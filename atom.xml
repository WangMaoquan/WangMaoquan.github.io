<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王小明</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.decade.run/"/>
  <updated>2021-04-06T07:54:06.691Z</updated>
  <id>http://blog.decade.run/</id>
  
  <author>
    <name>Decade W</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue3 源码阅读(一)</title>
    <link href="http://blog.decade.run/2021/04/06/vue3-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80/"/>
    <id>http://blog.decade.run/2021/04/06/vue3-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E4%B8%80/</id>
    <published>2021-04-06T07:50:56.000Z</published>
    <updated>2021-04-06T07:54:06.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从创建到挂载完成"><a href="#从创建到挂载完成" class="headerlink" title="从创建到挂载完成"></a>从创建到挂载完成</h1><p>我的初始模板: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; state.num &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../../dist/vue.global.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> &#123;</span></span><br><span class="line">    createApp,</span><br><span class="line">    reactive</span><br><span class="line"><span class="actionscript">  &#125; = <span class="keyword">this</span>.Vue;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">debugger</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> app = createApp(&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// composition api</span></span></span><br><span class="line">    setup() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line">        num: 1</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> state = reactive(obj)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">        state.num++;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        state,</span><br><span class="line">        handleClick</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">// option api</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// data() &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   return &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     num: 1</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// methods: &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   handleClick() &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     this.num++;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;,</span></span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="actionscript">  app.mount(<span class="string">"#app"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="createApp"><a href="#createApp" class="headerlink" title="createApp"></a>createApp</h2><p><code>packages/runtime-dom/src/index.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> renderer: Renderer&lt;Element&gt; | HydrationRenderer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个renderer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureRenderer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// render为undefined 走 createRenderer方法</span></span><br><span class="line">  <span class="keyword">return</span> renderer || (renderer = createRenderer&lt;Node, Element&gt;(rendererOptions))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入 isNativeTag 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectNativeTagCheck</span>(<span class="params">app: App</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Inject `isNativeTag`</span></span><br><span class="line">  <span class="comment">// this is used for component name validation (dev only)</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(app.config, <span class="string">'isNativeTag'</span>, &#123;</span><br><span class="line">    value: <span class="function">(<span class="params">tag: <span class="built_in">string</span></span>) =&gt;</span> isHTMLTag(tag) || isSVGTag(tag),</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function">(<span class="params">(<span class="params">...args</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 内部创建一个app</span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> app = ensureRenderer(<span class="params"></span>).createApp(<span class="params">...args</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">if</span> (<span class="params">__DEV__</span>) &#123; <span class="comment">// 开发环境下 注入isNativeTag 方法</span></span></span></span><br><span class="line"><span class="function"><span class="params">    injectNativeTagCheck(<span class="params">app</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 先保存 之前的mount方法 </span></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> &#123; mount &#125; = app</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// 重置 app的mount方法 </span></span></span></span><br><span class="line"><span class="function"><span class="params">  app.mount = (<span class="params">containerOrSelector: Element | ShadowRoot | <span class="built_in">string</span></span>): <span class="built_in">any</span> =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">// ...省略代码部分</span></span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">return</span> app <span class="comment">//返回一个app</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) <span class="params">as</span> <span class="params">CreateAppFunction</span>&lt;<span class="params">Element</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="createRenderer"><a href="#createRenderer" class="headerlink" title="createRenderer"></a>createRenderer</h3><p><code>packages/runtime-core/src/renderer.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入DOM的方法 调用 baseCreateRenderer 返回一个renderer</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRenderer</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">HostNode</span> = <span class="title">RendererNode</span>,</span></span><br><span class="line"><span class="function">  <span class="title">HostElement</span> = <span class="title">RendererElement</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params">options: RendererOptions&lt;HostNode, HostElement&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> baseCreateRenderer&lt;HostNode, HostElement&gt;(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// baseCreateRenderer重载 </span></span><br><span class="line"><span class="comment">// overload 1: no hydration 只有一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>&lt;</span></span><br><span class="line"><span class="function">  <span class="title">HostNode</span> = <span class="title">RendererNode</span>,</span></span><br><span class="line"><span class="function">  <span class="title">HostElement</span> = <span class="title">RendererElement</span></span></span><br><span class="line"><span class="function">&gt;(<span class="params">options: RendererOptions&lt;HostNode, HostElement&gt;</span>): <span class="title">Renderer</span>&lt;<span class="title">HostElement</span>&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">overload</span> 2: <span class="title">with</span> <span class="title">hydration</span> 两个参数 </span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="params">  options: RendererOptions&lt;Node, Element&gt;,</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="params">  createHydrationFns: <span class="keyword">typeof</span> createHydrationFunctions</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="params"></span>): <span class="title">HydrationRenderer</span></span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function">// <span class="title">implementation</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">baseCreateRenderer</span>(<span class="params"></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="params">  options: RendererOptions,</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="params">  createHydrationFns?: <span class="keyword">typeof</span> createHydrationFunctions</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="params"></span>): <span class="title">any</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  // <span class="title">compile</span>-<span class="title">time</span> <span class="title">feature</span> <span class="title">flags</span> <span class="title">check</span></span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params">__ESM_BUNDLER__ &amp;&amp; !__TEST__</span>) </span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">initFeatureFlags</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 取出操作<span class="title">DOM</span>的方法</span></span><br><span class="line"><span class="function">  <span class="title">const</span> </span>&#123;</span><br><span class="line">    insert: hostInsert,</span><br><span class="line">    remove: hostRemove,</span><br><span class="line">    patchProp: hostPatchProp,</span><br><span class="line">    forcePatchProp: hostForcePatchProp,</span><br><span class="line">    createElement: hostCreateElement,</span><br><span class="line">    createText: hostCreateText,</span><br><span class="line">    createComment: hostCreateComment,</span><br><span class="line">    setText: hostSetText,</span><br><span class="line">    setElementText: hostSetElementText,</span><br><span class="line">    parentNode: hostParentNode,</span><br><span class="line">    nextSibling: hostNextSibling,</span><br><span class="line">    setScopeId: hostSetScopeId = NOOP,</span><br><span class="line">    cloneNode: hostCloneNode,</span><br><span class="line">    insertStaticContent: hostInsertStaticContent</span><br><span class="line">  &#125; = options</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: functions inside this closure should use `const xxx = () =&gt; &#123;&#125;`</span></span><br><span class="line">  <span class="comment">// style in order to prevent being inlined by minifiers.</span></span><br><span class="line">  <span class="comment">// patch方法</span></span><br><span class="line">  <span class="keyword">const</span> patch: PatchFn = (</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    anchor = <span class="literal">null</span>,</span><br><span class="line">    parentComponent = <span class="literal">null</span>,</span><br><span class="line">    parentSuspense = <span class="literal">null</span>,</span><br><span class="line">    isSVG = <span class="literal">false</span>,</span><br><span class="line">    optimized = <span class="literal">false</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  省略很多代码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// render方法</span></span><br><span class="line">  <span class="keyword">const</span> render: RootRenderFunction = <span class="function">(<span class="params">vnode, container</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> internals: RendererInternals = &#123;</span><br><span class="line">    p: patch,</span><br><span class="line">    um: unmount,</span><br><span class="line">    m: move,</span><br><span class="line">    r: remove,</span><br><span class="line">    mt: mountComponent,</span><br><span class="line">    mc: mountChildren,</span><br><span class="line">    pc: patchChildren,</span><br><span class="line">    pbc: patchBlockChildren,</span><br><span class="line">    n: getNextHostNode,</span><br><span class="line">    o: options</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hydrate: ReturnType&lt;<span class="keyword">typeof</span> createHydrationFunctions&gt;[<span class="number">0</span>] | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">let</span> hydrateNode: ReturnType&lt;<span class="keyword">typeof</span> createHydrationFunctions&gt;[<span class="number">1</span>] | <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">if</span> (createHydrationFns) &#123; <span class="comment">// 是否有第二个参数 注水?? 这个操作我还是有点不明白</span></span><br><span class="line">    ;[hydrate, hydrateNode] = createHydrationFns(internals <span class="keyword">as</span> RendererInternals&lt;</span><br><span class="line">      Node,</span><br><span class="line">      Element</span><br><span class="line">    &gt;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个对象,</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render,</span><br><span class="line">    hydrate,</span><br><span class="line">    createApp: createAppAPI(render, hydrate) <span class="comment">// 调用 createAppAPI 方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createAppAPI"><a href="#createAppAPI" class="headerlink" title="createAppAPI"></a>createAppAPI</h3><p><code>packages/runtime-core/scr/apiCreateApp.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个上下文对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppContext</span>(<span class="params"></span>): <span class="title">AppContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    app: <span class="literal">null</span> <span class="keyword">as</span> <span class="built_in">any</span>, <span class="comment">// 实例</span></span><br><span class="line">    config: &#123;</span><br><span class="line">      isNativeTag: NO, <span class="comment">// NO 该方法永远返回false </span></span><br><span class="line">      performance: <span class="literal">false</span>, </span><br><span class="line">      globalProperties: &#123;&#125;, <span class="comment">// 挂载在全局属性上的 比如 app.config.globalProperties.$axios = axios</span></span><br><span class="line">      optionMergeStrategies: &#123;&#125;, <span class="comment">// option 合并策略</span></span><br><span class="line">      isCustomElement: NO,</span><br><span class="line">      errorHandler: <span class="literal">undefined</span>, <span class="comment">// 报错时的方法</span></span><br><span class="line">      warnHandler: <span class="literal">undefined</span> <span class="comment">// 警告时的方法</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mixins: [], <span class="comment">// mixins数组</span></span><br><span class="line">    components: &#123;&#125;, <span class="comment">// 组件</span></span><br><span class="line">    directives: &#123;&#125;, <span class="comment">// 指令</span></span><br><span class="line">    provides: <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 注入 provide/inject</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是一个createApp方法 这个方法 返回一个app对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAppAPI</span>&lt;<span class="title">HostElement</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  render: RootRenderFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate?: RootHydrateFunction</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">CreateAppFunction</span>&lt;<span class="title">HostElement</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">rootComponent, rootProps = <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rootProps != <span class="literal">null</span> &amp;&amp; !isObject(rootProps)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp; warn(<span class="string">`root props passed to app.mount() must be an object.`</span>)</span><br><span class="line">      rootProps = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> context = createAppContext() <span class="comment">// 初始化上下文</span></span><br><span class="line">    <span class="keyword">const</span> installedPlugins = <span class="keyword">new</span> Set() <span class="comment">// 插件是一个set集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isMounted = <span class="literal">false</span> <span class="comment">// 初始挂载状态为false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 app</span></span><br><span class="line">    <span class="keyword">const</span> app: App = (context.app = &#123;</span><br><span class="line">      _uid: uid++, <span class="comment">// uid自增</span></span><br><span class="line">      _component: rootComponent <span class="keyword">as</span> ConcreteComponent, <span class="comment">// 传入的 &#123; setup() &#123; return &#123;xxx&#125; &#125; &#125; 这样的对象</span></span><br><span class="line">      _props: rootProps,</span><br><span class="line">      _container: <span class="literal">null</span>,</span><br><span class="line">      _context: context, <span class="comment">// 上下文</span></span><br><span class="line"></span><br><span class="line">      version,</span><br><span class="line"></span><br><span class="line">      <span class="keyword">get</span> config() &#123;</span><br><span class="line">        <span class="keyword">return</span> context.config <span class="comment">// app.config.globalProperties.$axios = axios</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 不允许修改</span></span><br><span class="line">      <span class="keyword">set</span> config(v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`app.config cannot be replaced. Modify individual options instead.`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// use方法 安装插件 返回app本身</span></span><br><span class="line">      use(plugin: Plugin, ...options: <span class="built_in">any</span>[]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (installedPlugins.has(plugin)) &#123; <span class="comment">// 避免重复安装</span></span><br><span class="line">          __DEV__ &amp;&amp; warn(<span class="string">`Plugin has already been applied to target app.`</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plugin &amp;&amp; isFunction(plugin.install)) &#123; <span class="comment">// plugin可以是一个对象但必须有install这个属性 且必须是一个方法</span></span><br><span class="line">          installedPlugins.add(plugin) <span class="comment">// 放入set集合</span></span><br><span class="line">          plugin.install(app, ...options) <span class="comment">// 调用自己的 install 方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(plugin)) &#123; <span class="comment">// plugin就是一个方法</span></span><br><span class="line">          installedPlugins.add(plugin) <span class="comment">// 放入set 集合</span></span><br><span class="line">          plugin(app, ...options) <span class="comment">// 执行方法</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`A plugin must either be a function or an object with an "install" `</span> +</span><br><span class="line">              <span class="string">`function.`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 混入方法</span></span><br><span class="line">      mixin(mixin: ComponentOptions) &#123;</span><br><span class="line">        <span class="comment">// 如果是optionApi 就能用</span></span><br><span class="line">        <span class="keyword">if</span> (__FEATURE_OPTIONS_API__) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!context.mixins.includes(mixin)) &#123; <span class="comment">// 如果不存在</span></span><br><span class="line">            context.mixins.push(mixin) <span class="comment">// 添加进去</span></span><br><span class="line">            <span class="comment">// global mixin with props/emits de-optimizes props/emits</span></span><br><span class="line">            <span class="comment">// normalization caching.</span></span><br><span class="line">            <span class="keyword">if</span> (mixin.props || mixin.emits) &#123;</span><br><span class="line">              context.deopt = <span class="literal">true</span> <span class="comment">// 反优化</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">'Mixin has already been applied to target app'</span> +</span><br><span class="line">                (mixin.name ? <span class="string">`: <span class="subst">$&#123;mixin.name&#125;</span>`</span> : <span class="string">''</span>)</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(<span class="string">'Mixins are only available in builds supporting Options API'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册组件 / 获取组件</span></span><br><span class="line">      component(name: <span class="built_in">string</span>, component?: Component): <span class="built_in">any</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          validateComponentName(name, context.config) <span class="comment">// 验证组件名称</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!component) &#123; <span class="comment">// 第二个参数不存在, 返回组件</span></span><br><span class="line">          <span class="keyword">return</span> context.components[name]  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; context.components[name]) &#123; <span class="comment">// 组件存在 警告</span></span><br><span class="line">          warn(<span class="string">`Component "<span class="subst">$&#123;name&#125;</span>" has already been registered in target app.`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        context.components[name] = component <span class="comment">// 注册成功</span></span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注册 指令 / 返回指令</span></span><br><span class="line">      directive(name: <span class="built_in">string</span>, directive?: Directive) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          validateDirectiveName(name) <span class="comment">// 验证指令名称</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!directive) &#123; <span class="comment">// 第二个参数不存在 返回指令</span></span><br><span class="line">          <span class="keyword">return</span> context.directives[name] <span class="keyword">as</span> <span class="built_in">any</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; context.directives[name]) &#123; <span class="comment">// 指令已经存在 警告</span></span><br><span class="line">          warn(<span class="string">`Directive "<span class="subst">$&#123;name&#125;</span>" has already been registered in target app.`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        context.directives[name] = directive <span class="comment">// 注册成功</span></span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 挂载的方法</span></span><br><span class="line">      mount(rootContainer: HostElement, isHydrate?: <span class="built_in">boolean</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">        <span class="comment">// 省略代码部分</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 移出的方法</span></span><br><span class="line">      unmount() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMounted) &#123; <span class="comment">// 确定已经挂载过了的 才能执行该方法</span></span><br><span class="line">          render(<span class="literal">null</span>, app._container)</span><br><span class="line">          <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">            devtoolsUnmountApp(app) </span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(<span class="string">`Cannot unmount an app that is not mounted.`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// provide 方法</span></span><br><span class="line">      provide(key, value) &#123;</span><br><span class="line">        <span class="comment">// 检测是否注册过 提示注册过的会被修改成新值</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; (key <span class="keyword">as</span> <span class="built_in">string</span> | symbol) <span class="keyword">in</span> context.provides) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`App already provides property with key "<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>". `</span> +</span><br><span class="line">              <span class="string">`It will be overwritten with the new value.`</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TypeScript doesn't allow symbols as index type</span></span><br><span class="line">        <span class="comment">// https://github.com/Microsoft/TypeScript/issues/24587</span></span><br><span class="line">        context.provides[key <span class="keyword">as</span> <span class="built_in">string</span>] = value <span class="comment">// 加到provides里面</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>当我们执行 <strong><code>app.mount(&quot;#app&quot;)</code></strong> 方法 会进入到下面的代码里面, 我把关键的代码留下来, 其实这个方法的返回值是之前没有重写的<code>mount</code> 方法的返回值</p><p>修改之后的<code>mount</code>在 <code>packages/runtime-dom/index.ts</code></p><p>修改之前的<code>mount</code>在<code>packages/runtime-core/src/apiCreateApp.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个DOM或者null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: Element | ShadowRoot | <span class="built_in">string</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Element</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isString(container)) &#123; <span class="comment">// 如果是字符串 如 "#app"</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">document</span>.querySelector(container) <span class="comment">// 获取DOM</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !res) &#123; <span class="comment">// 开发环境下没有获取到 警告</span></span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Failed to mount app: mount target selector "<span class="subst">$&#123;container&#125;</span>" returned null.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果继承 ShadowRoot 且 mode属性为 closed 警告</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    __DEV__ &amp;&amp;</span><br><span class="line">    container <span class="keyword">instanceof</span> ShadowRoot &amp;&amp;</span><br><span class="line">    container.mode === <span class="string">'closed'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`mounting on a ShadowRoot with \`&#123;mode: "closed"&#125;\` may lead to unpredictable bugs`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> container <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写的mount方法</span></span><br><span class="line">app.mount = (containerOrSelector: Element | ShadowRoot | <span class="built_in">string</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container =  normalizeContainer(containerOrSelector)</span><br><span class="line">    <span class="keyword">if</span> (!container) <span class="keyword">return</span> <span class="comment">// 直接return</span></span><br><span class="line">    <span class="keyword">const</span> component = app._component <span class="comment">// 获取app的_componet属性 这里就是我们的 setup函数所在的那个对象</span></span><br><span class="line">    <span class="keyword">if</span> (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123; <span class="comment">// 这个对象没有不是函数, 没有render方法, 没有template </span></span><br><span class="line">      component.template = container.innerHTML <span class="comment">// 则将获取到的DOM作为 template属性的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear content before mounting</span></span><br><span class="line">    container.innerHTML = <span class="string">''</span> <span class="comment">// 清空</span></span><br><span class="line">    <span class="keyword">const</span> proxy = mount(container) <span class="comment">// 执行之前保存的mount方法</span></span><br><span class="line">    <span class="keyword">if</span> (container <span class="keyword">instanceof</span> Element) &#123; <span class="comment">// 如果 container 继承 Element</span></span><br><span class="line">      container.removeAttribute(<span class="string">'v-cloak'</span>) <span class="comment">// 移出v-cloak属性</span></span><br><span class="line">      container.setAttribute(<span class="string">'data-v-app'</span>, <span class="string">''</span>) <span class="comment">// 添加 data-v-app属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxy <span class="comment">// 返回mount结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原本的mount方法 </span></span><br><span class="line">mount(rootContainer: HostElement, isHydrate?: <span class="built_in">boolean</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isMounted) &#123; <span class="comment">// 没有挂载 创建根vnode</span></span><br><span class="line">    <span class="keyword">const</span> vnode = createVNode(</span><br><span class="line">      rootComponent <span class="keyword">as</span> ConcreteComponent,</span><br><span class="line">      rootProps</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// store app context on the root VNode.</span></span><br><span class="line">    <span class="comment">// this will be set on the root instance on initial mount.</span></span><br><span class="line">    vnode.appContext = context <span class="comment">// 加入上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HMR root reload </span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123; <span class="comment">// 开发环境下 自定义reload方法</span></span><br><span class="line">      context.reload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        render(cloneVNode(vnode), rootContainer)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注水 则调用 hydrate</span></span><br><span class="line">    <span class="keyword">if</span> (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">      hydrate(vnode <span class="keyword">as</span> VNode&lt;Node, Element&gt;, rootContainer <span class="keyword">as</span> <span class="built_in">any</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则调用render方法</span></span><br><span class="line">      render(vnode, rootContainer)</span><br><span class="line">    &#125;</span><br><span class="line">    isMounted = <span class="literal">true</span> <span class="comment">// render完毕 重置为true 当前组件已经挂载</span></span><br><span class="line">    app._container = rootContainer </span><br><span class="line">    <span class="comment">// for devtools and telemetry</span></span><br><span class="line">    <span class="comment">// __vue_app__ 属性指向自己</span></span><br><span class="line">    ;(rootContainer <span class="keyword">as</span> <span class="built_in">any</span>).__vue_app__ = app</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123; <span class="comment">// devtool工具</span></span><br><span class="line">      devtoolsInitApp(app, version)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> vnode.component!.proxy <span class="comment">// 返回一个vnode</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`App has already been mounted.\n`</span> +</span><br><span class="line">          <span class="string">`If you want to remount the same app, move your app creation logic `</span> +</span><br><span class="line">          <span class="string">`into a factory function and create fresh app instances for each `</span> +</span><br><span class="line">          <span class="string">`mount - e.g. \`const createMyApp = () =&gt; createApp(App)\``</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="createVNode"><a href="#createVNode" class="headerlink" title="createVNode"></a>createVNode</h3><p><code>packages/runtime-core/src/vnode.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发环境下 调用的 createVNodeWithArgsTransform</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createVNode = (__DEV__ ? createVNodeWithArgsTransform : _createVNode) <span class="keyword">as</span> <span class="keyword">typeof</span> _createVNode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是 _createVNode 方法完成后的值 vnodeArgsTransformer默认值为undefined </span></span><br><span class="line"><span class="keyword">const</span> createVNodeWithArgsTransform = (</span><br><span class="line">  ...args: Parameters&lt;<span class="keyword">typeof</span> _createVNode&gt;</span><br><span class="line">): <span class="function"><span class="params">VNode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> _createVNode(</span><br><span class="line">    ...(vnodeArgsTransformer</span><br><span class="line">      ? vnodeArgsTransformer(args, currentRenderingInstance)</span><br><span class="line">      : args)</span><br><span class="line">  ) <span class="comment">// 这里相当于调用的是 _createVNode(...args)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VNode类型会有一个 __v_isVNode这个属性为true</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isVNode</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">value</span> <span class="title">is</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value ? value.__v_isVNode === <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的值是function 并且有 __vccOpts 这个属性 该方法在packages/runtime-core/src/component.ts里面</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isClassComponent</span>(<span class="params">value: unknown</span>): <span class="title">value</span> <span class="title">is</span> <span class="title">ClassComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isFunction(value) &amp;&amp; <span class="string">'__vccOpts'</span> <span class="keyword">in</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出 键值key 对应的值 如果不为null 则返回 否则返回null</span></span><br><span class="line"><span class="keyword">const</span> normalizeKey = (&#123; key &#125;: VNodeProps): VNode[<span class="string">'key'</span>] =&gt;</span><br><span class="line">  key != <span class="literal">null</span> ? key : <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出 键值ref 对应的值 如果为null, 返回null, 不为null 且 是字符串或者是一个Ref 或者是一个方法, 返回一个对象, 否则返回本身</span></span><br><span class="line"><span class="keyword">const</span> normalizeRef = (&#123; ref &#125;: VNodeProps): VNodeNormalizedRefAtom | <span class="function"><span class="params">null</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (ref != <span class="literal">null</span></span><br><span class="line">    ? isString(ref) || isRef(ref) || isFunction(ref)</span><br><span class="line">      ? &#123; i: currentRenderingInstance, r: ref &#125;</span><br><span class="line">      : ref</span><br><span class="line">    : <span class="literal">null</span>) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常化子节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeChildren</span>(<span class="params">vnode: VNode, children: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">type</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> &#123; shapeFlag &#125; = vnode <span class="comment">// 取出 shapeFlag</span></span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123; <span class="comment">// 传入的children为null</span></span><br><span class="line">    children = <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(children)) &#123; </span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重新赋值</span></span><br><span class="line">  vnode.children = children <span class="keyword">as</span> VNodeNormalizedChildren</span><br><span class="line">  <span class="comment">// 改变vnode shapeFlag</span></span><br><span class="line">  vnode.shapeFlag |= <span class="keyword">type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数有6个 type与后面生成的shapeFlag有关, props是传入的属性, children是子元素/子组件数组, patchFlag 和patch有关, dynamicProps动态属性数组, 是否是blockNode</span></span><br><span class="line"><span class="comment">// 我们mount 传入进来的其实是那个 rootComponent 也就是我们传入createApp里面的那个对象 不过处理后 里面多了一个template属性 里面是我们的app的根元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createVNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: VNodeTypes | ClassComponent | <span class="keyword">typeof</span> NULL_DYNAMIC_COMPONENT,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: (Data &amp; VNodeProps) | <span class="literal">null</span> = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: unknown = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  patchFlag: <span class="built_in">number</span> = 0,</span></span></span><br><span class="line"><span class="function"><span class="params">  dynamicProps: <span class="built_in">string</span>[] | <span class="literal">null</span> = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isBlockNode = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遇到type不传 或者 类型是Symbol类型的 发出警告</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">type</span> || <span class="keyword">type</span> === NULL_DYNAMIC_COMPONENT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !<span class="keyword">type</span>) &#123;</span><br><span class="line">      warn(<span class="string">`Invalid vnode type when creating vnode: <span class="subst">$&#123;<span class="keyword">type</span>&#125;</span>.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">type</span> = Comment <span class="comment">// 并标记为 注释类型</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否是VNode</span></span><br><span class="line">  <span class="keyword">if</span> (isVNode(<span class="keyword">type</span>)) &#123;</span><br><span class="line">    <span class="comment">// createVNode receiving an existing vnode. This happens in cases like</span></span><br><span class="line">    <span class="comment">// &lt;component :is="vnode"/&gt;</span></span><br><span class="line">    <span class="comment">// #2078 make sure to merge refs during the clone instead of overwriting it</span></span><br><span class="line">    <span class="keyword">const</span> cloned = cloneVNode(<span class="keyword">type</span>, props, <span class="literal">true</span> <span class="comment">/* mergeRef: true */</span>)</span><br><span class="line">    <span class="keyword">if</span> (children) &#123;</span><br><span class="line">      normalizeChildren(cloned, children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloned</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断是否是classComponent</span></span><br><span class="line">  <span class="comment">// class component normalization.</span></span><br><span class="line">  <span class="keyword">if</span> (isClassComponent(<span class="keyword">type</span>)) &#123;</span><br><span class="line">    <span class="keyword">type</span> = <span class="keyword">type</span>.__vccOpts</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// props存在 则进入里面 </span></span><br><span class="line">  <span class="comment">// class &amp; style normalization.</span></span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    <span class="comment">// for reactive or proxy objects, we need to clone it to enable mutation.</span></span><br><span class="line">    <span class="keyword">if</span> (isProxy(props) || InternalObjectKey <span class="keyword">in</span> props) &#123;</span><br><span class="line">      props = extend(&#123;&#125;, props)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="keyword">class</span>: klass, style &#125; = props</span><br><span class="line">    <span class="keyword">if</span> (klass &amp;&amp; !isString(klass)) &#123;</span><br><span class="line">      props.class = normalizeClass(klass)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isObject(style)) &#123;</span><br><span class="line">      <span class="comment">// reactive state objects need to be cloned since they are likely to be</span></span><br><span class="line">      <span class="comment">// mutated</span></span><br><span class="line">      <span class="keyword">if</span> (isProxy(style) &amp;&amp; !isArray(style)) &#123;</span><br><span class="line">        style = extend(&#123;&#125;, style)</span><br><span class="line">      &#125;</span><br><span class="line">      props.style = normalizeStyle(style)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据type 来生成shapeFlag</span></span><br><span class="line">  <span class="comment">// encode the vnode type information into a bitmap</span></span><br><span class="line">  <span class="keyword">const</span> shapeFlag = isString(<span class="keyword">type</span>)</span><br><span class="line">    ? ShapeFlags.ELEMENT <span class="comment">// 元素 1</span></span><br><span class="line">    : __FEATURE_SUSPENSE__ &amp;&amp; isSuspense(<span class="keyword">type</span>) </span><br><span class="line">      ? ShapeFlags.SUSPENSE <span class="comment">// suspense 128</span></span><br><span class="line">      : isTeleport(<span class="keyword">type</span>)</span><br><span class="line">        ? ShapeFlags.TELEPORT <span class="comment">// teleport 64</span></span><br><span class="line">        : isObject(<span class="keyword">type</span>)</span><br><span class="line">          ? ShapeFlags.STATEFUL_COMPONENT <span class="comment">// 有状态的组件 4</span></span><br><span class="line">          : isFunction(<span class="keyword">type</span>)</span><br><span class="line">            ? ShapeFlags.FUNCTIONAL_COMPONENT <span class="comment">// 函数组件 2</span></span><br><span class="line">            : <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT 结果不为0 且不为响应式</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT &amp;&amp; isProxy(<span class="keyword">type</span>)) &#123;</span><br><span class="line">    <span class="keyword">type</span> = toRaw(<span class="keyword">type</span>)</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`Vue received a Component which was made a reactive object. This can `</span> +</span><br><span class="line">        <span class="string">`lead to unnecessary performance overhead, and should be avoided by `</span> +</span><br><span class="line">        <span class="string">`marking the component with \`markRaw\` or using \`shallowRef\` `</span> +</span><br><span class="line">        <span class="string">`instead of \`ref\`.`</span>,</span><br><span class="line">      <span class="string">`\nComponent that was made reactive: `</span>,</span><br><span class="line">      <span class="keyword">type</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建VNode</span></span><br><span class="line">  <span class="keyword">const</span> vnode: VNode = &#123;</span><br><span class="line">    __v_isVNode: <span class="literal">true</span>, <span class="comment">// 判断是否是VNode的标记</span></span><br><span class="line">    [ReactiveFlags.SKIP]: <span class="literal">true</span>, <span class="comment">// 后面跳过 reactive 会用到这个属性 标识VNode不是observable</span></span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    props, <span class="comment">// 属性信息</span></span><br><span class="line">    key: props &amp;&amp; normalizeKey(props),  <span class="comment">// 特殊 attribute 主要用在 Vue 的虚拟 DOM 算法</span></span><br><span class="line">    ref: props &amp;&amp; normalizeRef(props),  <span class="comment">// 被用来给元素或子组件注册引用信息。</span></span><br><span class="line">    scopeId: currentScopeId, <span class="comment">// SFC only</span></span><br><span class="line">    children: <span class="literal">null</span>, <span class="comment">// 保存子节点</span></span><br><span class="line">    component: <span class="literal">null</span>, <span class="comment">// 指向VNode对应的组件实例</span></span><br><span class="line">    suspense: <span class="literal">null</span>,</span><br><span class="line">    ssContent: <span class="literal">null</span>, </span><br><span class="line">    ssFallback: <span class="literal">null</span>,</span><br><span class="line">    dirs: <span class="literal">null</span>, <span class="comment">// 保存应用在VNode的指令信息</span></span><br><span class="line">    transition: <span class="literal">null</span>, <span class="comment">// 存储过渡效果信息</span></span><br><span class="line">    el: <span class="literal">null</span>, <span class="comment">// element </span></span><br><span class="line">    anchor: <span class="literal">null</span>, <span class="comment">// fragment 锚点</span></span><br><span class="line">    target: <span class="literal">null</span>, <span class="comment">// teleport 目标节点</span></span><br><span class="line">    targetAnchor: <span class="literal">null</span>,  <span class="comment">// teleport 目标锚点</span></span><br><span class="line">    staticCount: <span class="number">0</span>, <span class="comment">// 静态节点个数</span></span><br><span class="line">    shapeFlag, </span><br><span class="line">    patchFlag,</span><br><span class="line">    dynamicProps,</span><br><span class="line">    dynamicChildren: <span class="literal">null</span>,</span><br><span class="line">    appContext: <span class="literal">null</span> <span class="comment">// 上下文</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证key</span></span><br><span class="line">  <span class="comment">// validate key</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; vnode.key !== vnode.key) &#123;</span><br><span class="line">    warn(<span class="string">`VNode created with invalid key (NaN). VNode type:`</span>, vnode.type)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  normalizeChildren(vnode, children)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// normalize suspense children</span></span><br><span class="line">  <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; content, fallback &#125; = normalizeSuspenseChildren(vnode)</span><br><span class="line">    vnode.ssContent = content</span><br><span class="line">    vnode.ssFallback = fallback</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// currentBlock不存在 所以不会执行这里</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    shouldTrack &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    <span class="comment">// avoid a block node from tracking itself</span></span><br><span class="line">    !isBlockNode &amp;&amp;</span><br><span class="line">    <span class="comment">// has current parent block</span></span><br><span class="line">    currentBlock &amp;&amp;</span><br><span class="line">    <span class="comment">// presence of a patch flag indicates this node needs patching on updates.</span></span><br><span class="line">    <span class="comment">// component nodes also should always be patched, because even if the</span></span><br><span class="line">    <span class="comment">// component doesn't need to update, it needs to persist the instance on to</span></span><br><span class="line">    <span class="comment">// the next vnode so that it can be properly unmounted later.</span></span><br><span class="line">    (patchFlag &gt; <span class="number">0</span> || shapeFlag &amp; ShapeFlags.COMPONENT) &amp;&amp;</span><br><span class="line">    <span class="comment">// the EVENTS flag is only for hydration and if it is the only flag, the</span></span><br><span class="line">    <span class="comment">// vnode should not be considered dynamic due to handler caching.</span></span><br><span class="line">    patchFlag !== PatchFlags.HYDRATE_EVENTS</span><br><span class="line">  ) &#123;</span><br><span class="line">    currentBlock.push(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回vnode</span></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><p><code>packages/runtime-core/src/renderer.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入两个参数 一个vnode 一个根节点</span></span><br><span class="line"><span class="keyword">const</span> render: RootRenderFunction = <span class="function">(<span class="params">vnode, container</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode == <span class="literal">null</span>) &#123; <span class="comment">// 没有传第一个</span></span><br><span class="line">    <span class="keyword">if</span> (container._vnode) &#123; <span class="comment">// container有_vnode属性</span></span><br><span class="line">      unmount(container._vnode, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>) <span class="comment">// 卸载</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行patch方法 render方法执行的patch 第一个参数是为null的</span></span><br><span class="line">    patch(container._vnode || <span class="literal">null</span>, vnode, container) </span><br><span class="line">  &#125;</span><br><span class="line">  flushPostFlushCbs()</span><br><span class="line">  container._vnode = vnode <span class="comment">// 完成的vnode 挂载在 container _vnode上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> patch: PatchFn = (</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    anchor = <span class="literal">null</span>,</span><br><span class="line">    parentComponent = <span class="literal">null</span>,</span><br><span class="line">    parentSuspense = <span class="literal">null</span>,</span><br><span class="line">    isSVG = <span class="literal">false</span>,</span><br><span class="line">    optimized = <span class="literal">false</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// patching &amp; not same type, unmount old tree</span></span><br><span class="line">  <span class="comment">// n1 存在 且n1, n2 不是相同type的 直接卸载n1</span></span><br><span class="line">    <span class="keyword">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">      anchor = getNextHostNode(n1)</span><br><span class="line">      unmount(n1, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      n1 = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 n2.patchFlag === -1</span></span><br><span class="line">    <span class="keyword">if</span> (n2.patchFlag === PatchFlags.BAIL) &#123;</span><br><span class="line">      optimized = <span class="literal">false</span> </span><br><span class="line">      n2.dynamicChildren = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 type ref shapeFlag</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">type</span>, ref, shapeFlag &#125; = n2</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> Text: <span class="comment">// 处理文本节点</span></span><br><span class="line">        processText(n1, n2, container, anchor)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> Comment: <span class="comment">// 处理注释节点</span></span><br><span class="line">        processCommentNode(n1, n2, container, anchor)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> Static: <span class="comment">// 处理静态节点</span></span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">          mountStaticNode(n2, container, anchor, isSVG)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          patchStaticNode(n1, n2, container, isSVG)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> Fragment: <span class="comment">// 处理Fragment节点</span></span><br><span class="line">        processFragment(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ELEMENT) &#123; <span class="comment">// 处理元素节点</span></span><br><span class="line">          processElement(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.COMPONENT) &#123; <span class="comment">// 处理组件 ShapeFlags.COMPONENT是6  4 &amp; 6 为4 不为0满足 调用processComponent()方法</span></span><br><span class="line">          processComponent(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.TELEPORT) &#123; <span class="comment">// 处理teleport</span></span><br><span class="line">          ;(<span class="keyword">type</span> <span class="keyword">as</span> <span class="keyword">typeof</span> TeleportImpl).process(</span><br><span class="line">            n1 <span class="keyword">as</span> TeleportVNode,</span><br><span class="line">            n2 <span class="keyword">as</span> TeleportVNode,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized,</span><br><span class="line">            internals</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123; <span class="comment">// 处理 suspense</span></span><br><span class="line">          ;(<span class="keyword">type</span> <span class="keyword">as</span> <span class="keyword">typeof</span> SuspenseImpl).process(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized,</span><br><span class="line">            internals</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          warn(<span class="string">'Invalid VNode type:'</span>, <span class="keyword">type</span>, <span class="string">`(<span class="subst">$&#123;<span class="keyword">typeof</span> <span class="keyword">type</span>&#125;</span>)`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> processComponent = (</span><br><span class="line">    n1: VNode | <span class="literal">null</span>,</span><br><span class="line">    n2: VNode,</span><br><span class="line">    container: RendererElement,</span><br><span class="line">    anchor: RendererNode | <span class="literal">null</span>,</span><br><span class="line">    parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span><br><span class="line">    parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span><br><span class="line">    isSVG: <span class="built_in">boolean</span>,</span><br><span class="line">    optimized: <span class="built_in">boolean</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// n1不存在执行的是挂载</span></span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果是keep-alive组件</span></span><br><span class="line">      <span class="keyword">if</span> (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) &#123;</span><br><span class="line">        ;(parentComponent!.ctx <span class="keyword">as</span> KeepAliveContext).activate(</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行挂载组件方法</span></span><br><span class="line">        mountComponent(</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 存在走的是更新</span></span><br><span class="line">      updateComponent(n1, n2, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> mountComponent: MountComponentFn = (</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 初始化instance 并赋值给component属性</span></span><br><span class="line">    <span class="keyword">const</span> instance: ComponentInternalInstance = (initialVNode.component = createComponentInstance(</span><br><span class="line">      initialVNode,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开发环境 且 存在__hmrId</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; instance.type.__hmrId) &#123;</span><br><span class="line">      registerHMR(instance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      pushWarningContext(initialVNode) <span class="comment">// 推荐栈内</span></span><br><span class="line">      startMeasure(instance, <span class="string">`mount`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject renderer internals for keepAlive</span></span><br><span class="line">    <span class="comment">// 处理keepalive</span></span><br><span class="line">    <span class="keyword">if</span> (isKeepAlive(initialVNode)) &#123;</span><br><span class="line">      ;(instance.ctx <span class="keyword">as</span> KeepAliveContext).renderer = internals</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolve props and slots for setup context</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      startMeasure(instance, <span class="string">`init`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    setupComponent(instance)</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      endMeasure(instance, <span class="string">`init`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup() is async. This component relies on async logic to be resolved</span></span><br><span class="line">    <span class="comment">// before proceeding</span></span><br><span class="line">    <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; instance.asyncDep) &#123;</span><br><span class="line">      parentSuspense &amp;&amp; parentSuspense.registerDep(instance, setupRenderEffect)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Give it a placeholder if this is not hydration</span></span><br><span class="line">      <span class="comment">// TODO handle self-defined fallback</span></span><br><span class="line">      <span class="keyword">if</span> (!initialVNode.el) &#123;</span><br><span class="line">        <span class="keyword">const</span> placeholder = (instance.subTree = createVNode(Comment))</span><br><span class="line">        processCommentNode(<span class="literal">null</span>, placeholder, container!, anchor)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setupRenderEffect(</span><br><span class="line">      instance,</span><br><span class="line">      initialVNode,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      popWarningContext() <span class="comment">// 将当前的VNode弹出堆</span></span><br><span class="line">      endMeasure(instance, <span class="string">`mount`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="createComponentInstance"><a href="#createComponentInstance" class="headerlink" title="createComponentInstance"></a>createComponentInstance</h4><p><code>packages/runtime-core/src/component.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vnode: VNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  parent: ComponentInternalInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  suspense: SuspenseBoundary | <span class="literal">null</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">type</span> = vnode.type <span class="keyword">as</span> ConcreteComponent <span class="comment">// 获取type</span></span><br><span class="line">  <span class="comment">// inherit parent app context - or - if root, adopt from root vnode</span></span><br><span class="line">  <span class="comment">// 如果 parent不存在 则赋值vnode的appContext 如果也没有则为 emptyAppContext</span></span><br><span class="line">  <span class="keyword">const</span> appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化instance</span></span><br><span class="line">  <span class="keyword">const</span> instance: ComponentInternalInstance = &#123;</span><br><span class="line">    uid: uid++,</span><br><span class="line">    vnode,</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    parent,</span><br><span class="line">    appContext,</span><br><span class="line">    root: <span class="literal">null</span>!, <span class="comment">// to be immediately set</span></span><br><span class="line">    next: <span class="literal">null</span>,</span><br><span class="line">    subTree: <span class="literal">null</span>!, <span class="comment">// will be set synchronously right after creation 创建后立即同步设置</span></span><br><span class="line">    update: <span class="literal">null</span>!, <span class="comment">// will be set synchronously right after creation 创建后立即同步设置</span></span><br><span class="line">    render: <span class="literal">null</span>,</span><br><span class="line">    proxy: <span class="literal">null</span>,</span><br><span class="line">    exposed: <span class="literal">null</span>,</span><br><span class="line">    withProxy: <span class="literal">null</span>,</span><br><span class="line">    effects: <span class="literal">null</span>,</span><br><span class="line">    provides: parent ? parent.provides : <span class="built_in">Object</span>.create(appContext.provides), <span class="comment">// parent的不存在 就用appContext的</span></span><br><span class="line">    accessCache: <span class="literal">null</span>!,</span><br><span class="line">    renderCache: [], <span class="comment">// renderCache数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// local resovled assets</span></span><br><span class="line">    components: <span class="literal">null</span>, </span><br><span class="line">    directives: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolved props and emits options</span></span><br><span class="line">    propsOptions: normalizePropsOptions(<span class="keyword">type</span>, appContext),</span><br><span class="line">    emitsOptions: normalizeEmitsOptions(<span class="keyword">type</span>, appContext),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emit</span></span><br><span class="line">    emit: <span class="literal">null</span> <span class="keyword">as</span> <span class="built_in">any</span>, <span class="comment">// to be set immediately</span></span><br><span class="line">    emitted: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state</span></span><br><span class="line">    ctx: EMPTY_OBJ, <span class="comment">// 上下文对象</span></span><br><span class="line">    data: EMPTY_OBJ, </span><br><span class="line">    props: EMPTY_OBJ, <span class="comment">// 属性</span></span><br><span class="line">    attrs: EMPTY_OBJ, <span class="comment">// 属性</span></span><br><span class="line">    slots: EMPTY_OBJ, <span class="comment">// 插槽</span></span><br><span class="line">    refs: EMPTY_OBJ, <span class="comment">// ref</span></span><br><span class="line">    setupState: EMPTY_OBJ, </span><br><span class="line">    setupContext: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// suspense related</span></span><br><span class="line">    suspense,</span><br><span class="line">    suspenseId: suspense ? suspense.pendingId : <span class="number">0</span>,</span><br><span class="line">    asyncDep: <span class="literal">null</span>,</span><br><span class="line">    asyncResolved: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lifecycle hooks</span></span><br><span class="line">    <span class="comment">// not using enums here because it results in computed properties</span></span><br><span class="line">    isMounted: <span class="literal">false</span>,</span><br><span class="line">    isUnmounted: <span class="literal">false</span>,</span><br><span class="line">    isDeactivated: <span class="literal">false</span>,</span><br><span class="line">    bc: <span class="literal">null</span>, <span class="comment">//beforeCreate</span></span><br><span class="line">    c: <span class="literal">null</span>, <span class="comment">// created</span></span><br><span class="line">    bm: <span class="literal">null</span>, <span class="comment">// beforeMount</span></span><br><span class="line">    m: <span class="literal">null</span>, <span class="comment">// mounted</span></span><br><span class="line">    bu: <span class="literal">null</span>, <span class="comment">// beforeUpdate</span></span><br><span class="line">    u: <span class="literal">null</span>, <span class="comment">// updated</span></span><br><span class="line">    um: <span class="literal">null</span>, <span class="comment">// unmounted</span></span><br><span class="line">    bum: <span class="literal">null</span>, <span class="comment">// beforeUnmount</span></span><br><span class="line">    da: <span class="literal">null</span>, <span class="comment">// deactivated</span></span><br><span class="line">    a: <span class="literal">null</span>, <span class="comment">// activated </span></span><br><span class="line">    rtg: <span class="literal">null</span>, <span class="comment">// errorCaptured</span></span><br><span class="line">    rtc: <span class="literal">null</span>, <span class="comment">// renderTracked</span></span><br><span class="line">    ec: <span class="literal">null</span> <span class="comment">// errorCaptured</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123; <span class="comment">// 开发环境下 执行 createRenderContext方法</span></span><br><span class="line">    instance.ctx = createRenderContext(instance) <span class="comment">// ctx上就有了 $watch $data方法 还有了globalProperties上的属性</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    instance.ctx = &#123; _: instance &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  instance.root = parent ? parent.root : instance <span class="comment">// 如果parent存在 则为parent的root 否则挂载自己的instance</span></span><br><span class="line">  instance.emit = emit.bind(<span class="literal">null</span>, instance) <span class="comment">// 改变this指向instance</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">    devtoolsComponentAdded(instance)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 返回实例</span></span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="normalizePropsOptions"><a href="#normalizePropsOptions" class="headerlink" title="normalizePropsOptions"></a>normalizePropsOptions</h5><p><code>packages/runtime-core/src/componentProps.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizePropsOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  comp: ConcreteComponent,</span></span></span><br><span class="line"><span class="function"><span class="params">  appContext: AppContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  asMixin = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">NormalizedPropsOptions</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 只有在执行了app.mixin方法后 appContext.deopt才为true</span></span><br><span class="line">  <span class="comment">// 如果appContext.deopt为false 同时 comp存在__props属性 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!appContext.deopt &amp;&amp; comp.__props) &#123;</span><br><span class="line">    <span class="keyword">return</span> comp.__props</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> raw = comp.props <span class="comment">// 取出props</span></span><br><span class="line">  <span class="keyword">const</span> normalized: NormalizedPropsOptions[<span class="number">0</span>] = &#123;&#125; <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> needCastKeys: NormalizedPropsOptions[<span class="number">1</span>] = [] <span class="comment">// 需要改变的键值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// apply mixin/extends props</span></span><br><span class="line">  <span class="keyword">let</span> hasExtends = <span class="literal">false</span> <span class="comment">// 是否扩展</span></span><br><span class="line">  <span class="keyword">if</span> (__FEATURE_OPTIONS_API__ &amp;&amp; !isFunction(comp)) &#123;</span><br><span class="line">    <span class="comment">// 声明一个扩展属性方法</span></span><br><span class="line">    <span class="keyword">const</span> extendProps = <span class="function">(<span class="params">raw: ComponentOptions</span>) =&gt;</span> &#123;</span><br><span class="line">      hasExtends = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">const</span> [props, keys] = normalizePropsOptions(raw, appContext, <span class="literal">true</span>)</span><br><span class="line">      extend(normalized, props)</span><br><span class="line">      <span class="keyword">if</span> (keys) needCastKeys.push(...keys)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// asMixin 为false 且 appContext.mixins数组里面有mixin</span></span><br><span class="line">    <span class="keyword">if</span> (!asMixin &amp;&amp; appContext.mixins.length) &#123;</span><br><span class="line">      appContext.mixins.forEach(extendProps)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有extends属性</span></span><br><span class="line">    <span class="keyword">if</span> (comp.extends) &#123;</span><br><span class="line">      <span class="comment">// 执行</span></span><br><span class="line">      extendProps(comp.extends)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有mixins属性</span></span><br><span class="line">    <span class="keyword">if</span> (comp.mixins) &#123;</span><br><span class="line">      comp.mixins.forEach(extendProps)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果props不存在 且 没有扩展 则复制为空数组</span></span><br><span class="line">  <span class="keyword">if</span> (!raw &amp;&amp; !hasExtends) &#123;</span><br><span class="line">    <span class="keyword">return</span> (comp.__props = EMPTY_ARR <span class="keyword">as</span> <span class="built_in">any</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isArray(raw)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; raw.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; !isString(raw[i])) &#123;</span><br><span class="line">        warn(<span class="string">`props must be strings when using array syntax.`</span>, raw[i])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> normalizedKey = camelize(raw[i])</span><br><span class="line">      <span class="keyword">if</span> (validatePropName(normalizedKey)) &#123;</span><br><span class="line">        normalized[normalizedKey] = EMPTY_OBJ</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (raw) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !isObject(raw)) &#123;</span><br><span class="line">      warn(<span class="string">`invalid props options`</span>, raw)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> raw) &#123;</span><br><span class="line">      <span class="keyword">const</span> normalizedKey = camelize(key)</span><br><span class="line">      <span class="keyword">if</span> (validatePropName(normalizedKey)) &#123;</span><br><span class="line">        <span class="keyword">const</span> opt = raw[key]</span><br><span class="line">        <span class="keyword">const</span> prop: NormalizedProp = (normalized[normalizedKey] =</span><br><span class="line">          isArray(opt) || isFunction(opt) ? &#123; <span class="keyword">type</span>: opt &#125; : opt)</span><br><span class="line">        <span class="keyword">if</span> (prop) &#123;</span><br><span class="line">          <span class="keyword">const</span> booleanIndex = getTypeIndex(<span class="built_in">Boolean</span>, prop.type)</span><br><span class="line">          <span class="keyword">const</span> stringIndex = getTypeIndex(<span class="built_in">String</span>, prop.type)</span><br><span class="line">          prop[BooleanFlags.shouldCast] = booleanIndex &gt; <span class="number">-1</span></span><br><span class="line">          prop[BooleanFlags.shouldCastTrue] =</span><br><span class="line">            stringIndex &lt; <span class="number">0</span> || booleanIndex &lt; stringIndex</span><br><span class="line">          <span class="comment">// if the prop needs boolean casting or default value</span></span><br><span class="line">          <span class="keyword">if</span> (booleanIndex &gt; <span class="number">-1</span> || hasOwn(prop, <span class="string">'default'</span>)) &#123;</span><br><span class="line">            needCastKeys.push(normalizedKey)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (comp.__props = [normalized, needCastKeys])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="normalizeEmitsOptions"><a href="#normalizeEmitsOptions" class="headerlink" title="normalizeEmitsOptions"></a>normalizeEmitsOptions</h5><p><code>packages/runtime-core/src/componentEmits.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeEmitsOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  comp: ConcreteComponent,</span></span></span><br><span class="line"><span class="function"><span class="params">  appContext: AppContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  asMixin = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ObjectEmitsOptions</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!appContext.deopt &amp;&amp; comp.__emits !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> comp.__emits</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> raw = comp.emits <span class="comment">// 获取emits</span></span><br><span class="line">  <span class="keyword">let</span> normalized: ObjectEmitsOptions = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// apply mixin/extends props</span></span><br><span class="line">  <span class="keyword">let</span> hasExtends = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (__FEATURE_OPTIONS_API__ &amp;&amp; !isFunction(comp)) &#123;</span><br><span class="line">    <span class="keyword">const</span> extendEmits = <span class="function">(<span class="params">raw: ComponentOptions</span>) =&gt;</span> &#123;</span><br><span class="line">      hasExtends = <span class="literal">true</span></span><br><span class="line">      extend(normalized, normalizeEmitsOptions(raw, appContext, <span class="literal">true</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!asMixin &amp;&amp; appContext.mixins.length) &#123;</span><br><span class="line">      appContext.mixins.forEach(extendEmits)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (comp.extends) &#123;</span><br><span class="line">      extendEmits(comp.extends)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (comp.mixins) &#123;</span><br><span class="line">      comp.mixins.forEach(extendEmits)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值为null</span></span><br><span class="line">  <span class="keyword">if</span> (!raw &amp;&amp; !hasExtends) &#123;</span><br><span class="line">    <span class="keyword">return</span> (comp.__emits = <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isArray(raw)) &#123;</span><br><span class="line">    raw.forEach(<span class="function"><span class="params">key</span> =&gt;</span> (normalized[key] = <span class="literal">null</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    extend(normalized, raw)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (comp.__emits = normalized)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="createRenderContext"><a href="#createRenderContext" class="headerlink" title="createRenderContext"></a>createRenderContext</h5><p><code>packages/runtime-core/src/componentPublicInstance.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> publicPropertiesMap: PublicPropertiesMap = extend(<span class="built_in">Object</span>.create(<span class="literal">null</span>), &#123;</span><br><span class="line">  $: <span class="function"><span class="params">i</span> =&gt;</span> i,</span><br><span class="line">  $el: <span class="function"><span class="params">i</span> =&gt;</span> i.vnode.el,</span><br><span class="line">  $data: <span class="function"><span class="params">i</span> =&gt;</span> i.data,</span><br><span class="line">  $props: <span class="function"><span class="params">i</span> =&gt;</span> (__DEV__ ? shallowReadonly(i.props) : i.props),</span><br><span class="line">  $attrs: <span class="function"><span class="params">i</span> =&gt;</span> (__DEV__ ? shallowReadonly(i.attrs) : i.attrs),</span><br><span class="line">  $slots: <span class="function"><span class="params">i</span> =&gt;</span> (__DEV__ ? shallowReadonly(i.slots) : i.slots),</span><br><span class="line">  $refs: <span class="function"><span class="params">i</span> =&gt;</span> (__DEV__ ? shallowReadonly(i.refs) : i.refs),</span><br><span class="line">  $parent: <span class="function"><span class="params">i</span> =&gt;</span> getPublicInstance(i.parent),</span><br><span class="line">  $root: <span class="function"><span class="params">i</span> =&gt;</span> i.root &amp;&amp; i.root.proxy,</span><br><span class="line">  $emit: <span class="function"><span class="params">i</span> =&gt;</span> i.emit,</span><br><span class="line">  $options: <span class="function"><span class="params">i</span> =&gt;</span> (__FEATURE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),</span><br><span class="line">  $forceUpdate: <span class="function"><span class="params">i</span> =&gt;</span> () =&gt; queueJob(i.update),</span><br><span class="line">  $nextTick: <span class="function"><span class="params">i</span> =&gt;</span> nextTick.bind(i.proxy!),</span><br><span class="line">  $watch: <span class="function"><span class="params">i</span> =&gt;</span> (__FEATURE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)</span><br><span class="line">&#125; <span class="keyword">as</span> PublicPropertiesMap)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createRenderContext</span>(<span class="params">instance: ComponentInternalInstance</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> target: Record&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt; = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose internal instance for proxy handlers</span></span><br><span class="line">  <span class="comment">// target._ 获取 当前的instance</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, <span class="string">`_`</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> instance</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose public properties</span></span><br><span class="line">  <span class="comment">// 给tagert上挂载上 map中的键值对应的方法</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(publicPropertiesMap).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> publicPropertiesMap[key](instance),</span><br><span class="line">      <span class="comment">// intercepted by the proxy so no need for implementation,</span></span><br><span class="line">      <span class="comment">// but needed to prevent set errors</span></span><br><span class="line">      <span class="keyword">set</span>: NOOP</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose global properties</span></span><br><span class="line">  <span class="comment">// 取出 globalProperties 挂载在target上</span></span><br><span class="line">  <span class="keyword">const</span> &#123; globalProperties &#125; = instance.appContext.config</span><br><span class="line">  <span class="built_in">Object</span>.keys(globalProperties).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> globalProperties[key],</span><br><span class="line">      <span class="keyword">set</span>: NOOP</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target <span class="keyword">as</span> ComponentRenderContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setupComponent"><a href="#setupComponent" class="headerlink" title="setupComponent"></a>setupComponent</h4><p><code>packages/runtime-core/src/component.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setupComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  isInSSRComponentSetup = isSSR <span class="comment">// 是否是SSR</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出props children shapeFlag</span></span><br><span class="line">  <span class="keyword">const</span> &#123; props, children, shapeFlag &#125; = instance.vnode</span><br><span class="line">  <span class="keyword">const</span> isStateful = shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT <span class="comment">// 这里是 4 &amp; 4 = 4</span></span><br><span class="line">  initProps(instance, props, isStateful, isSSR) <span class="comment">// 初始化props</span></span><br><span class="line">  initSlots(instance, children) <span class="comment">// 初始化slots</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有状态的 所以执行 setupStatefulComponent</span></span><br><span class="line">  <span class="keyword">const</span> setupResult = isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR)</span><br><span class="line">    : <span class="literal">undefined</span></span><br><span class="line">  isInSSRComponentSetup = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> setupResult </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h5><p><code>packages/runtime-core/src/componentProps.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initProps</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  rawProps: Data | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  isStateful: <span class="built_in">number</span>, <span class="comment">// result of bitwise flag comparison</span></span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR = <span class="literal">false</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> props: Data = &#123;&#125; <span class="comment">// 放props</span></span><br><span class="line">  <span class="keyword">const</span> attrs: Data = &#123;&#125; <span class="comment">// 放attrs</span></span><br><span class="line">  def(attrs, InternalObjectKey, <span class="number">1</span>) <span class="comment">// attrs: &#123; __vInternal: 1 &#125;</span></span><br><span class="line">  setFullProps(instance, rawProps, props, attrs)</span><br><span class="line">  <span class="comment">// validation</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123; <span class="comment">// 开发环境下 验证props</span></span><br><span class="line">    validateProps(props, instance)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isStateful) &#123; <span class="comment">// 是否是有状态的</span></span><br><span class="line">    <span class="comment">// stateful</span></span><br><span class="line">    instance.props = isSSR ? props : shallowReactive(props) <span class="comment">// 会用shallowReactive方法 这里后面 分析响应式的再说吧</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.type.props) &#123;</span><br><span class="line">      <span class="comment">// functional w/ optional props, props === attrs</span></span><br><span class="line">      instance.props = attrs</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// functional w/ declared props</span></span><br><span class="line">      instance.props = props</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  instance.attrs = attrs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setFullProps</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  rawProps: Data | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  props: Data,</span></span></span><br><span class="line"><span class="function"><span class="params">  attrs: Data</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [options, needCastKeys] = instance.propsOptions <span class="comment">// 取出</span></span><br><span class="line">  <span class="keyword">if</span> (rawProps) &#123; <span class="comment">// 存在</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> rawProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = rawProps[key]</span><br><span class="line">      <span class="comment">// key, ref are reserved and never passed down</span></span><br><span class="line">      <span class="comment">// key, ref, onVnodeBeforeMount, onVnodeMounted, onVnodeBeforeUpdate, onVnodeUpdated, onVnodeBeforeUnmount, onVnodeUnmounted 这样的key会跳过</span></span><br><span class="line">      <span class="keyword">if</span> (isReservedProp(key)) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// prop option names are camelized during normalization, so to support</span></span><br><span class="line">      <span class="comment">// kebab -&gt; camel conversion here we need to camelize the key.</span></span><br><span class="line">      <span class="keyword">let</span> camelKey</span><br><span class="line">      <span class="comment">// 处理 props:["xxx"]这样的</span></span><br><span class="line">      <span class="keyword">if</span> (options &amp;&amp; hasOwn(options, (camelKey = camelize(key)))) &#123;</span><br><span class="line">        props[camelKey] = value</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isEmitListener(instance.emitsOptions, key)) &#123; <span class="comment">// 处理emit的事件名</span></span><br><span class="line">        <span class="comment">// Any non-declared (either as a prop or an emitted event) props are put</span></span><br><span class="line">        <span class="comment">// into a separate `attrs` object for spreading. Make sure to preserve</span></span><br><span class="line">        <span class="comment">// original key casing</span></span><br><span class="line">        attrs[key] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (needCastKeys) &#123;</span><br><span class="line">    <span class="keyword">const</span> rawCurrentProps = toRaw(props)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; needCastKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = needCastKeys[i]</span><br><span class="line">      props[key] = resolvePropValue(</span><br><span class="line">        options!,</span><br><span class="line">        rawCurrentProps,</span><br><span class="line">        key,</span><br><span class="line">        rawCurrentProps[key],</span><br><span class="line">        instance</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="initSlots"><a href="#initSlots" class="headerlink" title="initSlots"></a>initSlots</h5><p><code>packages/runtime-core/src/componentSlots.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> initSlots = (</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  children: VNodeNormalizedChildren</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 满足则继续 ShapeFlags.SLOTS_CHILDREN为32</span></span><br><span class="line">  <span class="keyword">if</span> (instance.vnode.shapeFlag &amp; ShapeFlags.SLOTS_CHILDREN) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">type</span> = (children <span class="keyword">as</span> RawSlots)._</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      instance.slots = children <span class="keyword">as</span> InternalSlots</span><br><span class="line">      <span class="comment">// make compiler marker non-enumerable</span></span><br><span class="line">      def(children <span class="keyword">as</span> InternalSlots, <span class="string">'_'</span>, <span class="keyword">type</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      normalizeObjectSlots(children <span class="keyword">as</span> RawSlots, (instance.slots = &#123;&#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    instance.slots = &#123;&#125; <span class="comment">// 赋值为空</span></span><br><span class="line">    <span class="keyword">if</span> (children) &#123;</span><br><span class="line">      normalizeVNodeSlots(instance, children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def(instance.slots, InternalObjectKey, <span class="number">1</span>); <span class="comment">// &#123; __vInternal: 1 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="setupStatefulComponent"><a href="#setupStatefulComponent" class="headerlink" title="setupStatefulComponent"></a>setupStatefulComponent</h5><p><code>packages/runtime-core/src/components.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupStatefulComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Component = instance.type <span class="keyword">as</span> ComponentOptions <span class="comment">// 获取type</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 开发环境下 如果我们传入的&#123; name:xxx, setup()&#123;&#125; &#125; 这个对象有name属性 , 这个name的值不能是内置的component/slot 或者是html标签或者svg</span></span><br><span class="line">    <span class="keyword">if</span> (Component.name) &#123;</span><br><span class="line">      validateComponentName(Component.name, instance.appContext.config)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Component.components) &#123;</span><br><span class="line">      <span class="keyword">const</span> names = <span class="built_in">Object</span>.keys(Component.components)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">        validateComponentName(names[i], instance.appContext.config)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有directives 验证每个directive是否是内置的指令</span></span><br><span class="line">    <span class="keyword">if</span> (Component.directives) &#123;</span><br><span class="line">      <span class="keyword">const</span> names = <span class="built_in">Object</span>.keys(Component.directives)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">        validateDirectiveName(names[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 0. create render proxy property access cache</span></span><br><span class="line">  <span class="comment">// 创建渲染代理属性访问缓存</span></span><br><span class="line">  instance.accessCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// 1. create public instance / render proxy</span></span><br><span class="line">  <span class="comment">// also mark it raw so it's never observed </span></span><br><span class="line">  <span class="comment">// 创建公共实例/渲染代理</span></span><br><span class="line">  <span class="comment">// PublicInstanceProxyHandlers 里面有三个方法 get / set / has</span></span><br><span class="line">  instance.proxy = <span class="keyword">new</span> Proxy(instance.ctx, PublicInstanceProxyHandlers)</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123; <span class="comment">// 开发环境下调用的</span></span><br><span class="line">    exposePropsOnRenderContext(instance)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. call setup()</span></span><br><span class="line">  <span class="keyword">const</span> &#123; setup &#125; = Component <span class="comment">// 取出setup方法</span></span><br><span class="line">  <span class="keyword">if</span> (setup) &#123;</span><br><span class="line">    <span class="comment">// 这里就是我们 传入的setup(props, ctx) &#123;  &#125; 这样访问的时候 才需要访问ctx上下文 这时的length肯定会大于1 才会去执行createSetupContext创建ctx,  否则赋值为null</span></span><br><span class="line">    <span class="keyword">const</span> setupContext = (instance.setupContext =</span><br><span class="line">      setup.length &gt; <span class="number">1</span> ? createSetupContext(instance) : <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    currentInstance = instance <span class="comment">// 赋值当前实例</span></span><br><span class="line">    pauseTracking() <span class="comment">// 暂停追踪</span></span><br><span class="line">    <span class="keyword">const</span> setupResult = callWithErrorHandling(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      ErrorCodes.SETUP_FUNCTION, <span class="comment">// 0</span></span><br><span class="line">      [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext] <span class="comment">// 开发环境下会将实例上的props shallowReadonly一下 具体过程我后面分析reactive时再来</span></span><br><span class="line">    )</span><br><span class="line">    resetTracking() <span class="comment">// 重置跟踪</span></span><br><span class="line">    currentInstance = <span class="literal">null</span> <span class="comment">// 重置当前实例为null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPromise(setupResult)) &#123; <span class="comment">// 判断这个结果是不是一个promise</span></span><br><span class="line">      <span class="keyword">if</span> (isSSR) &#123; <span class="comment">// 是不是SSR下</span></span><br><span class="line">        <span class="comment">// return the promise so server-renderer can wait on it</span></span><br><span class="line">        <span class="keyword">return</span> setupResult.then(<span class="function">(<span class="params">resolvedResult: unknown</span>) =&gt;</span> &#123;</span><br><span class="line">          handleSetupResult(instance, resolvedResult, isSSR)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__FEATURE_SUSPENSE__) &#123;</span><br><span class="line">        <span class="comment">// async setup returned Promise.</span></span><br><span class="line">        <span class="comment">// bail here and wait for re-entry.</span></span><br><span class="line">        instance.asyncDep = setupResult</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`setup() returned a Promise, but the version of Vue you are using `</span> +</span><br><span class="line">            <span class="string">`does not support it yet.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 执行 handleSetupResult</span></span><br><span class="line">      handleSetupResult(instance, setupResult, isSSR)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finishComponentSetup(instance, isSSR)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="exposePropsOnRenderContext"><a href="#exposePropsOnRenderContext" class="headerlink" title="exposePropsOnRenderContext"></a>exposePropsOnRenderContext</h6><p><code>packages/runtime-core/src/component.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">exposePropsOnRenderContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    ctx,</span><br><span class="line">    propsOptions: [propsOptions]</span><br><span class="line">  &#125; = instance</span><br><span class="line">  <span class="keyword">if</span> (propsOptions) &#123; <span class="comment">// 存在就挂载在上下文上</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(propsOptions).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(ctx, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> instance.props[key],</span><br><span class="line">        <span class="keyword">set</span>: NOOP</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="callWithErrorHandling"><a href="#callWithErrorHandling" class="headerlink" title="callWithErrorHandling"></a>callWithErrorHandling</h6><p><code>packages/runtime-core/src/errorHanding.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callWithErrorHandling</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  fn: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: ErrorTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  args?: unknown[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res <span class="comment">// 初始化一个结果</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    res = args ? fn(...args) : fn() <span class="comment">// 执行 setup函数</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    handleError(err, instance, <span class="keyword">type</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res <span class="comment">// 返回setup函数结果 这里返回结果就是setup return出来的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="handleSetupResult"><a href="#handleSetupResult" class="headerlink" title="handleSetupResult"></a>handleSetupResult</h6><p><code>packages/runtime-core/src/component.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">handleSetupResult</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  setupResult: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isFunction(setupResult)) &#123; <span class="comment">// setup返回的是一个render 函数</span></span><br><span class="line">    <span class="keyword">if</span> (__NODE_JS__ &amp;&amp; (instance.type <span class="keyword">as</span> ComponentOptions).__ssrInlineRender) &#123; <span class="comment">// 满足nodejs环境 并有__ssrInlineRender属性 为 true</span></span><br><span class="line">      instance.ssrRender = setupResult <span class="comment">// 赋值给ssrRender</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      instance.render = setupResult <span class="keyword">as</span> InternalRenderFunction <span class="comment">// 否则赋值给render</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject(setupResult)) &#123; <span class="comment">// 是对象</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; isVNode(setupResult)) &#123; <span class="comment">// 开发环境下返回的是一个VNode 叫你返回render</span></span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`setup() should not return VNodes directly - `</span> +</span><br><span class="line">          <span class="string">`return a render function instead.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// setup returned bindings.</span></span><br><span class="line">    <span class="comment">// assuming a render function compiled from template is present.</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123; <span class="comment">// 开发环境下 赋值给 devtoolsRawSetupState</span></span><br><span class="line">      instance.devtoolsRawSetupState = setupResult</span><br><span class="line">    &#125;</span><br><span class="line">    instance.setupState = proxyRefs(setupResult) <span class="comment">// proxyRefs 也留到后面将的时候再来吧 返回的是一个proxy对象</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123; <span class="comment">// 开发环境下</span></span><br><span class="line">      exposeSetupStateOnRenderContext(instance)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__ &amp;&amp; setupResult !== <span class="literal">undefined</span>) &#123; <span class="comment">// 不是对象不是方法 警告</span></span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`setup() should return an object. Received: <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        setupResult === <span class="literal">null</span> ? <span class="string">'null'</span> : <span class="keyword">typeof</span> setupResult</span></span></span><br><span class="line"><span class="string"><span class="subst">      &#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  finishComponentSetup(instance, isSSR)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>exposeSetupStateOnRenderContext</strong></p><p><code>packages/runtime-core/src/componentPublicInstance.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">exposeSetupStateOnRenderContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; ctx, setupState &#125; = instance</span><br><span class="line">  <span class="built_in">Object</span>.keys(toRaw(setupState)).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'$'</span> || key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123; <span class="comment">// 如果定义了 _ 或者 $ 开头的属性名 警告</span></span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`setup() return property <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(</span></span></span><br><span class="line"><span class="string"><span class="subst">          key</span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span> should not start with "$" or "_" `</span> +</span><br><span class="line">          <span class="string">`which are reserved prefixes for Vue internals.`</span></span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将属性挂载在 上下文ctx上面</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(ctx, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> setupState[key],</span><br><span class="line">      <span class="keyword">set</span>: NOOP</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>finishComponentSetup</strong></p><p><code>packages/runtime-core/src/component.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishComponentSetup</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  isSSR: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Component = instance.type <span class="keyword">as</span> ComponentOptions</span><br><span class="line"></span><br><span class="line">  <span class="comment">// template / render function normalization </span></span><br><span class="line">  <span class="comment">// node环境 且 是SSR</span></span><br><span class="line">  <span class="keyword">if</span> (__NODE_JS__ &amp;&amp; isSSR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Component.render) &#123;</span><br><span class="line">      instance.render = Component.render <span class="keyword">as</span> InternalRenderFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!instance.render) &#123; <span class="comment">// 如果setup没有返回一个函数 instance.render就是null</span></span><br><span class="line">    <span class="comment">// could be set from setup()</span></span><br><span class="line">    <span class="keyword">if</span> (compile &amp;&amp; Component.template &amp;&amp; !Component.render) &#123; <span class="comment">// complie方法存在 且template属性存在 且没有render方法</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`compile`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 通过template 生成render方法 compile 过程后面来分析</span></span><br><span class="line">      Component.render = compile(Component.template, &#123;</span><br><span class="line">        isCustomElement: instance.appContext.config.isCustomElement,</span><br><span class="line">        delimiters: Component.delimiters</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`compile`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将生成的render方法 赋值给实例上的render</span></span><br><span class="line">    instance.render = (Component.render || NOOP) <span class="keyword">as</span> InternalRenderFunction</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _rc 代表着这个render 是在runtime compile时生成的</span></span><br><span class="line">    <span class="keyword">if</span> (instance.render._rc) &#123;</span><br><span class="line">      instance.withProxy = <span class="keyword">new</span> Proxy(</span><br><span class="line">        instance.ctx,</span><br><span class="line">        RuntimeCompiledPublicInstanceProxyHandlers</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理optionApi的逻辑 重点是applyOptions方法</span></span><br><span class="line">  <span class="keyword">if</span> (__FEATURE_OPTIONS_API__) &#123;</span><br><span class="line">    currentInstance = instance <span class="comment">// 当前实例置为instance</span></span><br><span class="line">    pauseTracking() <span class="comment">// 暂停追踪</span></span><br><span class="line">    applyOptions(instance, Component) </span><br><span class="line">    resetTracking() <span class="comment">// 重新追踪</span></span><br><span class="line">    currentInstance = <span class="literal">null</span> <span class="comment">// 重置当前实例</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// warn missing template/render</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !Component.render &amp;&amp; instance.render === NOOP) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (!compile &amp;&amp; Component.template) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Component provided template option but `</span> +</span><br><span class="line">          <span class="string">`runtime compilation is not supported in this build of Vue.`</span> +</span><br><span class="line">          (__ESM_BUNDLER__</span><br><span class="line">            ? <span class="string">` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`</span></span><br><span class="line">            : __ESM_BROWSER__</span><br><span class="line">              ? <span class="string">` Use "vue.esm-browser.js" instead.`</span></span><br><span class="line">              : __GLOBAL__</span><br><span class="line">                ? <span class="string">` Use "vue.global.js" instead.`</span></span><br><span class="line">                : <span class="string">``</span>) <span class="comment">/* should not happen */</span></span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      warn(<span class="string">`Component is missing template or render function.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>applyOptions</strong></p><p><code>packages/runtime-core/src/componentOptions.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">applyOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ComponentOptions, <span class="comment">// 传入的&#123; data()&#123;&#125;, methods, ...&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params">  deferredData: DataFn[] = [],</span></span></span><br><span class="line"><span class="function"><span class="params">  deferredWatch: ComponentWatchOptions[] = [],</span></span></span><br><span class="line"><span class="function"><span class="params">  deferredProvide: (Data | <span class="built_in">Function</span>)[] = [],</span></span></span><br><span class="line"><span class="function"><span class="params">  asMixin: <span class="built_in">boolean</span> = <span class="literal">false</span> <span class="comment">// 是否是mixin</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// composition</span></span><br><span class="line">    mixins, </span><br><span class="line">    <span class="keyword">extends</span>: extendsOptions,</span><br><span class="line">    <span class="comment">// state</span></span><br><span class="line">    data: dataOptions,</span><br><span class="line">    computed: computedOptions,</span><br><span class="line">    methods,</span><br><span class="line">    watch: watchOptions,</span><br><span class="line">    provide: provideOptions,</span><br><span class="line">    inject: injectOptions,</span><br><span class="line">    <span class="comment">// assets</span></span><br><span class="line">    components,</span><br><span class="line">    directives,</span><br><span class="line">    <span class="comment">// lifecycle</span></span><br><span class="line">    beforeMount,</span><br><span class="line">    mounted,</span><br><span class="line">    beforeUpdate,</span><br><span class="line">    updated,</span><br><span class="line">    activated,</span><br><span class="line">    deactivated,</span><br><span class="line">    beforeDestroy,</span><br><span class="line">    beforeUnmount,</span><br><span class="line">    destroyed,</span><br><span class="line">    unmounted,</span><br><span class="line">    render,</span><br><span class="line">    renderTracked,</span><br><span class="line">    renderTriggered,</span><br><span class="line">    errorCaptured,</span><br><span class="line">    <span class="comment">// public API</span></span><br><span class="line">    expose</span><br><span class="line">  &#125; = options <span class="comment">// 取出那么多东西...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> publicThis = instance.proxy! <span class="comment">// 取出代理的实例</span></span><br><span class="line">  <span class="keyword">const</span> ctx = instance.ctx <span class="comment">// 取出上下文对象</span></span><br><span class="line">  <span class="keyword">const</span> globalMixins = instance.appContext.mixins <span class="comment">// 取出全局的mixins</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是mixin 且 option中 render 存在 且实例上的render 是NOOP, 将options中的render作为 实例的render</span></span><br><span class="line">  <span class="keyword">if</span> (asMixin &amp;&amp; render &amp;&amp; instance.render === NOOP) &#123;</span><br><span class="line">    instance.render = render <span class="keyword">as</span> InternalRenderFunction</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// applyOptions is called non-as-mixin once per instance</span></span><br><span class="line">  <span class="keyword">if</span> (!asMixin) &#123; <span class="comment">// 不是mixin</span></span><br><span class="line">    isInBeforeCreate = <span class="literal">true</span> <span class="comment">// 是在处于beforeCreate的状态</span></span><br><span class="line">    <span class="comment">// 调用beforeCreate 生命钩子函数</span></span><br><span class="line">    callSyncHook(</span><br><span class="line">      <span class="string">'beforeCreate'</span>,</span><br><span class="line">      LifecycleHooks.BEFORE_CREATE,</span><br><span class="line">      options,</span><br><span class="line">      instance,</span><br><span class="line">      globalMixins</span><br><span class="line">    ) <span class="comment">// 先调用全局的mixin里面的bc 然后调用组件里面的extends/mixins里面的bc, 最后调用自己写的bc</span></span><br><span class="line">    isInBeforeCreate = <span class="literal">false</span> <span class="comment">// beforeCreate过程结束</span></span><br><span class="line">    <span class="comment">// global mixins are applied first</span></span><br><span class="line">    applyMixins(</span><br><span class="line">      instance,</span><br><span class="line">      globalMixins,</span><br><span class="line">      deferredData,</span><br><span class="line">      deferredWatch,</span><br><span class="line">      deferredProvide</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extending a base component...</span></span><br><span class="line">  <span class="comment">// 组件本身上如果有extends 执行 applyOptions asMixin参数为true</span></span><br><span class="line">  <span class="keyword">if</span> (extendsOptions) &#123;</span><br><span class="line">    applyOptions(</span><br><span class="line">      instance,</span><br><span class="line">      extendsOptions,</span><br><span class="line">      deferredData,</span><br><span class="line">      deferredWatch,</span><br><span class="line">      deferredProvide,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 组件自己的 mixins</span></span><br><span class="line">  <span class="keyword">if</span> (mixins) &#123;</span><br><span class="line">    applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> checkDuplicateProperties = __DEV__ ? createDuplicateChecker() : <span class="literal">null</span> <span class="comment">// 开发环境下生成 重复key的检查函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123; <span class="comment">// 开发环境下</span></span><br><span class="line">    <span class="keyword">const</span> [propsOptions] = instance.propsOptions <span class="comment">// 取出属性</span></span><br><span class="line">    <span class="keyword">if</span> (propsOptions) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">        checkDuplicateProperties!(OptionTypes.PROPS, key) <span class="comment">// 检验属性里面的key是否已经被定义了</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尤大大给的3 兼容 2 这些属性的初始化顺序</span></span><br><span class="line">  <span class="comment">// options initialization order (to be consistent with Vue 2):</span></span><br><span class="line">  <span class="comment">// - props (already done outside of this function)</span></span><br><span class="line">  <span class="comment">// - inject</span></span><br><span class="line">  <span class="comment">// - methods</span></span><br><span class="line">  <span class="comment">// - data (deferred since it relies on `this` access)</span></span><br><span class="line">  <span class="comment">// - computed</span></span><br><span class="line">  <span class="comment">// - watch (deferred since it relies on `this` access)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存在inject</span></span><br><span class="line">  <span class="keyword">if</span> (injectOptions) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isArray(injectOptions)) &#123; <span class="comment">// 是数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; injectOptions.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = injectOptions[i]</span><br><span class="line">        ctx[key] = inject(key) <span class="comment">// 通过inject 挂载在上下文</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123; <span class="comment">// 开发环境下 </span></span><br><span class="line">          checkDuplicateProperties!(OptionTypes.INJECT, key) <span class="comment">// 检验key是否定义了</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> injectOptions) &#123; <span class="comment">// 取出key</span></span><br><span class="line">        <span class="keyword">const</span> opt = injectOptions[key]</span><br><span class="line">        <span class="keyword">if</span> (isObject(opt)) &#123; <span class="comment">// 判断是不是对象</span></span><br><span class="line">          ctx[key] = inject(</span><br><span class="line">            opt.from || key,</span><br><span class="line">            opt.default,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/* treat default function as factory */</span></span><br><span class="line">          ) <span class="comment">// 通过inject 挂载在上下文</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ctx[key] = inject(opt) <span class="comment">// 通过inject 挂载在上下文</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          checkDuplicateProperties!(OptionTypes.INJECT, key) <span class="comment">// 检验key是否定义了</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有methods</span></span><br><span class="line">  <span class="keyword">if</span> (methods) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">      <span class="keyword">const</span> methodHandler = (methods <span class="keyword">as</span> MethodOptions)[key] <span class="comment">// 获取</span></span><br><span class="line">      <span class="keyword">if</span> (isFunction(methodHandler)) &#123; <span class="comment">// 是不是函数</span></span><br><span class="line">        ctx[key] = methodHandler.bind(publicThis) <span class="comment">// 修改this</span></span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          checkDuplicateProperties!(OptionTypes.METHODS, key) <span class="comment">// 检验key是否定义了</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has type "<span class="subst">$&#123;<span class="keyword">typeof</span> methodHandler&#125;</span>" in the component definition. `</span> +</span><br><span class="line">            <span class="string">`Did you reference the function correctly?`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!asMixin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deferredData.length) &#123; <span class="comment">// deferredData 里面放的是 dataFn(data() &#123; return &#123;xxx: "xxx"&#125; &#125;)这样的</span></span><br><span class="line">      deferredData.forEach(<span class="function"><span class="params">dataFn</span> =&gt;</span> resolveData(instance, dataFn, publicThis))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dataOptions) &#123;</span><br><span class="line">      <span class="comment">// @ts-ignore dataOptions is not fully type safe</span></span><br><span class="line">      resolveData(instance, dataOptions, publicThis) <span class="comment">// 这是用户自己写的data() &#123; return &#123; xxx: "xxx" &#125; &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">const</span> rawData = toRaw(instance.data) <span class="comment">// 取出实例上的data</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> rawData) &#123;</span><br><span class="line">        checkDuplicateProperties!(OptionTypes.DATA, key) <span class="comment">// 验证是否定义了</span></span><br><span class="line">        <span class="comment">// expose data on ctx during dev</span></span><br><span class="line">        <span class="keyword">if</span> (key[<span class="number">0</span>] !== <span class="string">'$'</span> &amp;&amp; key[<span class="number">0</span>] !== <span class="string">'_'</span>) &#123; <span class="comment">// 不能是以 $ 或者 _ 打头的key</span></span><br><span class="line">          <span class="built_in">Object</span>.defineProperty(ctx, key, &#123;</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> rawData[key],</span><br><span class="line">            <span class="keyword">set</span>: NOOP</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataOptions) &#123; <span class="comment">// push 进 deferredData</span></span><br><span class="line">    deferredData.push(dataOptions <span class="keyword">as</span> DataFn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存在computed</span></span><br><span class="line">  <span class="keyword">if</span> (computedOptions) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computedOptions) &#123;</span><br><span class="line">      <span class="keyword">const</span> opt = (computedOptions <span class="keyword">as</span> ComputedOptions)[key] <span class="comment">// 拿到计算属性</span></span><br><span class="line">      <span class="comment">// 获取get</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">get</span> = isFunction(opt) </span><br><span class="line">        ? opt.bind(publicThis, publicThis) <span class="comment">// 是函数 绑定 publicThis, 传入publicThis</span></span><br><span class="line">        : isFunction(opt.get) <span class="comment">// 如果get属性是函数</span></span><br><span class="line">          ? opt.get.bind(publicThis, publicThis) <span class="comment">// 绑定 publicThis, 传入publicThis</span></span><br><span class="line">          : NOOP <span class="comment">// 返回一个空函数 () =&gt; &#123;&#125;</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; <span class="keyword">get</span> === NOOP) &#123; <span class="comment">// 没有getter</span></span><br><span class="line">        warn(<span class="string">`Computed property "<span class="subst">$&#123;key&#125;</span>" has no getter.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取set</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">set</span> =</span><br><span class="line">        !isFunction(opt) &amp;&amp; isFunction(opt.set)</span><br><span class="line">          ? opt.set.bind(publicThis) <span class="comment">// 不是函数 set且是方法</span></span><br><span class="line">          : __DEV__ <span class="comment">// 开发环境下设置默认的 函数</span></span><br><span class="line">            ? <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                warn(</span><br><span class="line">                  <span class="string">`Write operation failed: computed property "<span class="subst">$&#123;key&#125;</span>" is readonly.`</span></span><br><span class="line">                )</span><br><span class="line">              &#125;</span><br><span class="line">            : NOOP</span><br><span class="line">      <span class="comment">// emmm 后面分析 vue3 computed的实现</span></span><br><span class="line">      <span class="keyword">const</span> c = computed(&#123;</span><br><span class="line">        <span class="keyword">get</span>,</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 挂载在ctx上</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(ctx, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> c.value,</span><br><span class="line">        <span class="keyword">set</span>: <span class="function"><span class="params">v</span> =&gt;</span> (c.value = v)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        checkDuplicateProperties!(OptionTypes.COMPUTED, key) <span class="comment">// 验证是否定义了</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// watch</span></span><br><span class="line">  <span class="keyword">if</span> (watchOptions) &#123; </span><br><span class="line">    deferredWatch.push(watchOptions)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!asMixin &amp;&amp; deferredWatch.length) &#123;</span><br><span class="line">    deferredWatch.forEach(<span class="function"><span class="params">watchOptions</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watchOptions) &#123;</span><br><span class="line">        <span class="comment">// 创建watch emmm 后面分析</span></span><br><span class="line">        createWatcher(watchOptions[key], ctx, publicThis, key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// provide</span></span><br><span class="line">  <span class="keyword">if</span> (provideOptions) &#123;</span><br><span class="line">    deferredProvide.push(provideOptions)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!asMixin &amp;&amp; deferredProvide.length) &#123;</span><br><span class="line">    deferredProvide.forEach(<span class="function"><span class="params">provideOptions</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> provides = isFunction(provideOptions)</span><br><span class="line">        ? provideOptions.call(publicThis) <span class="comment">// 是方法 就执行改变this后的结果</span></span><br><span class="line">        : provideOptions</span><br><span class="line">      Reflect.ownKeys(provides).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        provide(key, provides[key]) <span class="comment">// 循环provide</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// asset options.</span></span><br><span class="line">  <span class="comment">// To reduce memory usage, only components with mixins or extends will have</span></span><br><span class="line">  <span class="comment">// resolved asset registry attached to instance.</span></span><br><span class="line">  <span class="comment">// 解析 mixin中的component, directive</span></span><br><span class="line">  <span class="keyword">if</span> (asMixin) &#123;</span><br><span class="line">    <span class="keyword">if</span> (components) &#123; <span class="comment">// 整合到实例的components里面</span></span><br><span class="line">      extend(</span><br><span class="line">        instance.components ||</span><br><span class="line">          (instance.components = extend(</span><br><span class="line">            &#123;&#125;,</span><br><span class="line">            (instance.type <span class="keyword">as</span> ComponentOptions).components</span><br><span class="line">          ) <span class="keyword">as</span> Record&lt;<span class="built_in">string</span>, ConcreteComponent&gt;),</span><br><span class="line">        components</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (directives) &#123; <span class="comment">// 整合到实例的directives里面</span></span><br><span class="line">      extend(</span><br><span class="line">        instance.directives ||</span><br><span class="line">          (instance.directives = extend(</span><br><span class="line">            &#123;&#125;,</span><br><span class="line">            (instance.type <span class="keyword">as</span> ComponentOptions).directives</span><br><span class="line">          )),</span><br><span class="line">        directives</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// lifecycle options</span></span><br><span class="line">  <span class="keyword">if</span> (!asMixin) &#123; <span class="comment">// 执行created钩子 顺序和 bc那里一样的</span></span><br><span class="line">    callSyncHook(</span><br><span class="line">      <span class="string">'created'</span>,</span><br><span class="line">      LifecycleHooks.CREATED,</span><br><span class="line">      options,</span><br><span class="line">      instance,</span><br><span class="line">      globalMixins</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 beforeMount 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (beforeMount) &#123; <span class="comment">// 当做回调函数 放入 onBeforeMount 钩子</span></span><br><span class="line">    onBeforeMount(beforeMount.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 mounted 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (mounted) &#123; <span class="comment">// 当做回调函数 放入 onMounted 钩子</span></span><br><span class="line">    onMounted(mounted.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 beforeUpdate 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (beforeUpdate) &#123; <span class="comment">// 当做回调函数 放入 onBeforeUpdate 钩子</span></span><br><span class="line">    onBeforeUpdate(beforeUpdate.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 updated 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (updated) &#123; <span class="comment">// 当做回调函数 放入 onUpdated 钩子</span></span><br><span class="line">    onUpdated(updated.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 activated 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (activated) &#123; <span class="comment">// 当做回调函数 放入 onActivated 钩子</span></span><br><span class="line">    onActivated(activated.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 deactivated 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (deactivated) &#123; <span class="comment">// 当做回调函数 放入 onDeactivated 钩子</span></span><br><span class="line">    onDeactivated(deactivated.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 errorCaptured 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (errorCaptured) &#123; <span class="comment">// 当做回调函数 放入 onErrorCaptured 钩子</span></span><br><span class="line">    onErrorCaptured(errorCaptured.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 renderTracked 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (renderTracked) &#123; <span class="comment">// 当做回调函数 放入 onRenderTracked 钩子</span></span><br><span class="line">    onRenderTracked(renderTracked.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 renderTriggered 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (renderTriggered) &#123; <span class="comment">// 当做回调函数 放入 onRenderTriggered 钩子</span></span><br><span class="line">    onRenderTriggered(renderTriggered.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开发环境下 有 beforeDestroy 警告一下</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; beforeDestroy) &#123;</span><br><span class="line">    warn(<span class="string">`\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存在 beforeUnmount 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (beforeUnmount) &#123; <span class="comment">// 当做回调函数 放入 onBeforeUnmount 钩子</span></span><br><span class="line">    onBeforeUnmount(beforeUnmount.bind(publicThis))</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 开发环境下 有 destroyed 警告一下</span></span><br><span class="line"><span class="keyword">if</span> (__DEV__ &amp;&amp; destroyed) &#123;</span><br><span class="line">    warn(<span class="string">`\`destroyed\` has been renamed to \`unmounted\`.`</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 存在 unmounted 钩子</span></span><br><span class="line">  <span class="keyword">if</span> (unmounted) &#123;  <span class="comment">// 当做回调函数 放入 onUnmounted 钩子</span></span><br><span class="line">    onUnmounted(unmounted.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存在expose</span></span><br><span class="line">  <span class="keyword">if</span> (isArray(expose)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!asMixin) &#123; <span class="comment">// 不是mixin</span></span><br><span class="line">      <span class="keyword">if</span> (expose.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> exposed = instance.exposed || (instance.exposed = proxyRefs(&#123;&#125;)) <span class="comment">// 取出实例上的expose</span></span><br><span class="line">        expose.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123; <span class="comment">// 遍历expose</span></span><br><span class="line">          exposed[key] = toRef(publicThis, key <span class="keyword">as</span> <span class="built_in">any</span>) <span class="comment">// 将 publicThis 上的key 对应的值 放到exposed对应的key值上</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!instance.exposed) &#123; <span class="comment">// 实例上不存在</span></span><br><span class="line">        instance.exposed = EMPTY_OBJ <span class="comment">// 赋值为空对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      warn(<span class="string">`The \`expose\` option is ignored when used in mixins.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>callSyncHook, callHookFromExtends, callHookFromMixins</strong></p><p><code>packages/runtime-core/src/componentOptions.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSyncHook</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: 'beforeCreate' | 'created',</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: LifecycleHooks,</span></span></span><br><span class="line"><span class="function"><span class="params">  options: ComponentOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  globalMixins: ComponentOptions[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  callHookFromMixins(name, <span class="keyword">type</span>, globalMixins, instance) <span class="comment">// 先从全局的mixin开始</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="keyword">extends</span>: base, mixins &#125; = options <span class="comment">// 取出 optionApi 中的 extends(base) 和 mixins</span></span><br><span class="line">  <span class="keyword">if</span> (base) &#123; <span class="comment">// 存在 调用 callHookFromExtends</span></span><br><span class="line">    callHookFromExtends(name, <span class="keyword">type</span>, base, instance)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mixins) &#123; <span class="comment">// 存在调用  callHookFromMixins</span></span><br><span class="line">    callHookFromMixins(name, <span class="keyword">type</span>, mixins, instance)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> selfHook = options[name] <span class="comment">// 获取用户自己写的 beforeCreate / created</span></span><br><span class="line">  <span class="keyword">if</span> (selfHook) &#123; <span class="comment">// 存在 就调用</span></span><br><span class="line">    callWithAsyncErrorHandling(selfHook.bind(instance.proxy!), instance, <span class="keyword">type</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHookFromExtends</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: 'beforeCreate' | 'created',</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: LifecycleHooks,</span></span></span><br><span class="line"><span class="function"><span class="params">  base: ComponentOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (base.extends) &#123; <span class="comment">// 如果带有extends 则执行 callHookFromExtends</span></span><br><span class="line">    callHookFromExtends(name, <span class="keyword">type</span>, base.extends, instance)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 拿到 全局中的mixin的 beforeCreate/created 方法</span></span><br><span class="line"><span class="keyword">const</span> baseHook = base[name]</span><br><span class="line">  <span class="keyword">if</span> (baseHook) &#123; <span class="comment">// 存在 则调用 callWithAsyncErrorHandling</span></span><br><span class="line">    callWithAsyncErrorHandling(baseHook.bind(instance.proxy!), instance, <span class="keyword">type</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHookFromMixins</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  name: 'beforeCreate' | 'created',</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: LifecycleHooks,</span></span></span><br><span class="line"><span class="function"><span class="params">  mixins: ComponentOptions[],</span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mixins.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> chainedMixins = mixins[i].mixins</span><br><span class="line">    <span class="keyword">if</span> (chainedMixins) &#123;</span><br><span class="line">      callHookFromMixins(name, <span class="keyword">type</span>, chainedMixins, instance)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> fn = mixins[i][name]</span><br><span class="line">    <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">      callWithAsyncErrorHandling(fn.bind(instance.proxy!), instance, <span class="keyword">type</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>callWithAsyncErrorHandling,  handleError,  logError</strong></p><p>  <code>packages/runtime-core/src/errorHandling.ts</code></p><pre><code><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callWithAsyncErrorHandling</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    fn: <span class="built_in">Function</span> | <span class="built_in">Function</span>[],</span></span></span><br><span class="line"><span class="function"><span class="params">    instance: ComponentInternalInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">type</span>: ErrorTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">    args?: unknown[]</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">any</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFunction(fn)) &#123; <span class="comment">// 如果是函数</span></span><br><span class="line">      <span class="keyword">const</span> res = callWithErrorHandling(fn, instance, <span class="keyword">type</span>, args) <span class="comment">// 拿到结果</span></span><br><span class="line">      <span class="keyword">if</span> (res &amp;&amp; isPromise(res)) &#123; <span class="comment">// 结果存在且是promise 成功捕获错误会调用 handleError</span></span><br><span class="line">        res.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          handleError(err, instance, <span class="keyword">type</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res <span class="comment">// 返回执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 说明传过来的是一个函数数组</span></span><br><span class="line">    <span class="keyword">const</span> values = [] <span class="comment">// 结果数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fn.length; i++) &#123;</span><br><span class="line">      values.push(callWithAsyncErrorHandling(fn[i], instance, <span class="keyword">type</span>, args)) <span class="comment">// 执行结果push进 values数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values <span class="comment">// 返回结果数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">handleError</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    err: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">    instance: ComponentInternalInstance | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">type</span>: ErrorTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">    throwInDev = <span class="literal">true</span></span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> contextVNode = instance ? instance.vnode : <span class="literal">null</span> <span class="comment">// 拿到当前的VNode</span></span><br><span class="line">    <span class="keyword">if</span> (instance) &#123; <span class="comment">// 存在</span></span><br><span class="line">      <span class="keyword">let</span> cur = instance.parent</span><br><span class="line">      <span class="comment">// the exposed instance is the render proxy to keep it consistent with 2.x</span></span><br><span class="line">      <span class="keyword">const</span> exposedInstance = instance.proxy</span><br><span class="line">      <span class="comment">// in production the hook receives only the error code</span></span><br><span class="line">      <span class="keyword">const</span> errorInfo = __DEV__ ? ErrorTypeStrings[<span class="keyword">type</span>] : <span class="keyword">type</span></span><br><span class="line">      <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">const</span> errorCapturedHooks = cur.ec <span class="comment">// 获取errorCapture数组</span></span><br><span class="line">        <span class="keyword">if</span> (errorCapturedHooks) &#123; <span class="comment">//存在</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; errorCapturedHooks.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              errorCapturedHooks[i](err, exposedInstance, errorInfo) === <span class="literal">false</span> <span class="comment">// 执行如果返回结果是false</span></span><br><span class="line">            ) &#123;</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.parent <span class="comment">// 向上寻找</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// app-level handling</span></span><br><span class="line">      <span class="keyword">const</span> appErrorHandler = instance.appContext.config.errorHandler <span class="comment">// 用户自己定义的错误handler</span></span><br><span class="line">      <span class="keyword">if</span> (appErrorHandler) &#123; <span class="comment">// 存在 </span></span><br><span class="line">        <span class="comment">// 执行用户自己定义的handler</span></span><br><span class="line">        callWithErrorHandling(</span><br><span class="line">          appErrorHandler,</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          ErrorCodes.APP_ERROR_HANDLER,</span><br><span class="line">          [err, exposedInstance, errorInfo]</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    logError(err, <span class="keyword">type</span>, contextVNode, throwInDev) <span class="comment">// 调用logError</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">logError</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    err: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">type</span>: ErrorTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">    contextVNode: VNode | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    throwInDev = <span class="literal">true</span></span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">const</span> info = ErrorTypeStrings[<span class="keyword">type</span>]</span><br><span class="line">      <span class="keyword">if</span> (contextVNode) &#123;</span><br><span class="line">        pushWarningContext(contextVNode)</span><br><span class="line">      &#125;</span><br><span class="line">      warn(<span class="string">`Unhandled error<span class="subst">$&#123;info ? <span class="string">` during execution of <span class="subst">$&#123;info&#125;</span>`</span> : <span class="string">``</span>&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">if</span> (contextVNode) &#123;</span><br><span class="line">        popWarningContext()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// crash in dev by default so it's more noticeable</span></span><br><span class="line">      <span class="keyword">if</span> (throwInDev) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!__TEST__) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// recover in prod to reduce the impact on end-user</span></span><br><span class="line">      <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><pre><code>- **applyMixins**  `packages/runtime-core/compoentOptions.ts`  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMixins</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  mixins: ComponentOptions[],</span></span></span><br><span class="line"><span class="function"><span class="params">  deferredData: DataFn[],</span></span></span><br><span class="line"><span class="function"><span class="params">  deferredWatch: ComponentWatchOptions[],</span></span></span><br><span class="line"><span class="function"><span class="params">  deferredProvide: (Data | <span class="built_in">Function</span>)[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历全局或者组件上的mixins中的每一项 分别调用applyOptions 并且 asMixin这个参数是true</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; mixins.length; i++) &#123;</span><br><span class="line">    applyOptions(</span><br><span class="line">      instance,</span><br><span class="line">      mixins[i],</span><br><span class="line">      deferredData,</span><br><span class="line">      deferredWatch,</span><br><span class="line">      deferredProvide,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- **createDuplicateChecker**  `packages/runtime-core/src/componentOptions.ts`  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDuplicateChecker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 利用闭包创建一个缓存</span></span><br><span class="line">  <span class="comment">// 返回一个方法 type 指的 Props, Data, Computed, Methods, Inject, 检验key是否被定义了</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params"><span class="keyword">type</span>: OptionTypes, key: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">      warn(<span class="string">`<span class="subst">$&#123;<span class="keyword">type</span>&#125;</span> property "<span class="subst">$&#123;key&#125;</span>" is already defined in <span class="subst">$&#123;cache[key]&#125;</span>.`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cache[key] = <span class="keyword">type</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- **inject**  `packages/rumtime-core/src/apiInject.ts`  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inject</span>&lt;<span class="title">T</span>&gt;(<span class="params">key: InjectionKey&lt;T&gt; | <span class="built_in">string</span></span>): <span class="title">T</span> | <span class="title">undefined</span> // 只传入一个参数 <span class="title">key</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inject</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="params">  key: InjectionKey&lt;T&gt; | <span class="built_in">string</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="params">  defaultValue: T,</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="params">  treatDefaultAsFactory?: <span class="literal">false</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="params"></span>): <span class="title">T</span> // <span class="title">key</span>, 默认值, 是否是为工厂</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inject</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="params">  key: InjectionKey&lt;T&gt; | <span class="built_in">string</span>,</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="params">  defaultValue: T | (() =&gt; T),</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="params">  treatDefaultAsFactory: <span class="literal">true</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="params"></span>): <span class="title">T</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inject</span>(<span class="params"></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  key: InjectionKey&lt;<span class="built_in">any</span>&gt; | <span class="built_in">string</span>,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  defaultValue?: unknown,</span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params">  treatDefaultAsFactory = <span class="literal">false</span></span></span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="function"><span class="params"></span>) </span>&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  // <span class="title">fallback</span> <span class="title">to</span> `<span class="title">currentRenderingInstance</span>` <span class="title">so</span> <span class="title">that</span> <span class="title">this</span> <span class="title">can</span> <span class="title">be</span> <span class="title">called</span> <span class="title">in</span> <span class="title">a</span> <span class="title">functional</span> <span class="title">component</span></span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  // 获取实例</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  <span class="title">const</span> <span class="title">instance</span> = <span class="title">currentInstance</span> || <span class="title">currentRenderingInstance</span> // 当前实例没有 就取当前正在<span class="title">render</span>的实例</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params">instance</span>) </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">    // #2400</span></span></span><br><span class="line"><span class="function"><span class="function">    // <span class="title">to</span> <span class="title">support</span> `<span class="title">app</span>.<span class="title">use</span>` <span class="title">plugins</span>,</span></span></span><br><span class="line"><span class="function"><span class="function">    // <span class="title">fallback</span> <span class="title">to</span> <span class="title">appContext</span>'<span class="title">s</span> `<span class="title">provides</span>` <span class="title">if</span> <span class="title">the</span> <span class="title">intance</span> <span class="title">is</span> <span class="title">at</span> <span class="title">root</span></span></span></span><br><span class="line"><span class="function"><span class="function">    <span class="title">const</span> <span class="title">provides</span> =</span></span></span><br><span class="line"><span class="function"><span class="function">      <span class="title">instance</span>.<span class="title">parent</span> == <span class="title">null</span> </span></span></span><br><span class="line"><span class="function"><span class="function">        ? <span class="title">instance</span>.<span class="title">vnode</span>.<span class="title">appContext</span> &amp;&amp; <span class="title">instance</span>.<span class="title">vnode</span>.<span class="title">appContext</span>.<span class="title">provides</span> // 是根节点则取出<span class="title">provides</span></span></span></span><br><span class="line"><span class="function"><span class="function">        : <span class="title">instance</span>.<span class="title">parent</span>.<span class="title">provides</span> // 否则就是往<span class="title">parent</span>去寻找</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function">    <span class="title">if</span> (<span class="params">provides &amp;&amp; (key <span class="keyword">as</span> <span class="built_in">string</span> | symbol) <span class="keyword">in</span> provides</span>) </span>&#123; // <span class="title">provides</span>存在 且 传入的<span class="title">key</span>也是 <span class="title">provides</span>的键</span></span><br><span class="line"><span class="function">      // <span class="title">TS</span> <span class="title">doesn</span>'<span class="title">t</span> <span class="title">allow</span> <span class="title">symbol</span> <span class="title">as</span> <span class="title">index</span> <span class="title">type</span></span></span><br><span class="line"><span class="function">      <span class="title">return</span> <span class="title">provides</span>[<span class="title">key</span> <span class="title">as</span> <span class="title">string</span>]</span></span><br><span class="line"><span class="function">    &#125; <span class="title">else</span> <span class="title">if</span> (<span class="params"><span class="built_in">arguments</span>.length &gt; 1</span>) </span>&#123; <span class="comment">// 传入的参数不止一个</span></span><br><span class="line">      <span class="comment">// 第三个参数为true且第二个参数是函数</span></span><br><span class="line">      <span class="keyword">return</span> treatDefaultAsFactory &amp;&amp; isFunction(defaultValue)</span><br><span class="line">        ? defaultValue() <span class="comment">// 直接返回defalutValue的调用结果</span></span><br><span class="line">        : defaultValue <span class="comment">// 否则返回第二个参数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      warn(<span class="string">`injection "<span class="subst">$&#123;<span class="built_in">String</span>(key)&#125;</span>" not found.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    warn(<span class="string">`inject() can only be used inside setup() or functional components.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- **resolveData**  `packages/runtime-core/src/componentOptions.ts`  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveData</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  dataFn: DataFn,</span></span></span><br><span class="line"><span class="function"><span class="params">  publicThis: ComponentPublicInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; !isFunction(dataFn)) &#123; <span class="comment">// 不是函数</span></span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`The data option must be a function. `</span> +</span><br><span class="line">        <span class="string">`Plain object usage is no longer supported.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> data = dataFn.call(publicThis, publicThis) <span class="comment">// 执行dataFn</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; isPromise(data)) &#123; <span class="comment">// 如果是promise</span></span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">`data() returned a Promise - note data() cannot be async; If you `</span> +</span><br><span class="line">        <span class="string">`intend to perform data fetching before component renders, use `</span> +</span><br><span class="line">        <span class="string">`async setup() + &lt;Suspense&gt;.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(data)) &#123; <span class="comment">// 如果不是对象</span></span><br><span class="line">    __DEV__ &amp;&amp; warn(<span class="string">`data() should return an object.`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance.data === EMPTY_OBJ) &#123; <span class="comment">// 如果是空对象</span></span><br><span class="line">    instance.data = reactive(data)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// existing data: this is a mixin or extends.</span></span><br><span class="line">    <span class="comment">// 扩展到实例的data上</span></span><br><span class="line">    extend(instance.data, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- **provide**  `packages/rumtime-core/src/apiInject.ts`  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">provide</span>&lt;<span class="title">T</span>&gt;(<span class="params">key: InjectionKey&lt;T&gt; | <span class="built_in">string</span> | <span class="built_in">number</span>, value: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!currentInstance) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      warn(<span class="string">`provide() can only be used inside setup().`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> provides = currentInstance.provides</span><br><span class="line">    <span class="comment">// by default an instance inherits its parent's provides object</span></span><br><span class="line">    <span class="comment">// but when it needs to provide values of its own, it creates its</span></span><br><span class="line">    <span class="comment">// own provides object using parent provides object as prototype.</span></span><br><span class="line">    <span class="comment">// this way in `inject` we can simply look up injections from direct</span></span><br><span class="line">    <span class="comment">// parent and let the prototype chain do the work.</span></span><br><span class="line">    <span class="keyword">const</span> parentProvides =</span><br><span class="line">      currentInstance.parent &amp;&amp; currentInstance.parent.provides</span><br><span class="line">    <span class="keyword">if</span> (parentProvides === provides) &#123;</span><br><span class="line">      provides = currentInstance.provides = <span class="built_in">Object</span>.create(parentProvides)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TS doesn't allow symbol as index type</span></span><br><span class="line">    provides[key <span class="keyword">as</span> <span class="built_in">string</span>] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="setupRenderEffect"><a href="#setupRenderEffect" class="headerlink" title="setupRenderEffect"></a>setupRenderEffect</h4><p><code>packages/runtime-core/src/rendered.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setupRenderEffect: SetupRenderEffectFn = (</span><br><span class="line">  instance,</span><br><span class="line">  initialVNode,</span><br><span class="line">  container,</span><br><span class="line">  anchor,</span><br><span class="line">  parentSuspense,</span><br><span class="line">  isSVG,</span><br><span class="line">  optimized</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="comment">// create reactive effect for rendering</span></span><br><span class="line">  <span class="comment">// 给实例的update属性赋值 effect方法后面再来看</span></span><br><span class="line">  instance.update = effect(<span class="function"><span class="keyword">function</span> <span class="title">componentEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance.isMounted) &#123; <span class="comment">// 实例还没有挂载</span></span><br><span class="line">      <span class="keyword">let</span> vnodeHook: VNodeHook | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">const</span> &#123; el, props &#125; = initialVNode </span><br><span class="line">      <span class="keyword">const</span> &#123; bm, m, parent &#125; = instance <span class="comment">// 取出beforeMount mounted</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 存在调用beforeMount钩子</span></span><br><span class="line">      <span class="keyword">if</span> (bm) &#123;</span><br><span class="line">        invokeArrayFns(bm) <span class="comment">// 这个方法 里面就是 循环 fnsArr 挨个调用</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// onVnodeBeforeMount</span></span><br><span class="line">      <span class="keyword">if</span> ((vnodeHook = props &amp;&amp; props.onVnodeBeforeMount)) &#123;</span><br><span class="line">        invokeVNodeHook(vnodeHook, parent, initialVNode)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// render</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`render`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行 renderComponentRoot 创建子树</span></span><br><span class="line">      <span class="keyword">const</span> subTree = (instance.subTree = renderComponentRoot(instance))</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`render`</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 存在el 且 要注水</span></span><br><span class="line">      <span class="keyword">if</span> (el &amp;&amp; hydrateNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          startMeasure(instance, <span class="string">`hydrate`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// vnode has adopted host node - perform hydration instead of mount.</span></span><br><span class="line">        hydrateNode(</span><br><span class="line">          initialVNode.el <span class="keyword">as</span> Node,</span><br><span class="line">          subTree,</span><br><span class="line">          instance,</span><br><span class="line">          parentSuspense</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          endMeasure(instance, <span class="string">`hydrate`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          startMeasure(instance, <span class="string">`patch`</span>)</span><br><span class="line">        &#125; <span class="comment">// 开始patch 不过这次会进 processFragment </span></span><br><span class="line">        patch(</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          subTree,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          instance,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          endMeasure(instance, <span class="string">`patch`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        initialVNode.el = subTree.el</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// mounted hook</span></span><br><span class="line">      <span class="keyword">if</span> (m) &#123;</span><br><span class="line">        queuePostRenderEffect(m, parentSuspense)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// onVnodeMounted</span></span><br><span class="line">      <span class="keyword">if</span> ((vnodeHook = props &amp;&amp; props.onVnodeMounted)) &#123;</span><br><span class="line">        <span class="keyword">const</span> scopedInitialVNode = initialVNode</span><br><span class="line">        queuePostRenderEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          invokeVNodeHook(vnodeHook!, parent, scopedInitialVNode)</span><br><span class="line">        &#125;, parentSuspense)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// activated hook for keep-alive roots.</span></span><br><span class="line">      <span class="comment">// #1742 activated hook must be accessed after first render</span></span><br><span class="line">      <span class="comment">// since the hook may be injected by a child keep-alive</span></span><br><span class="line">      <span class="keyword">const</span> &#123; a &#125; = instance <span class="comment">// keepAlive activated钩子</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        a &amp;&amp;</span><br><span class="line">        initialVNode.shapeFlag &amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE</span><br><span class="line">      ) &#123;</span><br><span class="line">        queuePostRenderEffect(a, parentSuspense)</span><br><span class="line">      &#125;</span><br><span class="line">      instance.isMounted = <span class="literal">true</span> <span class="comment">// 挂载完毕</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// #2458: deference mount-only object parameters to prevent memleaks</span></span><br><span class="line">      initialVNode = container = anchor = <span class="literal">null</span> <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 更新组件</span></span><br><span class="line">      <span class="comment">// updateComponent</span></span><br><span class="line">      <span class="comment">// This is triggered by mutation of component's own state (next: null)</span></span><br><span class="line">      <span class="comment">// OR parent calling processComponent (next: VNode)</span></span><br><span class="line">      <span class="keyword">let</span> &#123; next, bu, u, parent, vnode &#125; = instance</span><br><span class="line">      <span class="keyword">let</span> originNext = next</span><br><span class="line">      <span class="keyword">let</span> vnodeHook: VNodeHook | <span class="literal">null</span> | <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        pushWarningContext(next || instance.vnode)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (next) &#123;</span><br><span class="line">        next.el = vnode.el</span><br><span class="line">        updateComponentPreRender(instance, next, optimized)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next = vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// beforeUpdate hook</span></span><br><span class="line">      <span class="keyword">if</span> (bu) &#123;</span><br><span class="line">        invokeArrayFns(bu)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// onVnodeBeforeUpdate</span></span><br><span class="line">      <span class="keyword">if</span> ((vnodeHook = next.props &amp;&amp; next.props.onVnodeBeforeUpdate)) &#123;</span><br><span class="line">        invokeVNodeHook(vnodeHook, parent, next, vnode)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// render</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`render`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> nextTree = renderComponentRoot(instance)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`render`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> prevTree = instance.subTree</span><br><span class="line">      instance.subTree = nextTree</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, <span class="string">`patch`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      patch(</span><br><span class="line">        prevTree,</span><br><span class="line">        nextTree,</span><br><span class="line">        <span class="comment">// parent may have changed if it's in a teleport</span></span><br><span class="line">        hostParentNode(prevTree.el!)!,</span><br><span class="line">        <span class="comment">// anchor may have changed if it's in a fragment</span></span><br><span class="line">        getNextHostNode(prevTree),</span><br><span class="line">        instance,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, <span class="string">`patch`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      next.el = nextTree.el</span><br><span class="line">      <span class="keyword">if</span> (originNext === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// self-triggered update. In case of HOC, update parent component</span></span><br><span class="line">        <span class="comment">// vnode el. HOC is indicated by parent instance's subTree pointing</span></span><br><span class="line">        <span class="comment">// to child component's vnode</span></span><br><span class="line">        updateHOCHostEl(instance, nextTree.el)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// updated hook</span></span><br><span class="line">      <span class="keyword">if</span> (u) &#123;</span><br><span class="line">        queuePostRenderEffect(u, parentSuspense)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// onVnodeUpdated</span></span><br><span class="line">      <span class="keyword">if</span> ((vnodeHook = next.props &amp;&amp; next.props.onVnodeUpdated)) &#123;</span><br><span class="line">        queuePostRenderEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          invokeVNodeHook(vnodeHook!, parent, next!, vnode)</span><br><span class="line">        &#125;, parentSuspense)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">        devtoolsComponentUpdated(instance)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        popWarningContext()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="createDevEffectOptions"><a href="#createDevEffectOptions" class="headerlink" title="createDevEffectOptions"></a>createDevEffectOptions</h5><p><code>packages/runtime-core/src/renderer.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDevEffectOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffectOptions</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    scheduler: queueJob,</span><br><span class="line">    allowRecurse: <span class="literal">true</span>,</span><br><span class="line">    onTrack: instance.rtc ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtc!, e) : <span class="built_in">void</span> <span class="number">0</span>,</span><br><span class="line">    onTrigger: instance.rtg ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtg!, e) : <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="renderComponentRoot"><a href="#renderComponentRoot" class="headerlink" title="renderComponentRoot"></a>renderComponentRoot</h5><p><code>packages/runtime-core/src/componentRenderUtils.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderComponentRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>: Component,</span><br><span class="line">    vnode,</span><br><span class="line">    proxy,</span><br><span class="line">    withProxy,</span><br><span class="line">    props,</span><br><span class="line">    propsOptions: [propsOptions],</span><br><span class="line">    slots,</span><br><span class="line">    attrs,</span><br><span class="line">    emit,</span><br><span class="line">    render,</span><br><span class="line">    renderCache,</span><br><span class="line">    data,</span><br><span class="line">    setupState,</span><br><span class="line">    ctx</span><br><span class="line">  &#125; = instance</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  currentRenderingInstance = instance <span class="comment">// 当前render的实例</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    accessedAttrs = <span class="literal">false</span> <span class="comment">// 访问属性为 false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fallthroughAttrs</span><br><span class="line">    <span class="keyword">if</span> (vnode.shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT) &#123; <span class="comment">// 有状态的组件</span></span><br><span class="line">      <span class="comment">// withProxy is a proxy with a different `has` trap only for</span></span><br><span class="line">      <span class="comment">// runtime-compiled render functions using `with` block.</span></span><br><span class="line">      <span class="keyword">const</span> proxyToUse = withProxy || proxy</span><br><span class="line">      result = normalizeVNode(</span><br><span class="line">        <span class="comment">// 先执行之前生成的render函数</span></span><br><span class="line">        render!.call(</span><br><span class="line">          proxyToUse,</span><br><span class="line">          proxyToUse!,</span><br><span class="line">          renderCache,</span><br><span class="line">          props,</span><br><span class="line">          setupState,</span><br><span class="line">          data,</span><br><span class="line">          ctx</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">      fallthroughAttrs = attrs</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 函数组件</span></span><br><span class="line">      <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attr merging</span></span><br><span class="line">    <span class="comment">// in dev mode, comments are preserved, and it's possible for a template</span></span><br><span class="line">    <span class="comment">// to have comments along side the root element which makes it a fragment</span></span><br><span class="line">    <span class="keyword">let</span> root = result</span><br><span class="line">    <span class="keyword">let</span> setRoot: <span class="function">(<span class="params">(<span class="params">root: VNode</span>) =&gt; <span class="built_in">void</span></span>) | <span class="params">undefined</span> = <span class="params">undefined</span> // <span class="params">setRoot</span>方法</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">__DEV__ &amp;&amp; result.patchFlag &amp; PatchFlags.DEV_ROOT_FRAGMENT</span>) &#123; // <span class="params">DEV_ROOT_FRAGMENT</span> 2048 开发环境</span></span><br><span class="line"><span class="function">      ;[<span class="params">root</span>, <span class="params">setRoot</span>] = <span class="params">getChildRoot</span>(<span class="params">result</span>)</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="params">inheritAttrs</span> 不为<span class="params">false</span></span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">Component.inheritAttrs !== <span class="literal">false</span> &amp;&amp; fallthroughAttrs</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">const</span> <span class="params">keys</span> = <span class="params">Object</span>.<span class="params">keys</span>(<span class="params">fallthroughAttrs</span>) // <span class="params">Object</span>.<span class="params">keys</span>不能拿出 <span class="params">enumerable</span>为<span class="params">false</span>的<span class="params">key</span></span></span><br><span class="line"><span class="function">      <span class="params">const</span> &#123; <span class="params">shapeFlag</span> &#125; = <span class="params">root</span></span></span><br><span class="line"><span class="function">      <span class="params">if</span> (<span class="params">keys.length</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">if</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">          shapeFlag &amp; ShapeFlags.ELEMENT ||</span></span></span><br><span class="line"><span class="function"><span class="params">          shapeFlag &amp; ShapeFlags.COMPONENT</span></span></span><br><span class="line"><span class="function"><span class="params">        </span>) &#123; // 元素或者组件</span></span><br><span class="line"><span class="function">          <span class="params">if</span> (<span class="params">propsOptions &amp;&amp; keys.some(<span class="params">isModelListener</span>)</span>) &#123; // 存在属性 且还有 "<span class="params">onUpdate</span>:"开头的</span></span><br><span class="line"><span class="function">            // <span class="params">If</span> <span class="params">a</span> <span class="params">v</span>-<span class="params">model</span> <span class="params">listener</span> (<span class="params">onUpdate:xxx</span>) <span class="params">has</span> <span class="params">a</span> <span class="params">corresponding</span> <span class="params">declared</span></span></span><br><span class="line"><span class="function">            // <span class="params">prop</span>, <span class="params">it</span> <span class="params">indicates</span> <span class="params">this</span> <span class="params">component</span> <span class="params">expects</span> <span class="params">to</span> <span class="params">handle</span> <span class="params">v</span>-<span class="params">model</span> <span class="params">and</span></span></span><br><span class="line"><span class="function">            // <span class="params">it</span> <span class="params">should</span> <span class="params">not</span> <span class="params">fallthrough</span>.</span></span><br><span class="line"><span class="function">            // <span class="params">related</span>: #1543, #1643, #1989</span></span><br><span class="line"><span class="function">            // <span class="params">filterModelListeners</span> 筛选出 <span class="params">attrs</span>中存在"<span class="params">onUpdate</span>:"开头的 或者 <span class="params">key</span>.<span class="params">slice</span>(<span class="params">0, 9</span>)还存在<span class="params">props</span>里面的</span></span><br><span class="line"><span class="function">            <span class="params">fallthroughAttrs</span> = <span class="params">filterModelListeners</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">              fallthroughAttrs,</span></span></span><br><span class="line"><span class="function"><span class="params">              propsOptions</span></span></span><br><span class="line"><span class="function"><span class="params">            </span>)</span></span><br><span class="line"><span class="function">          &#125;</span></span><br><span class="line"><span class="function">          <span class="params">root</span> = <span class="params">cloneVNode</span>(<span class="params">root, fallthroughAttrs</span>)</span></span><br><span class="line"><span class="function">        &#125; <span class="params">else</span> <span class="params">if</span> (<span class="params">__DEV__ &amp;&amp; !accessedAttrs &amp;&amp; root.<span class="keyword">type</span> !== Comment</span>) &#123;</span></span><br><span class="line"><span class="function">          <span class="params">const</span> <span class="params">allAttrs</span> = <span class="params">Object</span>.<span class="params">keys</span>(<span class="params">attrs</span>)</span></span><br><span class="line"><span class="function">          <span class="params">const</span> <span class="params">eventAttrs</span>: <span class="params">string</span>[] = []</span></span><br><span class="line"><span class="function">          <span class="params">const</span> <span class="params">extraAttrs</span>: <span class="params">string</span>[] = []</span></span><br><span class="line"><span class="function">          <span class="params">for</span> (<span class="params"><span class="keyword">let</span> i = 0, l = allAttrs.length; i &lt; l; i++</span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="params">const</span> <span class="params">key</span> = <span class="params">allAttrs</span>[<span class="params">i</span>]</span></span><br><span class="line"><span class="function">            <span class="params">if</span> (<span class="params">isOn(<span class="params">key</span>)</span>) &#123; // 检验是不是<span class="params">on</span>开头的<span class="params">key</span></span></span><br><span class="line"><span class="function">              // <span class="params">ignore</span> <span class="params">v</span>-<span class="params">model</span> <span class="params">handlers</span> <span class="params">when</span> <span class="params">they</span> <span class="params">fail</span> <span class="params">to</span> <span class="params">fallthrough</span></span></span><br><span class="line"><span class="function">              <span class="params">if</span> (<span class="params">!isModelListener(<span class="params">key</span>)</span>) &#123; // 但不是 "<span class="params">onUpdate</span>:"开头的</span></span><br><span class="line"><span class="function">                // <span class="params">remove</span> `<span class="params">on</span>`, <span class="params">lowercase</span> <span class="params">first</span> <span class="params">letter</span> <span class="params">to</span> <span class="params">reflect</span> <span class="params">event</span> <span class="params">casing</span></span></span><br><span class="line"><span class="function">                // <span class="params">accurately</span></span></span><br><span class="line"><span class="function">                <span class="params">eventAttrs</span>.<span class="params">push</span>(<span class="params">key[2].toLowerCase(<span class="params"></span>) + key.slice(<span class="params">3</span>)</span>) // <span class="params">push</span>进<span class="params">eventAttrs</span></span></span><br><span class="line"><span class="function">              &#125;</span></span><br><span class="line"><span class="function">            &#125; <span class="params">else</span> &#123;</span></span><br><span class="line"><span class="function">              <span class="params">extraAttrs</span>.<span class="params">push</span>(<span class="params">key</span>) // 移入<span class="params">extraAttrs</span></span></span><br><span class="line"><span class="function">            &#125;</span></span><br><span class="line"><span class="function">          &#125;</span></span><br><span class="line"><span class="function">          <span class="params">if</span> (<span class="params">extraAttrs.length</span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="params">warn</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">              `Extraneous non-props attributes (<span class="params">` +</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">                `$&#123;extraAttrs.join(<span class="params">', '</span>)&#125;</span>) ` +</span></span></span><br><span class="line"><span class="function"><span class="params">                `were passed to component but could not be automatically inherited ` +</span></span></span><br><span class="line"><span class="function"><span class="params">                `because component renders fragment or text root nodes.`</span></span></span><br><span class="line"><span class="function"><span class="params">            </span>)</span></span><br><span class="line"><span class="function">          &#125;</span></span><br><span class="line"><span class="function">          <span class="params">if</span> (<span class="params">eventAttrs.length</span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="params">warn</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">              `Extraneous non-emits event listeners (<span class="params">` +</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">                `$&#123;eventAttrs.join(<span class="params">', '</span>)&#125;</span>) ` +</span></span></span><br><span class="line"><span class="function"><span class="params">                `were passed to component but could not be automatically inherited ` +</span></span></span><br><span class="line"><span class="function"><span class="params">                `because component renders fragment or text root nodes. ` +</span></span></span><br><span class="line"><span class="function"><span class="params">                `If the listener is intended to be a component custom event listener only, ` +</span></span></span><br><span class="line"><span class="function"><span class="params">                `<span class="keyword">declare</span> it using the "emits" option.`</span></span></span><br><span class="line"><span class="function"><span class="params">            </span>)</span></span><br><span class="line"><span class="function">          &#125;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="params">inherit</span> <span class="params">directives</span> 存在指令</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">vnode.dirs</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">if</span> (<span class="params">__DEV__ &amp;&amp; !isElementRoot(<span class="params">root</span>)</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">warn</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">          `Runtime directive used on component <span class="keyword">with</span> non-element root node. ` +</span></span></span><br><span class="line"><span class="function"><span class="params">            `The directives will not <span class="keyword">function</span> <span class="keyword">as</span> intended.`</span></span></span><br><span class="line"><span class="function"><span class="params">        </span>)</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">      <span class="params">root</span>.<span class="params">dirs</span> = <span class="params">root</span>.<span class="params">dirs</span> ? <span class="params">root</span>.<span class="params">dirs</span>.<span class="params">concat</span>(<span class="params">vnode.dirs</span>) : <span class="params">vnode</span>.<span class="params">dirs</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    // <span class="params">inherit</span> <span class="params">transition</span> <span class="params">data</span> </span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">vnode.transition</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">if</span> (<span class="params">__DEV__ &amp;&amp; !isElementRoot(<span class="params">root</span>)</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">warn</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">          `Component inside &lt;Transition&gt; renders non-element root node ` +</span></span></span><br><span class="line"><span class="function"><span class="params">            `that cannot be animated.`</span></span></span><br><span class="line"><span class="function"><span class="params">        </span>)</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">      <span class="params">root</span>.<span class="params">transition</span> = <span class="params">vnode</span>.<span class="params">transition</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">__DEV__ &amp;&amp; setRoot</span>) &#123;</span></span><br><span class="line"><span class="function">      <span class="params">setRoot</span>(<span class="params">root</span>)</span></span><br><span class="line"><span class="function">    &#125; <span class="params">else</span> &#123;</span></span><br><span class="line"><span class="function">      <span class="params">result</span> = <span class="params">root</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125; <span class="params">catch</span> (<span class="params">err</span>) &#123;</span></span><br><span class="line"><span class="function">    <span class="params">handleError</span>(<span class="params">err, instance, ErrorCodes.RENDER_FUNCTION</span>)</span></span><br><span class="line"><span class="function">    <span class="params">result</span> = <span class="params">createVNode</span>(<span class="params">Comment</span>)</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="params">currentRenderingInstance</span> = <span class="params">null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="params">return</span> <span class="params">result</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h6 id="normalizeVNode"><a href="#normalizeVNode" class="headerlink" title="normalizeVNode"></a>normalizeVNode</h6><p><code>packages/runtime-core/src/vnode.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeVNode</span>(<span class="params">child: VNodeChild</span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (child == <span class="literal">null</span> || <span class="keyword">typeof</span> child === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="comment">// empty placeholder 创建注释节点</span></span><br><span class="line">    <span class="keyword">return</span> createVNode(Comment)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(child)) &#123;</span><br><span class="line">    <span class="comment">// fragment fragment节点</span></span><br><span class="line">    <span class="keyword">return</span> createVNode(Fragment, <span class="literal">null</span>, child)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'object'</span>) &#123; <span class="comment">// 已经是一个vnode了</span></span><br><span class="line">    <span class="comment">// already vnode, this should be the most common since compiled templates</span></span><br><span class="line">    <span class="comment">// always produce all-vnode children arrays</span></span><br><span class="line">    <span class="keyword">return</span> child.el === <span class="literal">null</span> ? child : cloneVNode(child)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// strings and numbers 文本节点</span></span><br><span class="line">    <span class="keyword">return</span> createVNode(Text, <span class="literal">null</span>, <span class="built_in">String</span>(child))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="processFragment"><a href="#processFragment" class="headerlink" title="processFragment"></a>processFragment</h5><p><code>packages/runtime-core/src/renderer.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> processFragment = (</span><br><span class="line">  n1: VNode | <span class="literal">null</span>,</span><br><span class="line">  n2: VNode,</span><br><span class="line">  container: RendererElement,</span><br><span class="line">  anchor: RendererNode | <span class="literal">null</span>,</span><br><span class="line">  parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span><br><span class="line">  parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span><br><span class="line">  isSVG: <span class="built_in">boolean</span>,</span><br><span class="line">  optimized: <span class="built_in">boolean</span></span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(<span class="string">''</span>))!</span><br><span class="line">  <span class="keyword">const</span> fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(<span class="string">''</span>))!</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> &#123; patchFlag, dynamicChildren &#125; = n2</span><br><span class="line">  <span class="keyword">if</span> (patchFlag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    optimized = <span class="literal">true</span> <span class="comment">// 可以优化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; isHmrUpdating) &#123;</span><br><span class="line">    <span class="comment">// HMR updated, force full diff</span></span><br><span class="line">    patchFlag = <span class="number">0</span></span><br><span class="line">    optimized = <span class="literal">false</span></span><br><span class="line">    dynamicChildren = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123; <span class="comment">// 不存在n1</span></span><br><span class="line">    hostInsert(fragmentStartAnchor, container, anchor) <span class="comment">// 在container里面插入text文本节点</span></span><br><span class="line">    hostInsert(fragmentEndAnchor, container, anchor) <span class="comment">// 在container里面插入text文本节点</span></span><br><span class="line">    <span class="comment">// a fragment can only have array children</span></span><br><span class="line">    <span class="comment">// since they are either generated by the compiler, or implicitly created</span></span><br><span class="line">    <span class="comment">// from arrays.</span></span><br><span class="line">    <span class="comment">// fragment 只能有数组children </span></span><br><span class="line">    mountChildren(</span><br><span class="line">      n2.children <span class="keyword">as</span> VNodeArrayChildren,</span><br><span class="line">      container,</span><br><span class="line">      fragmentEndAnchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      patchFlag &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      patchFlag &amp; PatchFlags.STABLE_FRAGMENT &amp;&amp;</span><br><span class="line">      dynamicChildren &amp;&amp;</span><br><span class="line">      <span class="comment">// #2715 the previous fragment could've been a BAILed one as a result</span></span><br><span class="line">      <span class="comment">// of renderSlot() with no valid children</span></span><br><span class="line">      n1.dynamicChildren</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// a stable fragment (template root or &lt;template v-for&gt;) doesn't need to</span></span><br><span class="line">      <span class="comment">// patch children order, but it may contain dynamicChildren.</span></span><br><span class="line">      patchBlockChildren(</span><br><span class="line">        n1.dynamicChildren,</span><br><span class="line">        dynamicChildren,</span><br><span class="line">        container,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; parentComponent &amp;&amp; parentComponent.type.__hmrId) &#123;</span><br><span class="line">        traverseStaticChildren(n1, n2)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// #2080 if the stable fragment has a key, it's a &lt;template v-for&gt; that may</span></span><br><span class="line">        <span class="comment">//  get moved around. Make sure all root level vnodes inherit el.</span></span><br><span class="line">        <span class="comment">// #2134 or if it's a component root, it may also get moved around</span></span><br><span class="line">        <span class="comment">// as the component is being moved.</span></span><br><span class="line">        n2.key != <span class="literal">null</span> ||</span><br><span class="line">        (parentComponent &amp;&amp; n2 === parentComponent.subTree)</span><br><span class="line">      ) &#123;</span><br><span class="line">        traverseStaticChildren(n1, n2, <span class="literal">true</span> <span class="comment">/* shallow */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// keyed / unkeyed, or manual fragments.</span></span><br><span class="line">      <span class="comment">// for keyed &amp; unkeyed, since they are compiler generated from v-for,</span></span><br><span class="line">      <span class="comment">// each child is guaranteed to be a block so the fragment will never</span></span><br><span class="line">      <span class="comment">// have dynamicChildren.</span></span><br><span class="line">      patchChildren(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        container,</span><br><span class="line">        fragmentEndAnchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="mountChildren"><a href="#mountChildren" class="headerlink" title="mountChildren"></a>mountChildren</h6><p><code>packages/runtime-core/src/renderer.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mountChildren 循环调用 patch方法 挂载完子节点后 </span></span><br><span class="line"><span class="keyword">const</span> mountChildren: MountChildrenFn = (</span><br><span class="line">    children,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized,</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 循环调用patch 中间根据 optimized 是调用 cloneIfMounted 还是  normalizeVNode</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; children.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> child = (children[i] = optimized</span><br><span class="line">        ? cloneIfMounted(children[i] <span class="keyword">as</span> VNode) <span class="comment">// cloneIfMounted 方法 判断的是如果挂载了 el是有值的 </span></span><br><span class="line">        : normalizeVNode(children[i]))</span><br><span class="line">      patch(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        child,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      源码阅读
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="vue" scheme="http://blog.decade.run/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版-第十二章-笔记</title>
    <link href="http://blog.decade.run/2021/02/24/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2021/02/24/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-24T03:11:54.000Z</published>
    <updated>2021-02-24T05:56:11.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>BOM 的核心是 window 对象, 表示浏览器的实例, window 对象在浏览器中有两重身份, 一个是ECMAScript 中的 Global 对象, 另一个就是浏览器窗口的 JavaScript 接口</p><h4 id="Global-作用域"><a href="#Global-作用域" class="headerlink" title="Global 作用域"></a>Global 作用域</h4><p>window 对象被复用为 ECMAScript 的 Global 对象, 所以通过var声明的全局变量和全局方法都会变成window的属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.num); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.say(); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版-第十一章-笔记</title>
    <link href="http://blog.decade.run/2021/02/19/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2021/02/19/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-19T05:52:49.000Z</published>
    <updated>2021-02-24T02:00:42.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p>同步行为和异步行为的对立统一是计算机科学的一个基本概念. 特别是在 JavaScript 这种单线程事件循环模型中, 同步操作与异步操作更是代码所要依赖的核心机制. 异步行为是为了优化因计算量大而时间长的操作. 如果在等待其他操作完成的同时, 即使运行其他指令, 系统也能保持稳定, 那么这样做就是务实的</p><h4 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h4><p>同步行为对应内存中顺序执行的处理器指令</p><p>异步行为类似于系统中断, 即当前进程外部的实体可以触发代码执行</p><h4 id="以往的异步编程模式"><a href="#以往的异步编程模式" class="headerlink" title="以往的异步编程模式"></a>以往的异步编程模式</h4><p>异步行为是 JavaScript 的基础, 但以前的实现不理想, 在早期的 JavaScript , 只支持定义回调函数来表明异步操作完成, 串联多个异步操作是一个常见的问题, 通常需要深度嵌套的回调函数<code>(俗称&quot;回调地狱&quot;)</code>来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一个异步结束"</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"第二个异步结束"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><ol><li><p>异步返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, cb</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        cb(value * <span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">double(<span class="number">3</span>, v =&gt; <span class="built_in">console</span>.log(<span class="string">`value is <span class="subst">$&#123;v&#125;</span>`</span>)); <span class="comment">//  value is 6</span></span><br></pre></td></tr></table></figure></li><li><p>失败处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, error</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'number'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">'Must provide number as first argument'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            success(<span class="number">2</span> * value);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            error(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> successCB = <span class="function"><span class="params">v</span> =&gt;</span><span class="built_in">console</span>.log(<span class="string">`Success <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">const</span> errorCB = <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Error <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">double(<span class="number">3</span>, successCB, errorCB); <span class="comment">// Success 6</span></span><br><span class="line">double(<span class="string">"3"</span>, successCB, errorCB); <span class="comment">// Error Must provide number as first argument</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套异步回调</p><p>如果异步返值又依赖另一个异步返回值, 那么回调的情况还会进一步变复杂. 在实际的代码中, 这就要求嵌套回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">value, success, error</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'number'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">'Must provide number as first argument'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            success(<span class="number">2</span> * value);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            error(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> successCB = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">double(v, v =&gt; <span class="built_in">console</span>.log(<span class="string">`Success <span class="subst">$&#123;v&#125;</span>`</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> errorCB = <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Error <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">double(<span class="number">3</span>, successCB, errorCB); <span class="comment">// Success 12</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="期约"><a href="#期约" class="headerlink" title="期约"></a>期约</h3><h4 id="Promises-A-规范"><a href="#Promises-A-规范" class="headerlink" title="Promises/A+规范"></a>Promises/A+规范</h4><p>早期的期约机制在 jQuery 和 Dojo 中是以 Deferred API 的形式出现的. 到了 2010 年, CommonJS 项目实现的 Promises/A 规范日益流行起来. Q 和 Bluebird 等第三方 JavaScript 期约库也越来越得到社区认可, 虽然这些库的实现多少都有些不同. 为弥合现有实现之间的差异, 2012 年 Promises/A+组织分叉(fork) 了 CommonJS 的 Promises/A 建议, 并以相同的名字制定了 Promises/A+规范. 这个规范最终成为了ECMAScript 6 规范实现的范本</p><h4 id="期约基础"><a href="#期约基础" class="headerlink" title="期约基础"></a>期约基础</h4><p>ECMAScript 6 新增的引用类型 Promise, 可以通过 new 操作符来实例化. 创建新期约时需要传入执行器(executor)函数作为参数</p><ol><li><p>期约状态机</p><p>期约是一个有状态的对象, 有如下三种状态</p><ul><li>pending 待定</li><li>fulfilled 兑现 (有时候也成为解决, resolved)</li><li>rejeced 拒绝</li></ul><p>待定(pending)是期约的最初始状态. 在待定状态下, 期约可以落定(settled)为代表成功的兑现(fulfilled)状态, 或者代表失败的拒绝(rejected)状态, 无论落定为哪种状态都是不可逆的</p><p>期约的状态是私有的, 不能直接通过 JavaScript 检测到, 期约的状态也不能被外部 JavaScript 代码修改</p></li><li><p>解决值、拒绝理由及期约用例</p><p>期约主要有两大用途</p><p>一种是抽象的表示一个异步操作, 期约的状态代表期约是否完成。pending表示尚未开始或者正在执行中, fulfilled表示已经成功完成, rejected则表示没有成功完成</p><p>另一种是, 期约封装的异步操作会实际生成某个值, 而程序期待期约状态改变时可以访问这个值</p><p>为了支持这两种用例, 每个期约只要状态切换为兑现, 就会有一个私有的内部值(value). 类似地, 每个期约只要状态切换为拒绝, 就会有一个私有的内部理由(reason). 无论是值还是理由, 都是包含原始值或对象的不可修改的引用. 二者都是可选的, 而且默认值为 undefined. 在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由</p></li><li><p>通过执行函数控制期约状态</p><p>期约的状态是私有的, 所以只能在内部进行操作, 操作都在执行器里面执行. 执行器函数主要有两个职责: 初始化期约的异步行为和控制状态的最终转换, 改变期约的状态主要是控制器的两个参数<code>resolve()</code> 将状态切换为<code>fulfilled</code>, <code>reject</code> 将状态切换为<code>rejected</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve()); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject()); <span class="comment">// Uncaught (in promise) undefined</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.resolve()</p><p>期约并非一开始就必须处于待定状态, 然后通过执行器函数才能转换为落定状态. 通过调用Promise.resolve()静态方法, 可以实例化一个解决的期约, 对这个静态方法而言, 如果传入的参数本身是一个期约, 那它的行为就类似于一个空包装. 因此, Promise.resolve()可以说是一个幂等方法, 这个幂等性会保留传入期约的状态, 这个静态方法能够包装任何非期约值, 包括错误对象, 并将其转换为解决的期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="number">7</span>);</span><br><span class="line">p === <span class="built_in">Promise</span>.resolve(p); <span class="comment">// true</span></span><br><span class="line">p === <span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve(p)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.reject()</p><p>与 Promise.resolve()类似, Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误(这个错误不能通过 try/catch 捕获, 而只能通过拒绝处理程序捕获),拒绝的期约的理由就是传给 Promise.reject()的第一个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject()); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject();</span><br></pre></td></tr></table></figure></li><li><p>同步/异步执行的二元性</p><p>Promise 的设计很大程度上会导致一种完全不同于 JavaScript 的计算模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125; <span class="comment">// Error: error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125; <span class="comment">// Uncaught (in promise) Error: error</span></span><br></pre></td></tr></table></figure><p>期约真正的异步特性: 它们是同步对象, 但也是异步执行模式的媒介</p></li></ol><h4 id="期约实例方法"><a href="#期约实例方法" class="headerlink" title="期约实例方法"></a>期约实例方法</h4><p>期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁, 这些方法可以访问异步操作返回的数据, 处理期约成功和失败的结果, 连续对期约求值, 或者添加只有期约进入终止状态时才会执行的代码</p><ol><li><p>实现 Thenable 接口</p><p>ECMAScript 暴露的异步结构中, 任何对象都有一个 then()方法, 这个方法被认为实现了Thenable 接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThenable</span> </span>&#123;</span><br><span class="line">    then() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ECMAScript 的 Promise 类型实现了 Thenable 接口, 这个简化的接口跟 TypeScript 或其他包中的接口或类型定义不同, 它们都设定了 Thenable 接口更具体的形式</p></li><li><p>Promise.prototype.then()</p><p>Promise.prototype.then()是为期约实例添加处理程序的主要方法. 这个 then()方法接收最多两个参数: onResolved 方法在期约状态变成fulfilled时执行,  onRejected 方法在期约状态变成rejected时执行, 这两个参数都是可选的, 传给 then()的任何非函数类型的参数都会被静默忽略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OnResolved = <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;value&#125;</span>, fulfilled`</span>);</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;error&#125;</span>, rejected`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(reject, <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line">p1.then(OnResolved(<span class="string">"success"</span>)); <span class="comment">// success, fulfilled</span></span><br><span class="line">p2.then(<span class="literal">null</span>, onRejected(<span class="string">"error"</span>)); <span class="comment">// error, rejected</span></span><br></pre></td></tr></table></figure><p>   Promise.prototype.then()方法返回一个新的期约实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then();</span><br><span class="line">p2 === p1; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这个新期约实例基于 onResovled 处理程序的返回值构建, 换句话说, 该处理程序的返回值会通过Promise.resolve()包装来生成新期约, 如果没有提供这个处理程序, 则 Promise.resolve()就会包装上一个期约解决之后的值, 如果没有显式的返回语句, 则 Promise.resolve()会包装默认的返回值 undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">"p1"</span>); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> p3 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"><span class="keyword">const</span> p4 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">undefined</span>); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"><span class="keyword">const</span> p5 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve()); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> p6 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'p6'</span>); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p6"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p7 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">"p7"</span>)); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p7"&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> p8 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="keyword">const</span> p9 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.reject()); <span class="comment">//  Uncaught (in promise) undefined Promise &#123;&lt;rejected&gt;: undefined&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> p10 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">'p10'</span>; &#125;); <span class="comment">// Uncaught (in promise) p10 Promise &#123;&lt;rejected&gt;: "p10"&#125;</span></span><br><span class="line"><span class="comment">// 注意, 返回错误值不会触发上面的拒绝行为, 而会把错误对象包装在一个解决的期约中</span></span><br><span class="line"><span class="keyword">const</span> p11 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Error</span>(<span class="string">'p11'</span>)); <span class="comment">//  Promise &#123;&lt;fulfilled&gt;: Error: p11 at &lt;anonymous&gt;:1:27&#125;</span></span><br></pre></td></tr></table></figure><p> onRejected 处理程序也与之类似: onRejected 处理程序返回的值也会被 Promise.resolve()包装, onRejected 处理程序的就是为了捕获异常, 因此, 拒绝处理程序在捕获错误后不抛出异常是符合期约的行为, 应该返回一个解决期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.reject(<span class="string">"p1"</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.then(); <span class="comment">// Uncaught (in promise) p1 Promise &#123;&lt;rejected&gt;: "p1"&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> p3 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;); <span class="comment">// Uncaught (in promise) p1 Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"><span class="keyword">const</span> p4 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">undefined</span>); <span class="comment">// Uncaught (in promise) p1 Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"><span class="keyword">const</span> p5 = p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve()); <span class="comment">// Uncaught (in promise) p1 Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> p6 = p1.then(<span class="literal">null</span>, () =&gt; <span class="string">"p6"</span>); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p6"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p7 = p1.then(<span class="literal">null</span>, () =&gt; <span class="built_in">Promise</span>.resolve(<span class="string">'p7'</span>)); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p7"&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> p8 = p1.then(<span class="literal">null</span>, () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="keyword">const</span> p9 = p1.then(<span class="literal">null</span>, () =&gt; <span class="built_in">Promise</span>.reject()); <span class="comment">// Uncaught (in promise) undefined Promise &#123;&lt;rejected&gt;: undefined&#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> p10 = p1.then(<span class="literal">null</span>, () =&gt; &#123; <span class="keyword">throw</span> <span class="string">"p10"</span> &#125;); <span class="comment">// Uncaught (in promise) p10 Promise &#123;&lt;rejected&gt;: "p10"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p11 = p1.then(<span class="literal">null</span>, () =&gt; <span class="built_in">Error</span>(<span class="string">"p11"</span>)); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Error: p11 at &lt;anonymous&gt;:1:33&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.prototype.catch()</p><p>Promise.prototype.catch()方法用于给期约添加拒绝处理方法, 这个方法只接收一个参数; onRejected 方法, 相当于<code>Promise.prototype. then(null, onRejected)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject();</span><br><span class="line"><span class="keyword">const</span> onRejected = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"rejected"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">p.then(<span class="literal">null</span>, onRejected); <span class="comment">// rejected</span></span><br><span class="line">p.catch(onRejected); <span class="comment">// rejected</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.catch(); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.prototype.finally()</p><p>Promise.prototype.finally()方法用于给期约添加 onFinally 处理程序, 这个处理程序在期约转换为解决或拒绝状态时都会执行, 这个方法可以避免 onResolved 和 onRejected 处理程序中出现冗余代码, 但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝, 所以这个方法主要用于添加清理代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject(); </span><br><span class="line"><span class="keyword">const</span> onFinally = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Finally!'</span>);</span><br><span class="line">&#125;</span><br><span class="line">p1.finally(onFinally); <span class="comment">// Finally!</span></span><br><span class="line">p2.finally(onFinally); <span class="comment">// Uncaught (in promise) undefined Finally!</span></span><br></pre></td></tr></table></figure><p>Promise.prototype.finally()方法返回一个新的期约实例, 这个新期约实例不同于 then()或 catch()方式返回的实例, 因为 onFinally 被设计为一个状态无关的方法, 所以在大多数情况下它将表现为父期约的传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">"p1"</span>); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p2 = p1.finally(); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p3 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">undefined</span>); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p4 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p5 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve()); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p6 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'p6'</span>); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p7 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="string">'p7'</span>)); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br><span class="line"><span class="keyword">const</span> p8 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Error</span>(<span class="string">'p8'</span>)); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br></pre></td></tr></table></figure><p>如果返回的是一个待定的期约, 或者 onFinally 处理程序抛出了错误(显式抛出或返回了一个拒绝期约)则会返回相应的期约(待定或拒绝)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">"p1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.resolve()保留返回的期约</span></span><br><span class="line"><span class="keyword">const</span> p9 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="keyword">const</span> p10 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.reject()); <span class="comment">// Uncaught (in promise) undefined Promise &#123;&lt;rejected&gt;: undefined&#125;</span></span><br><span class="line"><span class="keyword">const</span> p11 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">'p11'</span>; &#125;); <span class="comment">// Uncaught (in promise) p11 Promise &#123;&lt;rejected&gt;: "p11"&#125;</span></span><br></pre></td></tr></table></figure><p>返回待定期约的情形并不常见, 这是因为只要期约一解决, 新期约仍然会原样后传初始的期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">"p1"</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"p2"</span>), <span class="number">100</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: "p1"&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>非重入期约方法</p><p>当期约进入落定状态时, 与该状态相关的处理程序仅仅会被排期, 而非立即执行, 跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加处理程序关联的状态, 执行顺序也是这样的, 这个特性由 JavaScript 运行时保证, 被称为”非重入”(non-reentrancy)特性</p><p>跟在 then()后面的同步代码一定先于处理程序执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">"p"</span>);</span><br><span class="line">p.then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"123"</span>);</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"><span class="comment">// p</span></span><br></pre></td></tr></table></figure><p>添加处理程序后, 同步代码才改变期约状态, 那么处理程序仍然会基于该状态变化表现出非重入特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> synchronousResolve;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    synchronousResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'1: invoking resolve()'</span>);</span><br><span class="line">        resolve(); </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2: resolve() returns'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'4: then() handler executes'</span>));</span><br><span class="line">synchronousResolve(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3: synchronousResolve() returns'</span>);</span><br><span class="line"><span class="comment">// 1: invoking resolve()</span></span><br><span class="line"><span class="comment">// 2: resolve() returns</span></span><br><span class="line"><span class="comment">// 3: synchronousResolve() returns</span></span><br><span class="line"><span class="comment">// 4: then() handler executes</span></span><br></pre></td></tr></table></figure><p>非重入适用于 onResolved/onRejected 处理程序、catch()处理程序和 finally()处理程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'p1.then() onResolved'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p1.then() returns'</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject(); </span><br><span class="line">p2.then(<span class="literal">null</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'p2.then() onRejected'</span>)); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p2.then() returns'</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.reject(); </span><br><span class="line">p3.catch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'p3.catch() onRejected'</span>)); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p3.catch() returns'</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.resolve(); </span><br><span class="line">p4.finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'p4.finally() onFinally'</span>)); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p4.finally() returns'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1.then() returns</span></span><br><span class="line"><span class="comment">// p2.then() returns</span></span><br><span class="line"><span class="comment">// p3.catch() returns</span></span><br><span class="line"><span class="comment">// p4.finally() returns</span></span><br><span class="line"><span class="comment">// p1.then() onResolved</span></span><br><span class="line"><span class="comment">// p2.then() onRejected</span></span><br><span class="line"><span class="comment">// p3.catch() onRejected</span></span><br><span class="line"><span class="comment">// p4.finally() onFinally</span></span><br></pre></td></tr></table></figure></li><li><p>邻近处理程序的执行顺序</p><p>如果给期约添加了多个处理程序, 当期约状态变化时, 相关处理程序会按照添加它们的顺序依次执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject(); </span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">1</span>)); </span><br><span class="line">p1.then(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">2</span>)); </span><br><span class="line">p2.then(<span class="literal">null</span>, () =&gt; setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">3</span>)); </span><br><span class="line">p2.then(<span class="literal">null</span>, () =&gt; setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">4</span>)); </span><br><span class="line">p2.catch(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">5</span>)); </span><br><span class="line">p2.catch(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">6</span>)); </span><br><span class="line">p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">7</span>)); </span><br><span class="line">p1.finally(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">8</span>)); </span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 3 </span></span><br><span class="line"><span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 5 </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 7 </span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure></li><li><p>传递解决值和拒绝理由</p><p>在执行函数中, 解决的值和拒绝的理由是分别作为 resolve()和 reject()的第一个参数往后传的, 然后, 这些值又会传给它们各自的处理程序, 作为 onResolved 或 onRejected 处理程序的唯一参数</p><p>Promise.resolve()和 Promise.reject()在被调用时就会接收解决值和拒绝理由, 同样地它们返回的期约也会像执行器一样把这些值传给 onResolved 或 onRejected 处理程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="string">'p1'</span>)); </span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// p1 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'p2'</span>)); </span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason)); <span class="comment">// p2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">'p3'</span>); </span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(value)); <span class="comment">// p3 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.reject(<span class="string">'p4'</span>); </span><br><span class="line">p2.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">console</span>.log(reason)); <span class="comment">// p4</span></span><br></pre></td></tr></table></figure></li><li><p>拒绝期约与拒绝错误处理</p><p>拒绝期约类似于 throw()表达式, 因为它们都代表一种程序状态, 即需要中断或者特殊处理, 在期约的执行函数或处理程序中抛出错误会导致拒绝, 对应的错误对象会成为拒绝的理由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="built_in">Error</span>(<span class="string">'p1'</span>)));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Promise &#123;&lt;rejected&gt;: Error: p1</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:1:52</span></span><br><span class="line"><span class="comment">    at new Promise (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:1:12&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'p2'</span>); &#125;); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Promise &#123;&lt;rejected&gt;: Error: p2</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:2:53</span></span><br><span class="line"><span class="comment">    at new Promise (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:2:12&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'p3'</span>); &#125;); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Promise &#123;&lt;rejected&gt;: Error: p3</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:3:49&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">'p4'</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Promise &#123;&lt;rejected&gt;: Error: p4</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:4:27&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">VM499:1 Uncaught (in promise) Error: p1</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:1:52</span></span><br><span class="line"><span class="comment">    at new Promise (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:1:12</span></span><br><span class="line"><span class="comment">(anonymous) @ VM499:1</span></span><br><span class="line"><span class="comment">(anonymous) @ VM499:1</span></span><br><span class="line"><span class="comment">VM499:2 Uncaught (in promise) Error: p2</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:2:53</span></span><br><span class="line"><span class="comment">    at new Promise (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:2:12</span></span><br><span class="line"><span class="comment">(anonymous) @ VM499:2</span></span><br><span class="line"><span class="comment">(anonymous) @ VM499:2</span></span><br><span class="line"><span class="comment">VM499:4 Uncaught (in promise) Error: p4</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:4:27</span></span><br><span class="line"><span class="comment">(anonymous) @ VM499:4</span></span><br><span class="line"><span class="comment">VM499:3 Uncaught (in promise) Error: p3</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:3:49</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Promise.resolve().then()的错误最后才出现, 这是因为它需要在运行时消息队列中添加处理程序; 也就是说, 在最终抛出未捕获错误之前它还会创建另一个期约</p><p>这个例子同样揭示了异步错误有意思的副作用. 正常情况下, 在通过 throw()关键字抛出错误时, JavaScript 运行时的错误处理机制会停止执行抛出错误之后的任何指令</p><p>在期约中抛出错误时, 因为错误实际上是从消息队列中异步抛出的, 所以并不会阻止运行时继续执行同步指令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="built_in">Error</span>(<span class="string">'error'</span>)).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>// 在解决或拒绝期约之前, 仍然可以使用 try/catch 在执行函数中捕获错误<br>   let p = new Promise((resolve, reject) =&gt; {<br>       try {<br>           throw Error(‘foo’);<br>       } catch(e) {}<br>       resolve(‘bar’);<br>   });<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">then()和 catch()的 onRejected 处理程序在语义上相当于 try&#x2F;catch, 出发点都是捕获错误之后将其隔离, 同时不影响正常逻辑执行, 为此, onRejected 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;javascript</span><br><span class="line">console.log(&#39;begin synchronous execution&#39;);</span><br><span class="line">try &#123; </span><br><span class="line">    throw Error(&#39;error&#39;); </span><br><span class="line">&#125; catch(e) &#123; </span><br><span class="line">    console.log(&#39;caught error&#39;, e); </span><br><span class="line">&#125; </span><br><span class="line">console.log(&#39;continue synchronous execution&#39;); </span><br><span class="line">&#x2F;&#x2F; begin synchronous execution </span><br><span class="line">&#x2F;&#x2F; caught error Error: error </span><br><span class="line">&#x2F;&#x2F; continue synchronous execution </span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123; </span><br><span class="line">    console.log(&#39;begin asynchronous execution&#39;); </span><br><span class="line">    reject(Error(&#39;error&#39;)); </span><br><span class="line">&#125;).catch((e) &#x3D;&gt; &#123; </span><br><span class="line">    console.log(&#39;caught error&#39;, e); </span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123; </span><br><span class="line">    console.log(&#39;continue asynchronous execution&#39;); </span><br><span class="line">&#125;); </span><br><span class="line">&#x2F;&#x2F; begin asynchronous execution </span><br><span class="line">&#x2F;&#x2F; caught error Error: error </span><br><span class="line">&#x2F;&#x2F; continue asynchronous execution</span><br></pre></td></tr></table></figure></p><h4 id="期约连锁与期约合成"><a href="#期约连锁与期约合成" class="headerlink" title="期约连锁与期约合成"></a>期约连锁与期约合成</h4><ol><li><p>期约连锁</p><p>把期约逐个地串联起来是一种非常有用的编程模式, 之所以可以这样做, 是因为每个期约实例的方法(then(), catch()和 finally())都会返回一个新的期约对象, 而这个新期约又有自己的实例方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first'</span>); </span><br><span class="line">    resolve(); </span><br><span class="line">&#125;); </span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'second'</span>)) </span><br><span class="line"> .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'third'</span>)) </span><br><span class="line"> .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fourth'</span>));</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="comment">// fourth</span></span><br></pre></td></tr></table></figure><p>要真正执行异步任务, 可以改写前面的例子, 让每个执行器都返回一个期约实例, 这样就可以让每个后续期约都等待之前的期约, 也就是串行化异步任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 executor'</span>); </span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>); </span><br><span class="line">&#125;); </span><br><span class="line">p1.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 executor'</span>); </span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>); </span><br><span class="line"> &#125;)) </span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p3 executor'</span>); </span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>); </span><br><span class="line"> &#125;)) </span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p4 executor'</span>); </span><br><span class="line">    setTimeout(resolve, <span class="number">1000</span>); </span><br><span class="line"> &#125;));</span><br><span class="line"><span class="comment">// p1 executor</span></span><br><span class="line"><span class="comment">// p2 executor</span></span><br><span class="line"><span class="comment">// p3 executor</span></span><br><span class="line"><span class="comment">// p4 executor</span></span><br></pre></td></tr></table></figure><p>把生成期约的代码提取到一个工厂函数中, 就可以写成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayedResolve</span>(<span class="params">str</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(str); </span><br><span class="line">        setTimeout(resolve, <span class="number">1000</span>); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line">delayedResolve(<span class="string">'p1 executor'</span>) </span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> delayedResolve(<span class="string">'p2 executor'</span>)) </span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> delayedResolve(<span class="string">'p3 executor'</span>)) </span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> delayedResolve(<span class="string">'p4 executor'</span>))</span><br><span class="line"><span class="comment">// p1 executor</span></span><br><span class="line"><span class="comment">// p2 executor</span></span><br><span class="line"><span class="comment">// p3 executor</span></span><br><span class="line"><span class="comment">// p4 executor</span></span><br></pre></td></tr></table></figure></li><li><p>期约图</p><p>因为一个期约可以有任意多个处理程序, 所以期约连锁可以构建有向非循环图的结构, 这样, 每个期约都是图中的一个节点, 而使用实例方法添加的处理程序则是有向顶点, 因为图中的每个节点都会等待前一个节点落定, 所以图的方向就是期约的解决或拒绝顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'A'</span>); </span><br><span class="line">    resolve(); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">let</span> B = A.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'B'</span>)); </span><br><span class="line"><span class="keyword">let</span> C = A.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'C'</span>)); </span><br><span class="line">B.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'D'</span>)); </span><br><span class="line">B.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'E'</span>)); </span><br><span class="line">C.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'F'</span>)); </span><br><span class="line">C.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'G'</span>));</span><br><span class="line"><span class="comment">// A</span></span><br><span class="line"><span class="comment">// B</span></span><br><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// E</span></span><br><span class="line"><span class="comment">// F</span></span><br><span class="line"><span class="comment">// G</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.all()和 Promise.race()</p><ul><li><p>Promise.all()  静态方法创建的期约会在一组期约全部解决之后再解决, 这个静态方法接收一个可迭代对象, 返回一个新期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="string">"first"</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="string">"second"</span>)</span><br><span class="line">]); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Array(2)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.all([<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Array(2)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空的可迭代对象等价于 Promise.resolve()</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.all([]); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Array(0)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.all(); <span class="comment">// VM263:1 Uncaught (in promise) TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))</span></span><br></pre></td></tr></table></figure><p>合成的期约只会在每个包含的期约都解决之后才解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([ </span><br><span class="line">    <span class="built_in">Promise</span>.resolve(), </span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve, <span class="number">2000</span>)) </span><br><span class="line">]); </span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">'all() resolved!'</span>));</span><br><span class="line"><span class="comment">// all() resolved!</span></span><br></pre></td></tr></table></figure><p>如果至少有一个包含的期约待定, 则合成的期约也会待定, 如果有一个包含的期约拒绝, 则合成的期约也会拒绝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="string">"complete"</span>)</span><br><span class="line">]); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(),</span><br><span class="line">    <span class="built_in">Promise</span>.reject(),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve()</span><br><span class="line">]); <span class="comment">// Uncaught (in promise) undefined  Promise &#123;&lt;rejected&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure><p>如果有期约拒绝, 则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由, 之后再拒绝的期约不会影响最终期约的拒绝理由, 不过, 这并不影响所有包含期约正常的拒绝操作, 合成的期约会静默处理所有包含期约的拒绝操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">"first"</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="string">"secend"</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">])</span><br><span class="line">p.catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;); <span class="comment">// first</span></span><br></pre></td></tr></table></figure></li><li><p>Promise.race() 静态方法返回一个包装期约, 是一组集合中最先解决或拒绝的期约的镜像, 这个方法接收一个可迭代对象, 返回一个新期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">]); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">"时间2000ms"</span>)</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">"时间1000ms"</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">]); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "时间1000ms"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象中的元素会通过 Promise.resolve()转换为期约</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.race([<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空的可迭代对象等价于 new Promise(() =&gt; &#123;&#125;)</span></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.race([]); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p5 = <span class="built_in">Promise</span>.race(); <span class="comment">// Uncaught (in promise) TypeError: undefined is not iterable (cannot read property Symbol(Symbol.iterator))</span></span><br></pre></td></tr></table></figure><p>Promise.race()不会对解决或拒绝的期约区别对待, 无论是解决还是拒绝, 只要是第一个落定的期约, Promise.race()就会包装其解决值或拒绝理由并返回新期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.race([ </span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="string">"resolve"</span>), </span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(reject, <span class="number">1000</span>, <span class="string">"reject"</span>)) </span><br><span class="line">]); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: "resolve"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.race([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">"reject"</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve, <span class="number">1000</span>, <span class="string">"resolve"</span>))</span><br><span class="line">]); <span class="comment">// Uncaught (in promise) reject Promise &#123;&lt;rejected&gt;: "reject"&#125;</span></span><br></pre></td></tr></table></figure><p>如果有一个期约拒绝, 只要它是第一个落定的, 就会成为拒绝合成期约的理由, 合成的期约会静默处理所有包含期约的拒绝操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.race([ </span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">"reject1"</span>), </span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(reject, <span class="number">1000</span>, <span class="string">"reject2"</span>)) </span><br><span class="line">]);</span><br><span class="line">p.catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;); <span class="comment">// reject1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>串行期约合成</p><p>异步产生值并将其传给处理程序, 基于后续期约使用之前期约的返回值来串联期约是期约的基本功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(x)</span><br><span class="line">        .then(addTwo)</span><br><span class="line">        .then(addThree)</span><br><span class="line">        .then(addFive);</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">10</span>).then((<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>使用 Array.prototype.reduce()可以写成更简洁的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [addTwo, addThree, addFive].reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise.then(fn);</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve(x));</span><br><span class="line">&#125;</span><br><span class="line">addTen(<span class="number">100</span>).then((<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)); <span class="comment">// 110</span></span><br></pre></td></tr></table></figure><p>这种模式可以提炼出一个通用函数, 可以把任意多个函数作为处理程序合成一个连续传值的期约连锁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fns</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> fns.reduce(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.then(fn), <span class="built_in">Promise</span>.resolve(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="期约扩展"><a href="#期约扩展" class="headerlink" title="期约扩展"></a>期约扩展</h4><p>ES6 期约实现是很可靠的, 但它也有不足之处, 比如, 很多第三方期约库实现中具备而 ECMAScript规范却未涉及的两个特性, 期约取消和进度追踪</p><ol><li><p>期约取消</p><p>可以在现有实现基础上提供一种临时性的封装, 以实现取消期约的功能, 这可以用到 Kevin Smith 提到的”取消令牌”(cancel token), 生成的令牌实例提供了一个接口, 利用这个接口可以取消期约; 同时也提供了一个期约的实例, 可以用来触发取消后的操作并求值取消状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123; </span><br><span class="line">    <span class="keyword">constructor</span>(cancelFn) &#123; </span><br><span class="line">        <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">            cancelFn(resolve); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   这个类包装了一个期约, 把解决方法暴露给了 cancelFn 参数, 这样, 外部代码就可以向构造函数中传入一个函数, 从而控制什么情况下可以取消期约, 这里期约是令牌类的公共成员, 因此可以给它添加处理程序以取消期约</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start"</span>&gt;</span>Start<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"cancel"</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="class"><span class="keyword">class</span> <span class="title">CancelToken</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">constructor</span>(cancelFn) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                cancelFn(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span></span><br><span class="line"><span class="javascript">                    setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">"delay cancelled"</span>); </span></span><br><span class="line">                    resolve(); </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> startButton = <span class="built_in">document</span>.querySelector(<span class="string">"#start"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> cancelButton = <span class="built_in">document</span>.querySelector(<span class="string">"#cancel"</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">cancelCallback</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"cancel"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">cancellableDelayedResolve</span><span class="params">(delay)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">"set delay"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> id = setTimeout(<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">"delayed resolve"</span>);</span></span><br><span class="line">            &#125;), delay);</span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> cancelToken = <span class="keyword">new</span> CancelToken(<span class="function">(<span class="params">cancelCallback</span>) =&gt;</span> </span></span><br><span class="line"><span class="actionscript">                cancelButton.addEventListener(<span class="string">"click"</span>, cancelCallback));</span></span><br><span class="line"><span class="javascript">            cancelToken.promise.then(<span class="function"><span class="params">()</span> =&gt;</span> clearTimeout(id));</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    startButton.addEventListener(<span class="string">"click"</span>, () =&gt; cancellableDelayedResolve(<span class="number">1000</span>));</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>期约进度通知</p><p>执行中的期约可能会有不少离散的”阶段”, 在最终解决之前必须依次经过</p><p>一种实现方式是扩展 Promise 类, 为它添加 notify()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackablePromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">const</span> notifyHandlers = [];</span><br><span class="line">        <span class="keyword">super</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> executor(resolve, reject, (status) =&gt; &#123; </span><br><span class="line">                notifyHandlers.map(<span class="function">(<span class="params">handler</span>) =&gt;</span> handler(status)); </span><br><span class="line">            &#125;); </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.notifyHandlers = notifyHandlers;</span><br><span class="line">    &#125;</span><br><span class="line">    notify(notifyHandler) &#123; </span><br><span class="line">        <span class="keyword">this</span>.notifyHandlers.push(notifyHandler); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> TrackablePromise(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            notify(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>); </span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> countdown(x - <span class="number">1</span>), <span class="number">1000</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            resolve(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    countdown(<span class="number">5</span>);</span><br><span class="line">&#125;); <span class="comment">// Promise &#123;&lt;pending&gt;, notifyHandlers: Array(0)&#125;</span></span><br><span class="line"></span><br><span class="line">p.notify(<span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">`progross <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">'completed'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// progross 80% remaining</span></span><br><span class="line"><span class="comment">// progross 60% remaining</span></span><br><span class="line"><span class="comment">// progross 40% remaining</span></span><br><span class="line"><span class="comment">// progross 20% remaining</span></span><br><span class="line"><span class="comment">// completed</span></span><br></pre></td></tr></table></figure><p>notify()函数会返回期约, 所以可以连缀调用, 连续添加处理程序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackablePromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">const</span> notifyHandlers = [];</span><br><span class="line">        <span class="keyword">super</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> executor(resolve, reject, (status) =&gt; &#123; </span><br><span class="line">                notifyHandlers.map(<span class="function">(<span class="params">handler</span>) =&gt;</span> handler(status)); </span><br><span class="line">            &#125;); </span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.notifyHandlers = notifyHandlers;</span><br><span class="line">    &#125;</span><br><span class="line">    notify(notifyHandler) &#123; </span><br><span class="line">        <span class="keyword">this</span>.notifyHandlers.push(notifyHandler); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> TrackablePromise(<span class="function">(<span class="params">resolve, reject, notify</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">countdown</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            notify(<span class="string">`<span class="subst">$&#123;<span class="number">20</span> * x&#125;</span>% remaining`</span>); </span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> countdown(x - <span class="number">1</span>), <span class="number">1000</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            resolve(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    countdown(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.notify(<span class="function">(<span class="params">x</span>) =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">'a:'</span>, x))</span><br><span class="line">    .notify(<span class="function">(<span class="params">x</span>) =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">'b:'</span>, x)); </span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="string">'completed'</span>));</span><br><span class="line"><span class="comment">// a: 80% remaining</span></span><br><span class="line"><span class="comment">// b: 80% remaining</span></span><br><span class="line"><span class="comment">// a: 60% remaining</span></span><br><span class="line"><span class="comment">// b: 60% remaining</span></span><br><span class="line"><span class="comment">// a: 40% remaining</span></span><br><span class="line"><span class="comment">// b: 40% remaining</span></span><br><span class="line"><span class="comment">// a: 20% remaining</span></span><br><span class="line"><span class="comment">// b: 20% remaining</span></span><br><span class="line"><span class="comment">// completed</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>异步函数, 也称为”async/await”(语法关键字), 是 ES6 期约模式在 ECMAScript 函数中的应用, async/await 是 ES8 规范新增的</p><h4 id="异步函数-1"><a href="#异步函数-1" class="headerlink" title="异步函数"></a>异步函数</h4><p>ES8 的 async/await 旨在解决利用异步结构组织代码的问题, 为此, ECMAScript 对函数进行了扩展, 为其增加了两个新关键字: async 和 await</p><ol><li><p>async 关键字用于声明异步函数, 这个关键字可以用在函数声明, 函数表达式, 箭头函数和方法上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bbb = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> ccc = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DDD</span> </span>&#123; </span><br><span class="line">    <span class="keyword">async</span> ddd() &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 async 关键字可以让函数具有异步特征, 但总体上其代码仍然是同步求值的, 而在参数或闭包方面, 异步函数仍然具有普通 JavaScript 函数的正常行为, 不过, 异步函数如果使用 return 关键字返回了值(如果没有 return 则会返回 undefined), 这个值会被 Promise.resolve()包装成一个期约对象, 异步函数始终返回期约对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"print"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "print"</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say().then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// "hi"</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>异步函数的返回值期待(但实际上并不要求)一个实现 thenable 接口的对象, 但常规的值也可以, 如果返回的是实现 thenable 接口的对象, 则这个对象可以由提供给 then()的处理程序”解包”, 如果不是, 则返回值就被当作已经解决的期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">test1().then(<span class="built_in">console</span>.log); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个没有实现 thenable 接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">test2().then(<span class="built_in">console</span>.log); <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个实现了 thenable 接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        then(cb) &#123;</span><br><span class="line">            cb(<span class="string">"test3"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test3().then(<span class="built_in">console</span>.log); <span class="comment">// test3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"test4"</span>);</span><br><span class="line">&#125;</span><br><span class="line">test4().then(<span class="built_in">console</span>.log); <span class="comment">// test4</span></span><br></pre></td></tr></table></figure><p>与在期约处理程序中一样, 在异步函数中抛出错误会返回拒绝的期约</p><p>不过, 拒绝期约的错误不会被异步函数捕获</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"error"</span>;</span><br><span class="line">&#125;</span><br><span class="line">aaa().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">bbb().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) 1</span></span><br></pre></td></tr></table></figure></li><li><p>await</p><p>因为异步函数主要针对不会马上完成的任务, 所以自然需要一种暂停和恢复执行的能力, 使用 await关键字可以暂停异步函数代码的执行, 等待期约解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>使用 async/await 可以写成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve, <span class="number">1000</span>, <span class="number">3</span>)); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> p); </span><br><span class="line">&#125;</span><br><span class="line">aaa(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>await 关键字会暂停执行异步函数后面的代码, 让出 JavaScript 运行时的执行线程,  await 关键字同样是尝试”解包”对象的值, 然后将这个值传给表达式, 再异步恢复异步函数的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, <span class="number">1000</span>, <span class="string">"aaaa"</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bbbb"</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">aaa();</span><br><span class="line"><span class="comment">// 等待了一秒</span></span><br><span class="line"><span class="comment">// aaaa</span></span><br><span class="line"><span class="comment">// bbbb</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ccc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, <span class="number">1000</span>, <span class="string">"cccc"</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ddd"</span>);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">ccc()</span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"><span class="comment">// ddd</span></span><br></pre></td></tr></table></figure><p>await 关键字期待一个实现 thenable 接口的对象, 但常规的值也可以, 如果是实现 thenable 接口的对象, 则这个对象可以由 await 来”解包”, 如果不是, 则这个值就被当作已经解决的期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">test1(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个没有实现 thenable 接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> [<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line">test2(); <span class="comment">// [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个实现了 thenable 接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> &#123;</span><br><span class="line">        then(cb) &#123;</span><br><span class="line">            cb(<span class="string">"test3"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">test3(); <span class="comment">// test3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test4</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'test4'</span>)); </span><br><span class="line">&#125; </span><br><span class="line">test4(); <span class="comment">// test4</span></span><br></pre></td></tr></table></figure><p>等待会抛出错误的同步操作, 会返回拒绝的期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">await</span> (<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="number">3</span>; </span><br><span class="line">    &#125;)();  </span><br><span class="line">&#125;</span><br><span class="line">aaa().catch(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>单独的 Promise.reject()不会被异步函数捕获, 而会抛出未捕获错误, 不过, 对拒绝的期约使用 await 则会释放(unwrap)错误值(将拒绝期约返回)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">3</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// 发现没有执行</span></span><br><span class="line">&#125; </span><br><span class="line">bbb().catch(<span class="built_in">console</span>.log); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>await的限制</p><p>await 关键字必须在异步函数中使用, 不能在顶级上下文如 <code>&lt;script&gt;</code>标签或模块中使用,  定义并立即调用异步函数是没问题的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)); </span><br><span class="line">&#125; </span><br><span class="line">aaa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同下</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>)); </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>异步函数的特质不会扩展到嵌套函数, await 关键字也只能直接出现在异步函数的定义中</p></li></ol><h4 id="停止和恢复执行"><a href="#停止和恢复执行" class="headerlink" title="停止和恢复执行"></a>停止和恢复执行</h4><p>使用 await 关键字之后的区别其实比看上去的还要微妙一些</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="string">'bar'</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'baz'</span>); </span><br><span class="line">&#125; </span><br><span class="line">foo(); </span><br><span class="line">bar(); </span><br><span class="line">baz();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 谷歌浏览器顺序</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qq浏览器</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// foo</span></span><br></pre></td></tr></table></figure><p>JavaScript 运行时在碰到 await 关键字时, 会记录在哪里暂停执行, 等到 await 右边的值可用了, JavaScript 运行时会向消息队列中推送一个任务, 这个任务会恢复异步函数的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="literal">null</span>; <span class="comment">// 执行到这里时  会退出aaa 继续执行 后面的同步代码, 等到同步代码执行完后 继续执行await 后面的代码</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">aaa();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">aaa();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">setTimeout(<span class="built_in">console</span>.log, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>如果 await 后面是一个期约, 则问题会稍微复杂一些, 为了执行异步函数, 实际上会有两个任务被添加到消息队列并被异步求值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">8</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line">aaa(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>); </span><br><span class="line">bbb(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>TC39 对 await 后面是期约的情况如何处理做过一次修改, 修改后, 本例中的 Promise.resolve(8)只会生成一个异步任务</p><h4 id="异步函数策略"><a href="#异步函数策略" class="headerlink" title="异步函数策略"></a>异步函数策略</h4><ol><li><p>实现sleep()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> setTimeout(resolve, delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1500</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() - startTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aaa(); <span class="comment">// 1503</span></span><br></pre></td></tr></table></figure></li><li><p>利用平行执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>); </span><br><span class="line">        resolve(); </span><br><span class="line">    &#125;, delay)); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now(); </span><br><span class="line">    <span class="keyword">await</span> randomDelay(<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">await</span> randomDelay(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">await</span> randomDelay(<span class="number">2</span>); </span><br><span class="line">    <span class="keyword">await</span> randomDelay(<span class="number">3</span>); </span><br><span class="line">    <span class="keyword">await</span> randomDelay(<span class="number">4</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>); </span><br><span class="line">&#125; </span><br><span class="line">aaa();</span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 3326ms elapsed</span></span><br></pre></td></tr></table></figure><p>上面这个例子 其实我们 没有必要等到上一个promise await完  再await 下一个promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">randomDelay</span>(<span class="params">id</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;id&#125;</span> finished`</span>); </span><br><span class="line">        resolve(id); </span><br><span class="line">    &#125;, delay)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bbb</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> t0 = <span class="built_in">Date</span>.now(); </span><br><span class="line">    <span class="keyword">const</span> promises = <span class="built_in">Array</span>(<span class="number">5</span>).fill(<span class="literal">null</span>).map(<span class="function">(<span class="params">_, i</span>) =&gt;</span> randomDelay(i)); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123; </span><br><span class="line">        <span class="keyword">await</span> p; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms elapsed`</span>); </span><br><span class="line">&#125;</span><br><span class="line">bbb();</span><br><span class="line"><span class="comment">// 3 finished</span></span><br><span class="line"><span class="comment">// 0 finished</span></span><br><span class="line"><span class="comment">// 4 finished</span></span><br><span class="line"><span class="comment">// 2 finished</span></span><br><span class="line"><span class="comment">// 1 finished</span></span><br><span class="line"><span class="comment">// 992ms elapsed</span></span><br></pre></td></tr></table></figure></li><li><p>串行执行期约</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTwo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addThree</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addFive</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123; </span><br><span class="line">        x = <span class="keyword">await</span> fn(x); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">&#125; </span><br><span class="line">addTen(<span class="number">9</span>).then(<span class="built_in">console</span>.log); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure></li><li><p>栈追踪与内存管理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooPromiseExecutor1</span>(<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">    setTimeout(reject, <span class="number">1000</span>, <span class="string">'bar'</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(fooPromiseExecutor1); </span><br><span class="line">&#125;</span><br><span class="line">foo1(); <span class="comment">// Uncaught (in promise) bar</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooPromiseExecutor2</span>(<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">    setTimeout(reject, <span class="number">1000</span>, <span class="string">'bar'</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(fooPromiseExecutor2); </span><br><span class="line">&#125; </span><br><span class="line">foo();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Uncaught (in promise) bar</span></span><br><span class="line"><span class="comment">foo2 @ VM110:6</span></span><br><span class="line"><span class="comment">async function (async)</span></span><br><span class="line"><span class="comment">foo2 @ VM110:5</span></span><br><span class="line"><span class="comment">(anonymous) @ VM110:7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版-第十章-笔记</title>
    <link href="http://blog.decade.run/2021/02/07/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2021/02/07/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-07T02:41:00.000Z</published>
    <updated>2021-02-19T05:47:54.982Z</updated>
    
    <content type="html"><![CDATA[<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ECMAScript 6 新增了使用胖箭头<code>(=&gt;)</code>语法定义函数表达式的能力, 很大程度上, 箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的,</p><p>箭头函数不能使用 <code>arguments、super 和new.target</code>, 也不能用作构造函数, 此外, 箭头函数也没有 <code>prototype</code> 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrowFunc = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">arrowFunc(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">arrowFunc;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(a, b) =&gt; &#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>因为函数名就是指向函数的指针, 所以它们跟其他包含对象指针的变量具有相同的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sayHI = sayHi;</span><br><span class="line">sayHI === sayHi; <span class="comment">// true</span></span><br><span class="line">sayHI; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ƒ sayHi() &#123;</span></span><br><span class="line"><span class="comment">    console.log("hi");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性, 其中包含关于函数的信息, 多数情况下, 这个属性中保存的就是一个函数标识符, 或者说是一个字符串化的变量名, 即使函数没有名称, 也会如实显示成空字符串, 如果它是使用 Function 构造函数创建的, 则会标识成<code>&quot;anonymous&quot;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">foo.name; <span class="comment">// foo</span></span><br><span class="line">baz.name; <span class="comment">// baz</span></span><br><span class="line">bar.name; <span class="comment">// bar</span></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).name; <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name); <span class="comment">// anonymous</span></span><br></pre></td></tr></table></figure><p>如果函数是一个获取函数, 设置函数, 或者使用 bind()实例化, 那么标识符前面会加上一个前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(<span class="literal">null</span>).name; <span class="comment">// "bound foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    _name: <span class="string">"decade"</span>,</span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> name(newName) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="keyword">get</span>, <span class="keyword">set</span> &#125; = Object.getOwnPropertyDescriptor(person, "name");</span><br><span class="line"><span class="keyword">get</span>.name; // "<span class="keyword">get</span> name"</span><br><span class="line"><span class="keyword">set</span>.name; // "<span class="keyword">set</span> name"</span><br></pre></td></tr></table></figure><h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><p>ECMAScript 函数既不关心传入的参数个数, 也不关心这些参数的数据类型</p><p>函数被调用时总会接收一个数组, 但函数并不关心这个数组中包含什么</p><p><code>arguments</code> 对象是一个类数组对象, 需要知道传了多少个参数可以访问<code>arguments.length</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name, msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"第一个参数"</span>, <span class="built_in">arguments</span>[<span class="number">0</span>] === name); <span class="comment">//  第一个参数 true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"第二个参数"</span>, <span class="built_in">arguments</span>[<span class="number">1</span>] === msg); <span class="comment">// 第二个参数 true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hello  <span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;msg&#125;</span>`</span>); <span class="comment">//  Hello  decade, henshin</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"请传入两个参数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sayHi(<span class="string">"decade"</span>, <span class="string">"henshin"</span>);</span><br></pre></td></tr></table></figure><p><code>arguments</code> 对象可以跟命名参数一起使用,  它的值始终会与对应的命名参数同步, 这并不意味着它们都访问同一个内存地址, 如果只传了一个参数, 然后把 <code>arguments[1]</code>设置为某个值, 那么这个值并不会反映到第二个命名参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line">say(obj); <span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say1</span>(<span class="params">name, hi</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="string">"你好"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>  <span class="subst">$&#123;hi&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">say1(<span class="string">"decade"</span>); <span class="comment">// decade  undefined</span></span><br></pre></td></tr></table></figure><p>箭头函数的参数将不能使用 arguments 关键字访问</p><h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>ECMAScript 函数没有签名,  ECMAScript 中定义了两个同名函数, 则后定义的会覆盖先定义的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = add(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 300</span></span><br></pre></td></tr></table></figure><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>在 ECMAScript5.1 及以前, 实现默认参数的一种常用方式就是检测某个参数是否等于 <code>undefined</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    name = (<span class="keyword">typeof</span> name !== <span class="string">'undefined'</span>) ? name : <span class="string">'decade'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span> + <span class="string">"  "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">sayHi(); <span class="comment">// hello  decade</span></span><br><span class="line">sayHi(<span class="string">"zio"</span>); <span class="comment">// hello  zio</span></span><br></pre></td></tr></table></figure><p>ECMAScript 6 之后就不用这么麻烦了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name = <span class="string">"decade"</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span> + <span class="string">"  "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">sayHi(); <span class="comment">//  hello  decade</span></span><br><span class="line">sayHi(<span class="string">"zio"</span>); <span class="comment">// hello  zio</span></span><br></pre></td></tr></table></figure><h3 id="默认参数作用域与暂时性死区"><a href="#默认参数作用域与暂时性死区" class="headerlink" title="默认参数作用域与暂时性死区"></a>默认参数作用域与暂时性死区</h3><p>因为在求值默认参数时可以定义对象, 也可以动态调用函数, 所以函数参数肯定是在某个作用域中求值的</p><p>默认参数会按照定义它们的顺序依次被初始化, 所以后定义默认值的参数可以引用先定义的参数</p><h3 id="参数扩展与收集"><a href="#参数扩展与收集" class="headerlink" title="参数扩展与收集"></a>参数扩展与收集</h3><p>ECMAScript 6 新增了扩展操作符, 使用它可以非常简洁地操作和组合集合数据, 扩展操作符最有用的场景就是函数定义中的参数列表, 在这里它可以充分利用这门语言的弱类型及参数长度可变的特点, 扩展操作符既可以用于调用函数时传参, 也可以用于定义函数参数</p><h4 id="扩展参数"><a href="#扩展参数" class="headerlink" title="扩展参数"></a>扩展参数</h4><p>在给函数传参时, 有时候可能不需要传一个数组, 而是要分别传入数组的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; ++i) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getSum(...arr); <span class="comment">// 10</span></span><br><span class="line">getSum(<span class="number">-1</span>, ...arr, ...[<span class="number">200</span>, <span class="number">-100</span>]); <span class="comment">// 109</span></span><br></pre></td></tr></table></figure><h4 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h4><p>在构思函数定义时, 可以使用扩展操作符把不同长度的独立参数组合为一个数组, 因为收集参数的结果可变, 所以只能把它作为最后一个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">...arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum1</span>(<span class="params">...arr, a</span>)</span>&#123;&#125;; <span class="comment">// 这样不行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum2</span>(<span class="params">init, ...arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;, init)</span><br><span class="line">&#125;;</span><br><span class="line">getSum2(<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 106</span></span><br></pre></td></tr></table></figure><h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>JavaScript 引擎在任何代码执行之前, 会先读取函数声明, 并在执行上下文中生成函数定义, 而函数表达式必须等到代码执行到它那一行, 才会在执行上下文中生成函数定义, 这个过程叫作函数声明提升<code>(function declaration hoisting)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这么写是没有问题的</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>)); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把前面代码中的函数声明改为等价的函数表达式, 那么执行的时候就会出错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>, <span class="number">10</span>));  <span class="comment">// Uncaught ReferenceError: sum is not defined at &lt;anonymous&gt;:1:13</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum1(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// Uncaught TypeError: sum is not a function at &lt;anonymous&gt;:1:13</span></span><br><span class="line"><span class="keyword">var</span> sum1 = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h3><p>因为函数名在 ECMAScript 中就是变量, 所以函数可以用在任何可以使用变量的地方, 这意味着不仅可以把函数作为参数传给另一个函数, 而且还可以在一个函数中返回另一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> someFunction(someArgument); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = callSomeFunction(add10, <span class="number">10</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>一个函数中返回另一个函数也是可以的</p><h3 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h3><p>在 ECMAScript 5 中, 函数内部存在两个特殊的对象: <code>arguments</code> 和 <code>this</code>, ECMAScript 6 又新增了 <code>new.target</code> 属性</p><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>它是一个类数组对象, 包含调用函数时传入的所有参数, 只有以<code>function</code>关键字定义的函数才有, 自己还有一个<code>callee</code>属性, 指向<code>arguments</code>对象所在函数的指针</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>另一个特殊的对象是 <code>this</code>, 它在标准函数和箭头函数中有不同的行为, 在标准函数中, <code>this</code> 引用的是把函数当成方法调用的上下文对象, 这时候通常称其为 this 值(在网页的全局上下文中调用函数时, <code>this</code> 指向 <code>windows</code>), 在箭头函数中, <code>this</code>引用的是定义箭头函数的上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"zio"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sayName1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.name;</span><br><span class="line"></span><br><span class="line">obj.sayName = sayName;</span><br><span class="line">obj.sayName1 = sayName1;</span><br><span class="line"></span><br><span class="line">sayName(); <span class="comment">// zio</span></span><br><span class="line">obj.sayName(); <span class="comment">// decade</span></span><br><span class="line">sayName1(); <span class="comment">// zio</span></span><br><span class="line">obj.sayName1(); <span class="comment">// zio</span></span><br></pre></td></tr></table></figure><h4 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h4><p>ECMAScript 5 也会给函数对象上添加一个属性: <code>caller</code>, 这个属性引用的是调用当前函数的函数``</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ƒ outer() &#123;</span></span><br><span class="line"><span class="comment">    inner();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在严格模式下访问 arguments.callee 会报错, ECMAScript 5 也定义了 arguments.caller, 但在严格模式下访问它会报错, 在非严格模式下则始终是 undefined, 严格模式下还有一个限制，就是不能给函数的 caller 属性赋值，否则会导致错误</p><h4 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h4><p>ECMAScript 中的函数始终可以作为构造函数实例化一个新对象, 也可以作为普通函数被调用, ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性, 如果函数是正常调用的, 则 new.target 的值是 undefined; 如果是使用 new 关键字调用的, 则 new.target 将引用被调用的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Person must be instantiated using "new"'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Person instantiated using "new"'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Person(); <span class="comment">// Person instantiated using "new"</span></span><br><span class="line">Person(); <span class="comment">// Uncaught Person must be instantiated using "new"</span></span><br></pre></td></tr></table></figure><h3 id="属性-与方法"><a href="#属性-与方法" class="headerlink" title="属性 与方法"></a>属性 与方法</h3><p>ECMAScript 中的函数是对象, 因此有属性和方法, 每个函数都有两个属性: <code>length</code>和 <code>prototype</code>, 其中, <code>length</code> 属性保存函数定义的命名参数的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">param</span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">param1, param2</span>) </span>&#123;&#125;;</span><br><span class="line">a.length; <span class="comment">// 0</span></span><br><span class="line">b.length; <span class="comment">// 1</span></span><br><span class="line">c.length; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>prototype 属性也许是 ECMAScript 核心中最有趣的部分, <code>prototype</code> 是保存引用类型所有实例方法的地方, 这意味着 <code>toString()、valueOf()</code>等方法实际上都保存在 <code>prototype</code> 上, 进而由所有实例共享</p><p>函数还有两个方法：<code>apply(),  call()</code>, 这两个方法都会以指定的 this 值来调用函数, 即会设置调用函数时函数体内 this 对象的值</p><p><code>apply()</code>方法接收两个参数：函数内 this 的值和一个参数数组, 第二个参数可以是 Array 的实例, 但也可以是 arguments 对象</p><p><code>call()</code>方法接收的第一个参数是函数内 this 的值, 第二个或者第三个等等等参数都挨个列出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applySum1</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applySum2</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [a, b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, ...arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line">applySum1(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line">applySum2(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line">callSum1(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line">callSum2(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>ECMAScript 5 出于同样的目的定义了一个新方法: <code>bind()</code>, <code>bind()</code>方法会创建一个新的函数实例, 其 this 值会被绑定到传给 <code>bind()</code>的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"green"</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    color: <span class="string">"red"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.printColor = printColor.bind(obj);</span><br><span class="line">printColor(); <span class="comment">// green</span></span><br><span class="line">obj.printColor(); <span class="comment">// red</span></span><br></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>定义函数有两种方式：函数声明和函数表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> add1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归函数通常的形式是一个函数通过名称调用自己</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherFactorial = factorial;; <span class="comment">// 复制一份</span></span><br><span class="line">factorial = <span class="literal">null</span>; <span class="comment">// 重置引用</span></span><br><span class="line">anotherFactorial(<span class="number">4</span>); <span class="comment">// Uncaught TypeError: factorial is not a function 因为在之前的factorial内部还调用了factorial但是修改后的factorial为null所以报错</span></span><br></pre></td></tr></table></figure><p>我们可以使用<code>arguments.callee</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的话在严格模式下是不能访问到<code>arguments.callee</code>  这时可以使用命名函数表达式<code>(named function expression)</code>达到目的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>ECMAScript 6 规范新增了一项内存管理优化机制, 让 JavaScript 引擎在满足条件时可以重用栈帧, 具体来说, 这项优化非常适合”尾调用’’, 即外部函数的返回值是一个内部函数的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> innerFunction(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ES6 优化之前, 执行这个例子会在内存中发生如下操作</p><ul><li>执行到 outerFunction 函数体, 第一个栈帧被推到栈上</li><li>执行 outerFunction 函数体, 到 return 语句, 计算返回值必须先计算 innerFunction</li><li>执行到 innerFunction 函数体, 第二个栈帧被推到栈上</li><li>执行 innerFunction 函数体, 计算其返回值</li><li>将返回值传回 outerFunction, 然后 outerFunction 再返回值</li><li>将栈帧弹出栈外</li></ul><p>优化后</p><ul><li>执行到 outerFunction 函数体, 第一个栈帧被推到栈上</li><li>执行 outerFunction 函数体, 到 return 语句, 计算返回值必须先计算 innerFunction</li><li>引擎发现把第一个栈帧弹出栈外也没问题, 因为 innerFunction 的返回值也是 outerFunction的返回值</li><li>弹出 outerFunction 的栈帧</li><li>执行到 innerFunction 函数体, 栈帧被推到栈上</li><li>执行 innerFunction 函数体, 计算其返回值</li><li>将 innerFunction 的栈帧弹出栈外</li></ul><p>很明显, 第一种情况下每多调用一次嵌套函数, 就会多增加一个栈帧, 而第二种情况下无论调用多少次嵌套函数, 都只有一个栈帧</p><h4 id="尾调用优化的条件"><a href="#尾调用优化的条件" class="headerlink" title="尾调用优化的条件"></a>尾调用优化的条件</h4><p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了, 涉及的条件如下</p><ul><li>代码在严格模式下执行</li><li>外部函数的返回值是对尾调用函数的调用</li><li>尾调用函数返回后不需要执行额外的逻辑</li><li>尾调用函数不是引用外部函数作用域中自由变量的闭包</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无优化：尾调用没有返回 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    innerFunction(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无优化：尾调用没有直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction2</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> innerFunctionResult = innerFunction(); </span><br><span class="line">    <span class="keyword">return</span> innerFunctionResult; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无优化：尾调用返回后必须转型为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction3</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> innerFunction().toString(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无优化：尾调用是一个闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction4</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> foo = <span class="string">'bar'</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> foo; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> innerFunction(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有优化：栈帧销毁前执行参数计算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction4</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> innerFunction(a + b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有优化：初始返回值不涉及栈帧</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction5</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123; </span><br><span class="line">        <span class="keyword">return</span> a; </span><br><span class="line">    &#125; </span><br><span class="line"> <span class="keyword">return</span> innerFunction(a + b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有优化：两个内部函数都在尾部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunction6</span>(<span class="params">condition</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> condition ? innerFunctionA() : innerFunctionB(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尾调用优化的代码"><a href="#尾调用优化的代码" class="headerlink" title="尾调用优化的代码"></a>尾调用优化的代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> n; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这个函数不符合尾调用优化的条件, 因为返回语句中有一个相加的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> fibImpl(<span class="number">0</span>, <span class="number">1</span>, n); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibImpl</span>(<span class="params">a, b, n</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> a; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> fibImpl(b, a + b, n - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指的是那些引用了另一个函数作用域中变量的函数, 通常是在嵌套函数中实现的</p><p>闭包会保留它们包含函数的作用域, 所以比其他函数更占用内存</p><h4 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h4><p>在闭包中使用 this 会让代码变复杂</p><ul><li>如果内部函数没有使用箭头函数定义, 则 this 对象会在运行时绑定到执行函数的上下文</li><li>如果在全局函数中调用, 则 this 在非严格模式下等于 window, 在严格模式下等于 undefined</li><li>如果作为某个对象的方法调用, 则 this 等于这个对象</li><li>匿名函数在这种情况下不会绑定到某个对象, 这就意味着 this 会指向 window, 除非在严格模式下 this 是 undefined</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identify = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    identify: <span class="string">'obj'</span>,</span><br><span class="line">    getIdentifyFunc() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.identify;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getIdentityFunc()(); <span class="comment">// obj</span></span><br></pre></td></tr></table></figure><p>this 和 arguments 都是不能直接在内部函数中访问的, 如果想访问包含作用域中的 arguments 对象, 则同样需要将其引用先保存到闭包能访问的另一个变量中</p><p>在一些特殊情况下, this 值可能并不是我们所期待的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identify = <span class="string">"window"</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    identify: <span class="string">'obj'</span>,</span><br><span class="line">    getIdentifyFunc() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.identify;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object.getIdentity(); <span class="comment">// obj</span></span><br><span class="line">(object.getIdentity)(); <span class="comment">// obj</span></span><br><span class="line">(object.getIdentity = object.getIdentity)(); <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 执行了一次赋值，然后再调用赋值后的结果, 因为赋值表达式的值是函数本身, this 值不再与任何对象绑定</span></span><br></pre></td></tr></table></figure><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'someElement'</span>); </span><br><span class="line">    element.onclick = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(element.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onclick方法中的引用这element的<code>id</code>属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'someElement'</span>); </span><br><span class="line">    <span class="keyword">let</span> id = element.id; </span><br><span class="line">    element.onclick = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(id);</span><br><span class="line">    element = <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为闭包还是会引用包含函数的活动对象, 而其中包含element, 即使闭包没有直接引用 element, 包含函数的活动对象上还是保存着对它的引用, 因此, 必须再把 element 设置为 null</p><h3 id="即调用的函数表达式"><a href="#即调用的函数表达式" class="headerlink" title="即调用的函数表达式"></a>即调用的函数表达式</h3><p>立即调用的匿名函数又被称作立即调用的函数表达式<code>(IIFE, Immediately Invoked Function Expression)</code>,  它类似于函数声明, 但由于被包含在括号中, 所以会被解释为函数表达式</p><p>使用 IIFE 可以模拟块级作用域, 即在一个函数表达式内部声明变量, 然后立即调用这个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;)(); </span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p>在 ECMAScript 6 以后, IIFE 就没有那么必要了, 因为块级作用域中的变量无须 IIFE 就可以实现同样的隔离</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>严格来讲, JavaScript 没有私有成员的概念, 所有对象属性都公有的, 不过, 倒是有私有变量的概念, 任何定义在函数或块中的变量, 都可以认为是私有的, 因为在这个函数或块的外部无法访问其中的变量, 私有变量包括函数参数, 局部变量, 以及函数内部定义的其他函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 add 里面有三个 私有变量, a, b, sum, 这三个变量只能在函数内部访问, 在这个函数中创建了一个闭包, 则这个闭包能通过其作用域链访问其外部的这 3 个变量</p><p>特权方法<code>(privileged method)</code>是能够访问函数私有变量<code>(及私有函数)</code>的公有方法, 在对象上有两种方式创建特权方法</p><p>第一种是在构造函数中实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">provateFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.pubilcMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> provateFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以定义私有变量和特权方法, 以隐藏不能被直接修改的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">        name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><p>特权方法也可以通过使用私有作用域定义私有变量和函数来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">let</span> privateVariable = <span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line">    <span class="comment">// 公有和特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        privateVariable++; </span><br><span class="line">        <span class="keyword">return</span> privateFunction(); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>特权方法作为一个闭包, 始终引用着包含它的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">''</span>; </span><br><span class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; </span><br><span class="line">        name = value; </span><br><span class="line">    &#125;; </span><br><span class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> name; </span><br><span class="line">    &#125;; </span><br><span class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; </span><br><span class="line">        name = value; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>创建静态私有变量可以利用原型更好地重用代码, 只是每个实例没有了自己的私有变量</p><p>使用闭包和私有变量会导致作用域链变长, 作用域链越长, 则查找变量所需的时间也越多</p><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4><p>在一个单例对象上实现了相同的隔离和封装, </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">let</span> privateVariable = <span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line"> <span class="comment">// 特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        publicProperty: <span class="literal">true</span>, </span><br><span class="line">        publicMethod() &#123; </span><br><span class="line">            privateVariable++; </span><br><span class="line">            <span class="keyword">return</span> privateFunction(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>在模块模式中, 单例对象作为一个模块, 经过初始化可以包含某些私有的数据, 而这些数据又可以通过其暴露的公共方法来访问,</p><h4 id="模块增强模式"><a href="#模块增强模式" class="headerlink" title="模块增强模式"></a>模块增强模式</h4><p>另一个利用模块模式的做法是在返回对象之前先对其进行增强</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">let</span> privateVariable = <span class="number">10</span>; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="keyword">let</span> object = <span class="keyword">new</span> CustomType(); </span><br><span class="line">    <span class="comment">// 添加特权/公有属性和方法</span></span><br><span class="line">    object.publicProperty = <span class="literal">true</span>; </span><br><span class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        privateVariable++; </span><br><span class="line">        <span class="keyword">return</span> privateFunction(); </span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> object; </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版-第九章-笔记</title>
    <link href="http://blog.decade.run/2021/02/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2021/02/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2021-02-05T02:53:45.000Z</published>
    <updated>2021-02-07T02:26:36.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h3><h4 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h4><p>最简单的代理是空代理, 即除了作为一个抽象的目标对象, 什么也不做, 默认情况下, 在代理对象上执行的所有操作都会无障碍地传播到目标对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Proxy &#123;name: "decade", age: 20&#125;</span></span><br><span class="line"><span class="comment">[[handlerr]]: Object</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">[[Target]]: Object</span></span><br><span class="line"><span class="comment">age: 20</span></span><br><span class="line"><span class="comment">name: "decade"</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">[[IsRevoked]]: false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">proxy.name; <span class="comment">// decade</span></span><br><span class="line">target.name; <span class="comment">// decade</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// target 添加新属性</span></span><br><span class="line">target.like = <span class="string">"coding"</span>;</span><br><span class="line">proxy.like; <span class="string">"coding"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy 添加</span></span><br><span class="line">proxy.xxx = <span class="number">1</span>;</span><br><span class="line">target.xxx; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改proxy</span></span><br><span class="line">proxy.like = <span class="string">"code"</span>;</span><br><span class="line">target.like; <span class="string">"code"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hasOwnProperty</span></span><br><span class="line">target.hasOwnProperty(<span class="string">"name"</span>); <span class="comment">// true</span></span><br><span class="line">proxy.hasOwnProperty(<span class="string">"name"</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">target <span class="keyword">instanceof</span> <span class="built_in">Proxy</span>; <span class="comment">// Uncaught TypeError: Function has non-object prototype 'undefined' in instanceof check at Function.[Symbol.hasInstance] (&lt;anonymous&gt;)</span></span><br><span class="line"></span><br><span class="line">target === proxy; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h4><p>使用代理的主要目的是可以定义捕获器<code>(trap)</code>, 捕获器就是在处理程序对象中定义的”基本操作的拦截器”, 每个处理程序对象可以包含零个或多个捕获器, 每个捕获器都对应一种基本操作, 可以直接或间接在代理对象上调用, 每次在代理对象上调用这些基本操作时, 代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"get"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.name; <span class="comment">// get</span></span><br></pre></td></tr></table></figure><h4 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h4><p>所有捕获器都可以访问相应的参数, 基于这些参数可以重建被捕获方法的原始行为, 下面的例子可以看出有三个参数,  第一个参数是<code>targetObject</code>, 第二个参数是访问的属性名<code>property</code>, 第三个参数是代理对象<code>proxy</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="comment">/*get(...rest) &#123;</span></span><br><span class="line"><span class="comment">        // console.log(rest);</span></span><br><span class="line"><span class="comment">        console.log(rest[0] === target); // true</span></span><br><span class="line"><span class="comment">        console.log(rest[2] === proxy); // true</span></span><br><span class="line"><span class="comment">        console.log("get");</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">get</span>(targetObj, property, receiver) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetObj[property]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.name; <span class="comment">// "decade"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(3) [&#123;…&#125;, "name", Proxy]</span></span><br><span class="line"><span class="comment">0: &#123;name: "decade"&#125;</span></span><br><span class="line"><span class="comment">1: "name"</span></span><br><span class="line"><span class="comment">2: Proxy &#123;name: "decade"&#125;</span></span><br><span class="line"><span class="comment">length: 3</span></span><br><span class="line"><span class="comment">__proto__: Array(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所有捕获器都可以基于自己的参数重建原始操作, 但并非所有捕获器行为都像 get()那么简单, 因此, 通过手动写码如法炮制的想法是不现实的, 实际上, 开发者并不需要手动重建原始行为, 而是可以通过调用全局 <code>Reflect</code> 对象上(封装了原始行为)的同名方法来轻松重建, 处理程序对象中所有可以捕获的方法都有对应的反射<code>Reflect API</code> 方法, 这些方法与捕获器拦截的方法具有相同的名称和函数签名, 而且也具有与被拦截方法相同的行为, 因此, 使用反射 API 也可以像下面这样定义出空代理对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样也可以</span></span><br><span class="line"><span class="keyword">const</span> handler1 = &#123;</span><br><span class="line">    <span class="keyword">get</span>: Reflect.<span class="keyword">get</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h4><p>使用捕获器几乎可以改变所有基本方法的行为, 但也不是没有限制, 根据 ECMAScript 规范, 每个捕获的方法都知道目标对象上下文、捕获函数签名, 而捕获处理程序的行为必须遵循”捕获器不变式”(trap invariant), 捕获器不变式因方法不同而异, 但通常都会防止捕获器定义出现过于反常的行为</p><p>如果目标对象有一个不可配置且不可写的数据属性, 那么在捕获器返回一个与该属性不同的值时, 会抛出 TypeError</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"decade"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"zio"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.name; <span class="comment">// Uncaught TypeError: 'get' on proxy: property 'name' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected 'decade' but got 'zio') at &lt;anonymous&gt;:13:7</span></span><br></pre></td></tr></table></figure><h4 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h4><p>有时候可能需要中断代理对象与目标对象之间的联系, 对于使用 new Proxy()创建的普通代理来说, 这种联系会在代理对象的生命周期内一直持续存在, Proxy 本身也暴露出<code>revocable</code> 的方法, 这个方法支持撤销代理对象与目标对象的关联, 撤销代理的操作是不可逆的, 而且, 撤销函数<code>revoke()</code>是幂等的, 调用多少次的结果都一样, 撤销代理之后再调用代理会抛出 TypeError</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(targetObj, property, receiver) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(targetObj, property, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.name; <span class="comment">// "decade"</span></span><br><span class="line">revoke();</span><br><span class="line">proxy.name; <span class="comment">// Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure><h4 id="实用反射-API"><a href="#实用反射-API" class="headerlink" title="实用反射 API"></a>实用反射 API</h4><p>某些情况下应该优先使用反射 API, 这是有一些理由的</p><h5 id="反射-API-与对象-API"><a href="#反射-API-与对象-API" class="headerlink" title="反射 API 与对象 API"></a>反射 API 与对象 API</h5><ol><li>反射 API 并不限于捕获处理程序</li><li>大多数反射 API 方法在 Object 类型上有对应的方法</li></ol><p>通常, Object 上的方法适用于通用程序, 而反射方法适用于细粒度的对象控制与操作</p><h5 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h5><p>很多反射方法返回称作”状态标记”的布尔值, 表示意图执行的操作是否成功, 有时候, 状态标记\比那些返回修改后的对象或者抛出错误(取决于方法)的反射 API 方法更有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(o, <span class="string">'foo'</span>, <span class="string">'bar'</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'failure'</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反射API</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(o, <span class="string">'foo'</span>, &#123;<span class="attr">value</span>: <span class="string">'bar'</span>&#125;)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success'</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'failure'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下反射方法都会提供状态标记</p><ul><li>Reflect.defineProperty()</li><li>Reflect.preventExtensions()</li><li>Reflect.setPrototypeOf()</li><li>Reflect.set()</li><li>Reflect.deleteProperty()</li></ul><h5 id="用一等函数替代操作符"><a href="#用一等函数替代操作符" class="headerlink" title="用一等函数替代操作符"></a>用一等函数替代操作符</h5><ul><li>Reflect.get(): 可以替代对象属性访问操作符</li><li>Reflect.set(): 可以替代<code>=</code>赋值操作符</li><li>Reflect.has(): 可以替代 <code>in</code> 操作符或 <code>with()</code></li><li>Reflect.deleteProperty(): 可以替代 <code>delete</code> 操作符</li><li>Reflect.construct(): 可以替代 <code>new</code>操作符</li></ul><h5 id="安全地应用函数"><a href="#安全地应用函数" class="headerlink" title="安全地应用函数"></a>安全地应用函数</h5><p>在通过 apply 方法调用函数时, 被调用的函数可能也定义了自己的 apply 属性(虽然可能性极小), 为绕过这个问题, 可以使用定义在 Function 原型上的 apply 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply.call(myFunc, thisVal, argumentList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种可怕的代码完全可以使用 Reflect.apply 来避免</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(myFunc, thisVal, argumentsList);</span><br></pre></td></tr></table></figure><h5 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h5><p>代理可以拦截反射 API 的操作, 而这意味着完全可以创建一个代理, 通过它去代理另一个代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler1 = &#123;</span><br><span class="line">    <span class="keyword">get</span>(o, k, r) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"first"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(o, k, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler2 = &#123;</span><br><span class="line">    <span class="keyword">get</span>(o, k, r) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"second"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(o, k, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler1);</span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(firstProxy, handler2);</span><br><span class="line">secondProxy.name; <span class="comment">// second first "decade"</span></span><br></pre></td></tr></table></figure><h5 id="代理的问题与不足"><a href="#代理的问题与不足" class="headerlink" title="代理的问题与不足"></a>代理的问题与不足</h5><p>代理是在 ECMAScript 现有基础之上构建起来的一套新 API, 因此其实现已经尽力做到最好了, 很大程度上, 代理作为对象的虚拟层可以正常使用</p><ol><li><p>代理中的this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> === proxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line">proxy.say(); <span class="comment">// true</span></span><br><span class="line">target.say(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果目标对象依赖于对象标识, 那就可能碰到意料之外的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">        wm.set(<span class="keyword">this</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> id(id) &#123;</span><br><span class="line">        wm.set(<span class="keyword">this</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> id() &#123;</span><br><span class="line">        <span class="keyword">return</span> wm.get(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="string">"decade"</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;&#125;);</span><br><span class="line">proxy.id; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>要解决这个问题, 就需要重新配置代理, 把代理 <code>User</code> 实例改为代理 <code>User</code> 类本身, 之后再创建代理的实例就会以代理实例作为 WeakMap 的键了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxyUser = <span class="keyword">new</span> <span class="built_in">Proxy</span>(User, &#123;&#125;);</span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> proxyUser(<span class="string">"decade"</span>);</span><br><span class="line">user1.id; <span class="comment">// decade</span></span><br></pre></td></tr></table></figure></li><li><p>代理与内部槽位</p><p>有些 ECMAScript 内置类型可能会依赖代理无法控制的机制, 结果导致在代理上调用某些方法会出错, <code>Date</code>类型方法的执行依赖 this 值上的内部槽位<code>[[NumberDate]]</code>,代理对象上不存在这个内部槽位, 而且这个内部槽位的值也不能通过普通的 <code>get()</code>和<code>set()</code>操作访问到, 于是代理拦截后本应转发给目标对象的方法会抛出 TypeError</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(date, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">proxy <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">// true</span></span><br><span class="line">proxy.getDate(); <span class="comment">// Uncaught TypeError: this is not a Date object</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="代理捕获器与反射方法"><a href="#代理捕获器与反射方法" class="headerlink" title="代理捕获器与反射方法"></a>代理捕获器与反射方法</h3><p>代理可以捕获 13 种不同的基本操作, 这些操作有各自不同的反射 API 方法、参数、关联 ECMAScript操作和不变式</p><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p><code>get()</code>捕获器会在获取属性值的操作中被调用, 对应的反射 API 方法为 <code>Reflect.get()</code></p><ol><li><p>返回值 </p><p>返回值无限制</p></li><li><p>拦截的操作</p><ul><li>proxy.property</li><li>proxy[property]</li><li>Object.create(proxy)[property]</li><li>Reflect.get(proxy, property, receiver)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li><li>property: 引用的目标对象上的字符串键属性</li><li>receiver: 代理对象或继承代理对象的对象</li></ul></li><li><p>捕获器不变式</p><ul><li>如果 <code>target.property</code> 不可写且不可配置, 则处理程序返回的值必须与 <code>target.property</code> 匹配</li><li>如果 <code>target.property</code>不可配置且<code>[[Get]]</code>特性为<code>undefined</code>, 处理程序的返回值也必须是 <code>undefined</code></li></ul></li></ol><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p>set()捕获器会在设置属性值的操作中被调用, 对应的反射 API 方法为 <code>Reflect.set()</code></p><ol><li><p>返回值</p><p>返回 true 表示成功, 返回 false 表示失败, 严格模式下会抛出 TypeError</p></li><li><p>拦截的操作</p><ul><li>proxy.property = value</li><li>proxy[property] = value</li><li>Object.create(proxy)[property] = value</li><li>Reflect.set(proxy, property, value, receiver)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li><li>property: 引用的目标对象上的字符串键属性</li><li>value: 要赋给属性的值</li><li>receiver: 接收最初赋值的对象</li></ul></li><li><p>捕获器不变式</p><ul><li>如果 <code>target.property</code>不可写且不可配置, 则不能修改目标属性的值</li><li>如果 <code>target.property</code> 不可配置且<code>[[Set]]</code>特性为 <code>undefined</code>, 则不能修改目标属性的值</li><li>在严格模式下, 处理程序中返回 <code>false</code> 会抛出 TypeError</li></ul></li></ol><h4 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h4><p>has()捕获器会在 in 操作符中被调用, 对应的反射 API 方法为 <code>Reflect.has()</code></p><ol><li><p>返回值</p><p>has()必须返回布尔值, 表示属性是否存在, 返回非布尔值会被转型为布尔值</p></li><li><p>拦截的操作</p><ul><li>property in proxy</li><li>property in Object.create(proxy)</li><li>with(proxy) { (property) }</li><li>Reflect.has(proxy, property)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li><li>property: 引用的目标对象上的字符串键属性</li></ul></li><li><p>捕获器不变式</p><ul><li>如果 <code>target.property</code> 存在且不可配置, 则处理程序必须返回 true</li><li>如果 <code>target.property</code> 存在且目标对象不可扩展, 则处理程序必须返回 true</li></ul></li></ol><h4 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h4><p>defineProperty()捕获器会在 Object.defineProperty()中被调用, 对应的反射 API 方法为<code>Reflect.defineProperty()</code></p><ol><li><p>返回值</p><p>defineProperty()必须返回布尔值, 表示属性是否成功定义, 返回非布尔值会被转型为布尔值</p></li><li><p>拦截的操作</p><ul><li>Object.defineProperty(proxy, property, descriptor)</li><li>Reflect.defineProperty(proxy, property, descriptor)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li><li>property: 引用的目标对象上的字符串键属性</li><li>descriptor: 包含enumerable, configurable, writable, value, get, set的对象</li></ul></li><li><p>捕获器不变式</p><ul><li>如果目标对象不可扩展, 则无法定义属性</li><li>如果目标对象有一个可配置的属性, 则不能添加同名的不可配置属性</li><li>如果目标对象有一个不可配置的属性, 则不能添加同名的可配置属性</li></ul></li></ol><h4 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h4><p>getOwnPropertyDescriptor()捕获器会在 Object.getOwnPropertyDescriptor()中被调用, 对应的反射 API 方法为 <code>Reflect.getOwnPropertyDescriptor()</code></p><ol><li><p>返回值</p><p>getOwnPropertyDescriptor()必须返回对象 , 或者在属性不存在时返回 undefined</p></li><li><p>拦截的操作</p><ul><li>Object.getOwnPropertyDescriptor(proxy, property)</li><li>Reflect.getOwnPropertyDescriptor(proxy, property)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li><li>property: 引用的目标对象上的字符串键属性</li></ul></li><li><p>捕获器不变式</p><ul><li>如果自有的 <code>target.property</code> 存在且不可配置, 则处理程序必须返回一个表示该属性存在的对象</li><li>如果自有的 <code>target.property</code> 存在且可配置, 则处理程序必须返回表示该属性可配置的对象</li><li>如果自有的 <code>target.property</code> 存在且 target 不可扩展, 则处理程序必须返回一个表示该属性存在的对象</li><li>如果 <code>target.property</code> 不存在且 target 不可扩展, 则处理程序必须返回 undefined 表示该属性不存在</li><li>如果 1target.property` 不存在, 则处理程序不能返回表示该属性可配置的对象</li></ul></li></ol><h4 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h4><p>deleteProperty()捕获器会在 delete 操作符中被调用, 对应的反射 API 方法为 <code>Reflect. deleteProperty()</code></p><ol><li><p>返回值</p><p>deleteProperty()必须返回布尔值, 表示删除属性是否成功, 返回非布尔值会被转型为布尔值</p></li><li><p>拦截的操作</p><ul><li>delete proxy.property</li><li>delete proxy[property]</li><li>Reflect.deleteProperty(proxy, property)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li><li>property: 引用的目标对象上的字符串键属性</li></ul></li><li><p>捕获器不变式</p><ul><li>如果自有的 <code>target.property</code> 存在且不可配置, 则处理程序不能删除这个属性</li></ul></li></ol><h4 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h4><p>ownKeys()捕获器会在 Object.keys()及类似方法中被调用, 对应的反射 API 方法为 <code>Reflect. ownKeys()</code></p><ol><li><p>返回值</p><p>ownKeys()必须返回包含字符串或符号的可枚举对象</p></li><li><p>拦截的操作</p><ul><li>Object.getOwnPropertyNames(proxy)</li><li>Object.getOwnPropertySymbols(proxy)</li><li>Object.keys(proxy)</li><li>Reflect.ownKeys(proxy)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li></ul></li><li><p>捕获器不变式</p><ul><li>返回的可枚举对象必须包含 target 的所有不可配置的自有属性,</li><li>如果 target 不可扩展, 则返回可枚举对象必须准确地包含自有属性键</li></ul></li></ol><h4 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h4><p>getPrototypeOf()捕获器会在 Object.getPrototypeOf()中被调用, 对应的反射 API 方法为<code>Reflect.getPrototypeOf()</code></p><ol><li><p>返回值</p><p>getPrototypeOf()必须返回对象或 null</p></li><li><p>拦截的操作</p><ul><li>Object.getPrototypeOf(proxy)</li><li>Reflect.getPrototypeOf(proxy</li><li><code>proxy. __proto__</code></li><li>Object.prototype.isPrototypeOf(proxy)</li><li>proxy instanceof Object</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li></ul></li><li><p>捕获器不变式</p><ul><li>如果 target 不可扩展, 则 Object.getPrototypeOf(proxy)唯一有效的返回值就是 <code>Object. getPrototypeOf(target)</code>的返回值</li></ul></li></ol><h4 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h4><p>setPrototypeOf()捕获器会在 Object.setPrototypeOf()中被调用, 对应的反射 API 方法为<code>Reflect.setPrototypeOf()</code></p><ol><li><p>返回值</p><p>setPrototypeOf()必须返回布尔值, 表示原型赋值是否成功, 返回非布尔值会被转型为布尔值</p></li><li><p>拦截的操作</p><ul><li>Object.setPrototypeOf(proxy)</li><li>Reflect.setPrototypeOf(proxy)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li><li>prototype: target 的替代原型, 如果是顶级原型则为 null</li></ul></li><li><p>捕获器不变式</p><ul><li>如果 target 不可扩展, 则唯一有效的 prototype 参数就是 Object.getPrototypeOf(target)的返回值</li></ul></li></ol><h4 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h4><p>isExtensible()捕获器会在 Object.isExtensible()中被调用, 对应的反射 API 方法为<code>Reflect.isExtensible()</code></p><ol><li><p>返回值</p><p>isExtensible()必须返回布尔值, 表示 target 是否可扩展, 返回非布尔值会被转型为布尔值</p></li><li><p>拦截的操作</p><ul><li>Object.isExtensible(proxy)</li><li>Reflect.isExtensible(proxy)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li></ul></li><li><p>捕获器不变式</p><ul><li>如果 target 可扩展, 则处理程序必须返回 true</li><li>如果 target 不可扩展, 则处理程序必须返回 false</li></ul></li></ol><h4 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h4><p>preventExtensions()捕获器会在 Object.preventExtensions()中被调用. 对应的反射 API方法为 <code>Reflect.preventExtensions()</code></p><ol><li><p>返回值</p><p>preventExtensions()必须返回布尔值，表示 target 是否已经不可扩展, 返回非布尔值会被转型为布尔值</p></li><li><p>拦截的操作</p><ul><li>Object.preventExtensions(proxy)</li><li>Reflect.preventExtensions(proxy)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li></ul></li><li><p>捕获器不变式</p><ul><li>如果 Object.isExtensible(proxy)是 false, 则处理程序必须返回 true</li></ul></li></ol><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>apply()捕获器会在调用函数时中被调用, 对应的反射 API 方法为 <code>Reflect.apply()</code></p><ol><li><p>返回值</p><p>返回值无限制</p></li><li><p>拦截的操作</p><ul><li>proxy(…argumentsList)</li><li>Function.prototype.apply(thisArg, argumentsList)</li><li>Function.prototype.call(thisArg, …argumentsList)</li><li>Reflect.apply(target, thisArgument, argumentsList)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标对象</li><li>thisArg: 调用函数时的 this 参数</li><li>argumentsList: 调用函数时的参数列表</li></ul></li><li><p>捕获器不变式</p><ul><li>target 必须是一个函数对象</li></ul></li></ol><h4 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h4><p>construct()捕获器会在 new 操作符中被调用, 对应的反射 API 方法为 <code>Reflect.construct()</code></p><ol><li><p>返回值</p><p>construct()必须返回一个对象</p></li><li><p>拦截的操作</p><ul><li>new proxy(…argumentsList)</li><li>Reflect.construct(target, argumentsList, newTarget)</li></ul></li><li><p>捕获器处理程序参数</p><ul><li>target: 目标构造函数</li><li>argumentsList: 传给目标构造函数的参数列表</li><li>newTarget: 最初被调用的构造函数</li></ul></li><li><p>捕获器不变式</p><ul><li>target 必须可以用作构造函数</li></ul></li></ol><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h4 id="跟踪属性访问"><a href="#跟踪属性访问" class="headerlink" title="跟踪属性访问"></a>跟踪属性访问</h4><p>通过捕获 get、set 和 has 等操作, 可以知道对象属性什么时候被访问、被查询, 把实现相应捕获器的某个对象代理放到应用中, 可以监控这个对象何时在何处被访问过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(o, k, r) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;k&#125;</span>被访问`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(o, k, r);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(o, k, v, r) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;k&#125;</span>被修改, 新值为<span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(o, k, v, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.name; <span class="comment">// name被访问 "decade"</span></span><br><span class="line">proxy.age = <span class="number">21</span>; <span class="comment">// age被修改, 新值为21</span></span><br></pre></td></tr></table></figure><h4 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h4><p>代理的内部实现对外部代码是不可见的, 因此要隐藏目标对象上的属性也轻而易举</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">"name"</span>, <span class="string">"age"</span>];</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    like: <span class="string">"code"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(o, k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiddenProperties.includes(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(o, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    has(o, k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiddenProperties.includes(k)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(o, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.name; <span class="comment">// undefined</span></span><br><span class="line">proxy.age; <span class="comment">// undefined</span></span><br><span class="line">proxy.like; <span class="comment">// "code"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> proxy; <span class="comment">// false</span></span><br><span class="line"><span class="string">"age"</span> <span class="keyword">in</span> proxy; <span class="comment">// false</span></span><br><span class="line"><span class="string">"like"</span> <span class="keyword">in</span> proxy; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h4><p>因为所有赋值操作都会触发 set()捕获器, 所以可以根据所赋的值决定是允许还是拒绝赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">set</span>(o, k, v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> v !== <span class="string">"number"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(o, k, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.age = <span class="string">"200"</span>;</span><br><span class="line">proxy.age; <span class="comment">// 20</span></span><br><span class="line">proxy.age = <span class="number">21</span>;</span><br><span class="line">proxy.age; <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><h4 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h4><p>跟保护和验证对象属性类似, 也可对函数和构造函数参数进行审查</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">medium</span>(<span class="params">...nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums.sort()[<span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(medium, &#123;</span><br><span class="line">    apply(target, thisArg, argumentsList) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) &#123; </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'number'</span>) &#123; </span><br><span class="line">                <span class="keyword">throw</span> <span class="string">'Non-number argument provided'</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy(<span class="number">4</span>, <span class="string">"5"</span>, <span class="number">6</span>); <span class="comment">// Uncaught Non-number argument provided</span></span><br></pre></td></tr></table></figure><p>类似地，可以要求实例化时必须给构造函数传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</span><br><span class="line">    construct(target, argumentsList, newTarget) &#123; </span><br><span class="line">        <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="string">'Person cannot be instantiated without name'</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(...arguments); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> proxy(); <span class="comment">// VM101:10 Uncaught Person cannot be instantiated without name</span></span><br></pre></td></tr></table></figure><h4 id="数据绑定与可观察对象"><a href="#数据绑定与可观察对象" class="headerlink" title="数据绑定与可观察对象"></a>数据绑定与可观察对象</h4><p>通过代理可以把运行时中原本不相关的部分联系到一起</p><p>可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personList = [];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    (person <span class="keyword">instanceof</span> Person) &amp;&amp; (<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> 添加了`</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> listProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(personList, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, property, value, receiver) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, property, value, receiver);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            emit(<span class="built_in">Reflect</span>.get(target, property, receiver));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</span><br><span class="line">    construct(target, argumentsList, newTarget) &#123;</span><br><span class="line">        <span class="keyword">const</span> newPerson = <span class="built_in">Reflect</span>.construct(target, argumentsList, newTarget);</span><br><span class="line">        listProxy.push(newPerson);</span><br><span class="line">        <span class="keyword">return</span> newPerson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> proxy(<span class="string">'decade'</span>); <span class="comment">// VM393:8 decade 添加了</span></span><br><span class="line"><span class="keyword">new</span> proxy(<span class="string">'zio'</span>); <span class="comment">// VM393:8 zio 添加了</span></span><br><span class="line"><span class="keyword">new</span> proxy(<span class="string">'ooo'</span>); <span class="comment">// VM393:8 ooo 添加了</span></span><br><span class="line">personList;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(3) [Person, Person, Person]</span></span><br><span class="line"><span class="comment">0: Person &#123;name: "decade"&#125;</span></span><br><span class="line"><span class="comment">1: Person &#123;name: "zio"&#125;</span></span><br><span class="line"><span class="comment">2: Person &#123;name: "ooo"&#125;</span></span><br><span class="line"><span class="comment">length: 3</span></span><br><span class="line"><span class="comment">__proto__: Array(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版-第八章-笔记</title>
    <link href="http://blog.decade.run/2021/01/27/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2021/01/27/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-27T08:21:53.000Z</published>
    <updated>2021-02-05T02:49:53.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">"decade"</span>;</span><br><span class="line">obj.age = <span class="number">20</span>;</span><br><span class="line">obj.job = <span class="string">"coder"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: "decade", age: 20, job: "coder"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    job: <span class="string">"coder"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;name: "decade", age: 20, job: "coder"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h4><ol><li><p>数据属性</p><ul><li>[[Configurable]]: 表示属性是否可以通过 delete 删除并重新定义, 是否可以修改它的特性, 以及是否可以把它改为访问器属性,  直接定义在对象里面的属性默认为<code>true</code> </li><li>[[Enumerable]]: 表示属性是否可以通过 for-in 循环返回, 直接定义在对象里面的属性默认为 <code>true</code> </li><li>[[Writable]]: 表示属性的值是否可以被修改, 直接定义在对象里面的属性默认为 <code>true</code> </li><li>[[Value]]: 包含属性实际的值, 默认为 <code>undefined</code> </li></ul><p>修改属性的默认值, 需要用<code>Object.defineProperty(target, key, propertyObj)</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">"dddd decade"</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;; <span class="comment">// &#123;name: "dddd decade",  age: 20&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"name"</span>, &#123;</span><br><span class="line">    value: <span class="string">"DDDD DECADE"</span> <span class="comment">// 修改原来的值</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: "DDDD DECADE", age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span> <span class="comment">// 不允许修改 name对应的值</span></span><br><span class="line">&#125;);</span><br><span class="line">obj.name = <span class="string">"dddd decade"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: "DDDD DECADE", age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// name age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"name"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span> <span class="comment">// 不允许 name  使用for-in</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name; <span class="comment">// true</span></span><br><span class="line">obj = &#123; ...obj, <span class="attr">name</span>: <span class="string">'decade'</span> &#125;; <span class="comment">// &#123;age: 20, name: "decade"&#125;</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="number">1</span>; <span class="comment">// &#123;age: 20, name: 1&#125;</span></span><br><span class="line"><span class="comment">// 说明新添加的这个name [[Writable]] 为 true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// name age</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明新添加的这个name [[Enumerable]] 为 true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>, <span class="comment">// 不允许删除</span></span><br><span class="line">    writable: <span class="literal">false</span>, <span class="comment">// 不允许修改 name对应的值</span></span><br><span class="line">    enumerable: <span class="literal">false</span>, <span class="comment">// 不允许 name  使用for-in</span></span><br><span class="line">    value: <span class="string">"decade"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> obj.name; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们只给 age属性的 configurable 设置为false</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>, <span class="comment">// 不允许删除</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值得一提的是 这里的不可修改别的配置 是在你配置过一次配置 后 就不能修改了 如下 (下面的情况仅仅是 之前只配置了configurable: false)</span></span><br><span class="line"><span class="comment">// 第一次配置 只配置了writable 为false 别的enumerable为默认配置为true value为当前的值 是不会报错的</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> Uncaught TypeError: Cannot redefine property: age</span></span><br><span class="line"><span class="comment"> at Function.defineProperty (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">at &lt;anonymous&gt;:1:8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> Uncaught TypeError: Cannot redefine property: age</span></span><br><span class="line"><span class="comment"> at Function.defineProperty (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">at &lt;anonymous&gt;:1:8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"age"</span>, &#123;</span><br><span class="line">   value: <span class="number">22</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>访问器属性</p><ul><li>[[Configurable]]: 表示属性是否可以通过 delete 删除并重新定义, 是否可以修改它的特性, 以及是否可以把它改为数据属性, 直接定义在对象里面的属性默认为 <code>true</code></li><li>[[Enumerable]]: 表示属性是否可以通过 for-in 循环返回, 直接定义在对象里面的属性默认为 <code>true</code></li><li>[[Get]]: 获取函数, 在读取属性的时候调用, 默认 <code>undefined</code></li><li>[[Set]]: 设置函数, 在写入属性的时候调用, 默认 <code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    _name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"name"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(nv) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"name changed"</span>)</span><br><span class="line">        <span class="keyword">this</span>._name = nv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.name; <span class="comment">// decade</span></span><br><span class="line">obj.name = <span class="string">"ddd decade"</span>; <span class="comment">// name changed</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p><code>Object.defineProperties(target, propertiesObj)</code> 方法可以为一个对象定义多个属性,  该方法同时定义的所有的数据属性, <code>configurable, enumerable, writable</code> 默认都是 <code>false</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    _name: &#123;</span><br><span class="line">        value: <span class="string">"decade"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    name: &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(nv) &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">"name changed"</span>)</span><br><span class="line">        <span class="keyword">this</span>._name = nv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;_name: "decade", age: 20&#125;</span></span><br><span class="line">obj.name; <span class="comment">// decade</span></span><br><span class="line">obj.name = <span class="string">"dddd decade"</span>; <span class="comment">// name changed</span></span><br><span class="line">obj.age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改不了</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;_name: "decade", age: 20&#125;</span></span><br><span class="line"><span class="comment">// 打印不出来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能修改</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"_name"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Uncaught TypeError: Cannot redefine property: _name</span></span><br><span class="line"><span class="comment">    at Function.defineProperty (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:1:8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p><code>Object.getOwnPropertyDescriptor(target, key)</code> 获取指定属性的属性描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    _name: &#123;</span><br><span class="line">        value: <span class="string">"decade"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    name: &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(nv) &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">"name changed"</span>)</span><br><span class="line">        <span class="keyword">this</span>._name = nv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dataDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">"_name"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dataDescriptor); <span class="comment">// &#123;value: "decade", writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"><span class="keyword">const</span> propertyDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">"name"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor); <span class="comment">// &#123;enumerable: false, configurable: false, get: ƒ, set: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors(target)</code> 获取 <code>target</code> 上每个自有属性的 属性描述符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">like</span>: <span class="string">"coding"</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    _name: &#123;</span><br><span class="line">        value: <span class="string">"decade"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    name: &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(nv) &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">"name changed"</span>)</span><br><span class="line">        <span class="keyword">this</span>._name = nv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> descriptors = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"><span class="built_in">console</span>.log(descriptors);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;like: &#123;…&#125;, _name: &#123;…&#125;, age: &#123;…&#125;, name: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">age: &#123;value: 20, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"><span class="comment">like: &#123;value: "coding", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">name: &#123;enumerable: false, configurable: false, get: ƒ, set: ƒ&#125;</span></span><br><span class="line"><span class="comment">_name: &#123;value: "decade", writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h4><p><code>Object.assign()</code> 用于两个对象或者多个对象的合并(混入)  返回修改后的 <code>target</code> 对象</p><ul><li>源对象的可枚举(Object.propertyIsEnumerable()返回 true)属性</li><li>源对象的自有(Object.hasOwnProperty()返回 true)属性</li><li>以字符串和符号为键的属性</li></ul><p>使用源对象上的<code>[[Get]]</code>取得属性的值, 然后使用目标对象上的<code>[[Set]]</code>设置属性的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj === <span class="built_in">Object</span>.assign(obj, &#123;<span class="attr">name</span>: <span class="string">"decade"</span>&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: "decade"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"decade"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型上的 parentName属性</span></span><br><span class="line">CreateObj.prototype.parentName = <span class="string">"father"</span>;</span><br><span class="line"><span class="keyword">let</span> sourceObj = <span class="keyword">new</span> CreateObj();</span><br><span class="line"><span class="keyword">let</span> sourceObj1 = &#123;&#125;;</span><br><span class="line"><span class="comment">// enumerable 为false</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(sourceObj1, <span class="string">"name"</span>, &#123;</span><br><span class="line">    enumerable 为<span class="literal">false</span>: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"unEnumerable"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(sourceObj1, <span class="string">"like"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">"coding"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(sourceObj1, <span class="string">"age"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="number">22</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面的source 中属性名相同 以最后出现的为主</span></span><br><span class="line"><span class="keyword">let</span> targetObj = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.assign(targetObj, sourceObj, sourceObj1); <span class="comment">// &#123;name: "decade", age: 22, like: "coding"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果source中里面也有对象, 合并也是浅复制</span></span><br><span class="line"><span class="keyword">let</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123; <span class="attr">a</span>: &#123; <span class="attr">name</span>: <span class="string">"dddd"</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target1, source2);</span><br><span class="line">target1.a === source2.a; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h4><p>在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符合预期的</span></span><br><span class="line"><span class="literal">true</span> === <span class="number">1</span>; <span class="comment">// false</span></span><br><span class="line">(&#123;&#125; === &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="string">"2"</span> === <span class="number">2</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等</span></span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span>; <span class="comment">// true</span></span><br><span class="line">+<span class="number">0</span> === <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">-0</span> === <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN()</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>为改善这类情况, ECMAScript 6 规范新增了<code>Object.is()</code> 这个方法与 <code>===</code> 很像, 但同时也考虑到了上述边界情形</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">true</span>, <span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="string">"2"</span>, <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h4><h5 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h5><p>属性名只要使用变量名(不用再写冒号)就会自动被解释为同名的属性键, 如果没有找到同名变量, 则会抛出 ReferenceError</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">"decade"</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "decade"&#125;</span></span><br></pre></td></tr></table></figure><h5 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h5><p>可计算属性表达式中抛出任何错误都会中断对象创建, 如果计算属性的表达式有副作用, 那就要小心了, 因为如果表达式抛出错误,那么之前完成的计算是不能回滚的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">"dddd"</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="number">123</span> + <span class="string">"name"</span>]: <span class="string">"key为123name"</span>,</span><br><span class="line">    [key + <span class="string">"decade"</span>]: <span class="string">"key为dddddecade"</span></span><br><span class="line">&#125;; <span class="comment">// &#123;123name: "key为123name", dddddecade: "key为dddddecade"&#125;</span></span><br></pre></td></tr></table></figure><h5 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h5><p>在给对象定义方法时, 通常都要写一个方法名、冒号, 然后再引用一个匿名函数表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写前</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写后</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    sayName(name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算属性简写</span></span><br><span class="line"><span class="keyword">const</span> funcKey = <span class="string">"Name"</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    [say + funcKey](name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用</span></span><br><span class="line"><span class="keyword">const</span> name = obj.name,</span><br><span class="line">      age = obj.age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = obj;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: objName, <span class="attr">age</span>: objAge &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, objName); <span class="comment">// "decade" ,"decade"</span></span><br><span class="line"><span class="built_in">console</span>.log(age, objAge); <span class="comment">// 20, 20</span></span><br></pre></td></tr></table></figure><p>解构在内部使用函数 <code>ToObject()(不能在运行时环境中直接访问)</code>把源数据结构转换为对象, 这意味着在对象解构的上下文中, 原始值会被当成对象, 这也意味着(根据 ToObject()的定义), <code>null</code>和 <code>undefined</code> 不能被解构</p><h5 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    job: &#123;</span><br><span class="line">        title: <span class="string">"Front-end development engineer"</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> name, age, title;</span><br><span class="line">(&#123; name, age,  <span class="attr">job</span>: &#123; title &#125; &#125; = obj);</span><br><span class="line"><span class="built_in">console</span>.log(name, age, title); <span class="comment">// "decade", 20, "Front-end development engineer"</span></span><br></pre></td></tr></table></figure><h5 id="部分解构"><a href="#部分解构" class="headerlink" title="部分解构"></a>部分解构</h5><p>需要注意的是, 涉及多个属性的解构赋值是一个输出无关的顺序化操作, 如果一个解构表达式涉及多个赋值, 开始的赋值成功而后面的赋值出错, 则整个解构赋值只会完成一部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name, title, age;</span><br><span class="line">(&#123; name, <span class="attr">job</span>: &#123; title &#125;, age &#125; = obj);</span><br><span class="line"><span class="comment">// VM163:7 Uncaught TypeError: Cannot read property 'title' of undefined at &lt;anonymous&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, title, age); <span class="comment">// "decade" undefined undefined</span></span><br></pre></td></tr></table></figure><h5 id="参数上下文匹配"><a href="#参数上下文匹配" class="headerlink" title="参数上下文匹配"></a>参数上下文匹配</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">&#123; name, age &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, i am <span class="subst">$&#123;age&#125;</span> years old`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">print(obj); <span class="comment">// my name is decade, i am 20 years old</span></span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>虽然使用 Object 构造函数或对象字面量可以方便地创建对象, 但这些方式也有明显不足: 创建具有同样接口的多个对象需要重复编写很多代码</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ECMAScript 5.1 并没有正式支持面向对象的结构, 比如类或继承, 但是巧妙地运用原型式继承也可以成功地模拟同样的行为</p><p>ECMAScript 6 开始正式支持类和继承, ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模式, 不过, 无论从哪方面看, ES6 的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式是一种众所周知的设计模式, 广泛应用于软件工程领域, 用于抽象创建特定对象的过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = createPerson(<span class="string">"decade"</span>, <span class="number">20</span>, <span class="string">'Front-end development engineer'</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = createPerson(<span class="string">"zio"</span>, <span class="number">21</span>, <span class="string">"Front-end development engineer"</span>);</span><br></pre></td></tr></table></figure><p>这种工厂模式虽然可以解决创建多个类似对象的问题, 但没有解决对象标识问题(即新创建的对象是什么类型)</p><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">"decade"</span>, <span class="number">20</span>, <span class="string">'Front-end development engineer'</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">"zio"</span>, <span class="number">21</span>, <span class="string">'Front-end development engineer'</span>);</span><br></pre></td></tr></table></figure><ul><li>没有显式地创建对象</li><li>属性和方法直接赋值给了 this</li><li>没有 return</li></ul><p>使用 new 操作符, 调用构造函数会执行如下操作</p><ol><li>在内存中创建一个新对象</li><li>这个新对象内部的<code>[[Prototype]]</code>特性被赋值为构造函数的 <code>prototype</code> 属性</li><li>构造函数内部的 this 被赋值为这个新对象</li><li>执行构造函数内部的代码 (给新对象添加属性)</li><li>如果构造函数返回非空对象, 则返回该对象, 否则, 返回刚创建的新对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor === person2.constructor; <span class="comment">// true</span></span><br><span class="line">person1.constructor === Person; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">person1 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h5><p>构造函数与普通函数唯一的区别就是调用方式不同, 除此之外, 构造函数也是函数, 并没有把某个函数定义为构造函数的特殊语法, 任何函数只要使用 <code>new</code>操作符调用就是构造函数 , 而不使用 <code>new</code> 操作符调用的函数就是普通函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">"decade"</span>, <span class="number">20</span>); </span><br><span class="line">Person(<span class="string">"zio"</span>, <span class="number">21</span>); <span class="comment">// 里面this指向window</span></span><br></pre></td></tr></table></figure><p>在调用一个函数而没有明确设置 this 值的情况下<code>(即没有作为对象的方法调用, 或者没有使用 call()/apply()调用)</code>, <code>this</code> 始终指向 <code>Global</code>对象<code>(在浏览器中就是 window 对象)</code></p><h5 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h5><p>构造函数虽然有用, 但也不是没有问题, 构造函数的主要问题在于, 其定义的方法会在每个实例上都创建一遍</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">"decade"</span>, <span class="number">20</span>); </span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">"zio"</span>, <span class="number">21</span>); </span><br><span class="line">person1.sayName === person2.sayName; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>所以完全可以单独提出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">"decade"</span>, <span class="number">20</span>); </span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">"zio"</span>, <span class="number">21</span>); </span><br><span class="line">person1.sayName === person2.sayName; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>不过这样解决也导致了 <code>sayName</code>方法 挂在全局作用域上, 导致可能会有命名冲突</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>每个函数都会创建一个 <code>prototype</code> 属性, 这个属性是一个对象, 包含应该由特定引用类型的实例共享的属性和方法, 在它上面定义的属性和方法可以被对象实例共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">"decade"</span>, <span class="number">20</span>); </span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">"zio"</span>, <span class="number">21</span>); </span><br><span class="line">person1.sayName === person2.sayName; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h5><p>无论何时, 只要创建一个函数, 就会按照特定的规则为这个函数创建一个 <code>prototype</code> 属性(指向原型对象), 默认情况下, 所有原型对象自动获得一个名为 <code>constructor</code>  的属性, 指回与之关联的构造函数</p><ol><li>构造函数的实例上的<code>__propt__</code>上的<code>constructor</code> 指向的是该构造函数</li><li>构造函数上面的 <code>prototype</code> 上也有个自己生成的 <code>constructor</code>,  该函数也指向该构造函数</li><li>构造函数上面的 <code>prototype</code> 上也有个自己生成的 <code>constructor</code>也还有个 <code>prototype</code>, 同理上面也有个<code>constructor</code>, 也指向的是该构造函数</li><li>实例上的<code>__proto__</code>就相当于构造函数上的<code>prototype</code> </li><li>构造函数Person 上面也有个<code>__proto__</code>属性, 并指向的是 <code>Object</code> , 我们可以理解为 Person构造函数相当于Object的一个实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">arguments: null</span></span><br><span class="line"><span class="comment">caller: null</span></span><br><span class="line"><span class="comment">length: 0</span></span><br><span class="line"><span class="comment">name: "Person"</span></span><br><span class="line"><span class="comment">prototype:</span></span><br><span class="line"><span class="comment">constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">__proto__: ƒ ()</span></span><br><span class="line"><span class="comment">[[FunctionLocation]]: VM20:1</span></span><br><span class="line"><span class="comment">[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person.__proto__.constructor === Person; <span class="comment">// true</span></span><br><span class="line">person.__proto__.constructor === person.__proto__.constructor.prototype.constructor; <span class="comment">// true</span></span><br><span class="line">person.__proto__.constructor === person.__proto__.constructor.prototype.constructor.prototype.constructor; <span class="comment">// true</span></span><br><span class="line">person.__proto__.__proto__.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">Person.__proto__.constructor.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code> 检查实例的原型链中是否包含指定构造函数的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>isPrototypeOf()</code> 方法会在传入参数的<code>[[Prototype]]</code>指向调用它的对象时返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.isPrototypeOf(person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Object.getPrototypeOf()</code> 返回参数的内部特性<code>[[Prototype]]</code>的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Object.setPrototypeOf()</code> 可以向实例的私有特性<code>[[Prototype]]</code>写入一个新值, <strong>能别用就别用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> changeObj = &#123;</span><br><span class="line">    name: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, changeObj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: </span></span><br><span class="line"><span class="comment">name: 123</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person.__proto__ === changeObj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Object.create()</code> 创建一个对象并为其指明原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: </span></span><br><span class="line"><span class="comment">name: "decade"</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj1) === obj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h5><p>在通过对象访问属性时, 会按照这个属性的名称开始搜索, 搜索开始于对象实例本身, 如果在这个实例上发现了给定的名称, 则返回该名称对应的值, 如果没有找到这个属性, 则搜索会沿着指针进入原型对象, 然后在原型对象上找到属性后, 再返回对应的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype.name = <span class="string">"zio"</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">"decade"</span>;</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// person1上有 停止找 </span></span><br><span class="line">person1.name; <span class="comment">// "decade";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person2 上没有 会往上找</span></span><br><span class="line">person2.name; <span class="comment">// "zio"</span></span><br></pre></td></tr></table></figure><p><code>hasOwnProperty()</code> 判断属性是否在实例属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.hasOwnProperty(<span class="string">"name"</span>); <span class="comment">// true</span></span><br><span class="line">person2.hasOwnProperty(<span class="string">"name"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="原型和in操作符"><a href="#原型和in操作符" class="headerlink" title="原型和in操作符"></a>原型和in操作符</h5><p>有两种方式使用 <code>in</code>操作符: 单独使用和在 for-in 循环中使用,</p><p>在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 <code>true</code>, 无论该属性是在实例上还是在原型上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> person1; <span class="comment">// true 实例上</span></span><br><span class="line"><span class="string">"name"</span> <span class="keyword">in</span> person2; <span class="comment">// true 原型上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototyProperty</span>(<span class="params">obj, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !obj.hasOwnProperty(property) &amp;&amp; (property <span class="keyword">in</span> obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>for-in</code>中使用</p><p>可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person1) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Object.keys()</code> 传入一个对象, 返回该对象所有可枚举属性名称的字符串数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">"decade"</span>; </span><br><span class="line">Person.prototype.age = <span class="number">20</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Front-end development engineer"</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Person.prototype); <span class="comment">// ["name", "age", "job", "sayName"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">"zio"</span>;</span><br><span class="line">person.age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys1 = <span class="built_in">Object</span>.keys(person); <span class="comment">// ["name", "age"]</span></span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyNames()</code> 返回所有自身属性, 无论是否可以枚举</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); <span class="comment">//  ["constructor", "name", "age", "job", "sayName"]</span></span><br></pre></td></tr></table></figure><p>在 ECMAScript 6 新增符号类型之后, <code>Object.getOwnPropertySymbols()</code> 返回<code>Symbol</code>键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">'k1'</span>), </span><br><span class="line">    k2 = <span class="built_in">Symbol</span>(<span class="string">'k2'</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> [k1]: <span class="string">'k1'</span>, </span><br><span class="line"> [k2]: <span class="string">'k2'</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(o); <span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure><h5 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h5><p><code>for-in</code> 循环和 <code>Object.keys()</code>的枚举顺序是不确定的, 取决于 JavaScript 引擎, 可能因浏览器而异</p><p><code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code>和 <code>Object.assign()</code>的枚举顺序是确定性的, 先以升序枚举数值键, 然后以插入顺序枚举字符串和符号键</p><h4 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h4><p><code>Object.values()</code> 接收一个对象, 返回 该对象值得数组, <code>Object.entries()</code> 接收一个对象, 返回该对象 所有键值对的数组, 这两个方法都不会对<code>Symbol</code>键 返回, 不可枚举的也不会被返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(<span class="string">"symbolKey"</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    job: &#123;&#125;,</span><br><span class="line">    [symbolKey]: <span class="string">"symbol"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"like"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"coding"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ["decade", 20, &#123;…&#125;]</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Array(2), Array(2), Array(2)]</span></span><br><span class="line"><span class="comment">0: (2) ["name", "decade"]</span></span><br><span class="line"><span class="comment">1: (2) ["age", 20]</span></span><br><span class="line"><span class="comment">2: (2) ["job", &#123;…&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h5><p>通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法, 这样导致我们不同通过<code>constructor</code>来识别类型, 当然我们可以专门给一个<code>constructor</code>属性 , 不过切记 这样设置的, 会让<code>constructor</code>可枚举</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">age: 20</span></span><br><span class="line"><span class="comment">name: "decade"</span></span><br><span class="line"><span class="comment">sayName: ƒ sayName()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">person.constructor === Person; <span class="comment">// false</span></span><br><span class="line">person.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">   value: Person</span><br><span class="line">&#125;);</span><br><span class="line">person.constructor === Person; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5><p>因为从原型上搜索值的过程是动态的, 所以即使实例在修改原型之前已经存在, 任何时候对原型对象所做的修改也会在实例上反映出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">person;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">sayHi: ƒ ()</span></span><br><span class="line"><span class="comment">constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person.sayHi(); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure><p>实例只有指向原型的指针, 没有指向构造函数的指针, 下面这个例子就是重写了原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123; </span><br><span class="line"> <span class="keyword">constructor</span>: Person, </span><br><span class="line"> sayHi() &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"hi"</span>); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br><span class="line">person.sayHi(); <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// 未修改之前的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(); <span class="comment">// 修改之后的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">sayHi: ƒ ()</span></span><br><span class="line"><span class="comment">constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person1.sayHi(); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure><h5 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h5><p>原型模式之所以重要, 不仅体现在自定义类型上, 而且还因为它也是实现所有原生引用类型的模式, 所有原生引用类型的构造函数(包括 Object、Array、String 等)都在原型上定义了实例方法, 当然我们也可以自己在原型上定义方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort; <span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring; <span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义一个方法</span></span><br><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text) === <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">"Hello world!"</span>; </span><br><span class="line">msg.startsWith(<span class="string">"Hello"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="原型问题"><a href="#原型问题" class="headerlink" title="原型问题"></a>原型问题</h5><p>放在原型上的引用类型数据都是共享的, 所以可能会导致, 一个实例修改后, 另一个实例拿到的是修改之后的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype.names = [<span class="string">"decade"</span>];</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.names.push(<span class="string">"zio"</span>);</span><br><span class="line">person2.names.pop(); <span class="comment">// "zio" 本来person2想输出的是 "decade"的</span></span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>很多面向对象语言都支持两种继承: <code>接口继承</code>和<code>实现继承</code>, 前者只继承方法签名, 后者继承实际的方法, 接口继承在 ECMAScript 中是不可能的，因为函数没有签名, 实现继承是 ECMAScript 唯一支持的继承方式, 而这主要是通过原型链实现的</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>每个构造函数都有一个原型对象<code>prototype</code>, 原型有一个属性<code>constructor</code>指回构造函数, 而实例有一个内部指针<code>__proto__</code>指向原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getParentName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parentName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">constructor: ƒ Child()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 修改 Child的prototype 为 Parnet的实例</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parent &#123;parentName: "parent"&#125;</span></span><br><span class="line"><span class="comment">parentName: "parent"</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">getParentName: ƒ ()</span></span><br><span class="line"><span class="comment">constructor: ƒ Parent()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Child.prototype.getChildName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.childName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Child();</span><br><span class="line">instance.getParentName(); <span class="comment">// "parent"</span></span><br></pre></td></tr></table></figure><h5 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h5><p>所有引用类型都继承自 Object, 这也是通过原型链实现的, 任何函数的默认原型都是一个 Object 的实例, 这意味着这个实例有一个内部指针指向<code>Object.prototype</code></p><h5 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h5><p>原型与实例的关系可以通过两种方式来确定, 第一种方式是使用 <code>instanceof</code> 操作符, 如果一个实例的原型链中出现过相应的构造函数, 则 <code>instanceof</code> 返回 true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> Parent; <span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> Child; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>第二种方式是使用 <code>isPrototypeOf()</code>方法, 原型链中包含这个原型, 这个方法就返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(instance); <span class="comment">// true</span></span><br><span class="line">Parent.prototype.isPrototypeOf(instance); <span class="comment">// true</span></span><br><span class="line">Child.prototype.isPrototypeOf(instance); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="关于方法"><a href="#关于方法" class="headerlink" title="关于方法"></a>关于方法</h5><p>子类有时候需要覆盖父类的方法, 这样我只需要在子类的<code>prototype</code>上 命名一个和父类上的方法名一样的方法就能覆盖, 增加父类没有方法 同理也是在子类<code>prototype</code>加方法就行, 需要注意的是, 我们必须是在原型上赋值后, 再添加我们需要覆盖或者新增的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getParentName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parentName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.childFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这是Parent没有的方法"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype.getParentName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这是覆盖Parent上的同名方法"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.childFunc(); <span class="comment">// 这是Parent没有的方法</span></span><br><span class="line">child.getParentName(); <span class="comment">// 这是覆盖Parent上的同名方法</span></span><br></pre></td></tr></table></figure><h5 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h5><p>使用原型实现继承时, 原型实际上变成了另一个类型的实例, 意味着原先的实例属性变成为了原型属性, 如果<code>prototype</code>上挂载的是一个引用类型的数据, 就有可能, 出现, 子类实例化后, 还能修改到父类原型上的那个数据</p><p>子类型在实例化时不能给父类型的构造函数传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getParentName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parentName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;childName: "child"&#125;</span></span><br><span class="line"><span class="comment">childName: "child"</span></span><br><span class="line"><span class="comment">__proto__: Parent</span></span><br><span class="line"><span class="comment">parentName: "parent"</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h4><p>在子类构造函数中调用父类构造函数</p><h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>相比于使用原型链, 盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参</p><h5 id="盗用构造函数的问题"><a href="#盗用构造函数的问题" class="headerlink" title="盗用构造函数的问题"></a>盗用构造函数的问题</h5><p>子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式, <code>instanceof</code>不能判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.name = <span class="string">"decade"</span>;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.colors.push(<span class="string">"yellow"</span>);</span><br><span class="line"><span class="comment">// 这样两个实例对不会共享 colors</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// ["red", "green", "black"]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;colors: Array(3)&#125;</span></span><br><span class="line"><span class="comment">colors: (3) ["red", "green", "black"]</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: ƒ Child()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">child2 <span class="keyword">instanceof</span> Parent; <span class="comment">// false</span></span><br><span class="line">child.name; <span class="comment">// Uncaught ReferenceError: child is not defined</span></span><br><span class="line">child.sayName(); <span class="comment">// Uncaught ReferenceError: child is not defined</span></span><br></pre></td></tr></table></figure><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>使用原型链继承原型上的属性和方法, 而通过盗用构造函数继承实例属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>];</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">"Decade"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;colors: Array(3), name: "Decade"&#125;</span></span><br><span class="line"><span class="comment">colors: (3) ["red", "green", "black"]</span></span><br><span class="line"><span class="comment">name: "Decade"</span></span><br><span class="line"><span class="comment">__proto__: Parent</span></span><br><span class="line"><span class="comment">colors: (3) ["red", "green", "black"]</span></span><br><span class="line"><span class="comment">name: undefined</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 能访问父级原型上的方法</span></span><br><span class="line">child.sayName(); <span class="comment">// Decade</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>不自定义类型也可以通过原型实现对象之间的信息共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    colors: [<span class="string">"black"</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = object(obj);</span><br><span class="line"><span class="keyword">const</span> person2 = object(obj);</span><br><span class="line">person1.name = <span class="string">"zio"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// decade</span></span><br><span class="line">person1.colors.push(<span class="string">"red"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.colors); <span class="comment">// ["black", "red"]</span></span><br></pre></td></tr></table></figure><p><code>Object.create(protoObject, [propertiesObject])</code> 第一个参数传入作为返回的参数的原型, 第二个参数可选, 与<code>Object.defineProperties()</code>的第二个参数一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> protoObject = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    colors: [<span class="string">"red"</span>, <span class="string">"black"</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="built_in">Object</span>.create(protoObject, &#123;</span><br><span class="line">    age: &#123;</span><br><span class="line">        value: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;age: 20&#125;</span></span><br><span class="line"><span class="comment">age: 20</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">colors: (2) ["red", "black"]</span></span><br><span class="line"><span class="comment">name: "decade"</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>创建一个实现继承的函数, 以某种方式增强对象, 然后返回这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhanceObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> clone = object(obj);</span><br><span class="line">    <span class="comment">// 增强</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    colors: [<span class="string">"black"</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = enhanceObject(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">F &#123;sayHi: ƒ&#125;</span></span><br><span class="line"><span class="comment">sayHi: ƒ ()</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">colors: ["black"]</span></span><br><span class="line"><span class="comment">name: "decade"</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h4><p>组合继承存在父类构造函数会被调用两次, 一次是在<code>Child.prototype = new Parent()</code>, 第二次是在<code>Parent.call(this)</code></p><p>寄生式组合继承通过盗用构造函数继承属性, 但使用混合式原型链继承方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">Child, Parent</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">let</span> prototype = object(Parent.prototype); <span class="comment">// prototype 的原型 是父类的原型</span></span><br><span class="line"> prototype.constructor = Child; <span class="comment">// 构造函数记得改回成子类的</span></span><br><span class="line"> Child.prototype = prototype; <span class="comment">// 修改子类的prototype</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line">inheritPrototype(Child, Parent);</span><br><span class="line">Child.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">"decade"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;name: "decade"&#125;</span></span><br><span class="line"><span class="comment">name: "decade"</span></span><br><span class="line"><span class="comment">__proto__: Parent</span></span><br><span class="line"><span class="comment">constructor: ƒ Child(name)</span></span><br><span class="line"><span class="comment">sayHi: ƒ ()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>ECMAScript 6 新引入的 class 关键字具有正式定义类的能力</p><h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>与函数类型相似, 定义类也有两种主要方式: 类声明和类表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="keyword">const</span> Personal = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>与函数表达式类似, 类表达式在它们被求值前也不能引用, 不过, 与函数定义不同的是, 虽然函数声明可以提升, 但类定义不能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(funcExp); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> funcExp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(funcExp); <span class="comment">// ƒ () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(funcDec); <span class="comment">// ƒ funcDec() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcDec</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(funcDec); <span class="comment">// ƒ funcDec() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(classExp); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> classExp = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(classExp); <span class="comment">// class &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(classDec); <span class="comment">// Uncaught ReferenceError: classDec is not defined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classDec</span> </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(classDec); <span class="comment">// class classDec &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>另一个跟函数声明不同的地方是, 函数受函数作用域限制, 而类受块作用域限制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">FunctionDec</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ClassDec</span> </span>&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionDec); <span class="comment">// ƒ FunctionDec() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassDec); <span class="comment">// Uncaught ReferenceError: ClassDec is not defined</span></span><br></pre></td></tr></table></figure><h4 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h4><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法, 但是这些方法都不是必需的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Baz &#123;</span><br><span class="line">    <span class="keyword">get</span> myBaz() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> myQux() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类表达式的名称是可选的, 在把类表达式赋值给变量后, 可以通过 name 属性取得类表达式的名称字符串, 但不能在类表达式作用域外部访问这个标识符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonName</span> </span>&#123;</span><br><span class="line">    print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Person, PersonName)</span><br><span class="line">    &#125;;</span><br><span class="line">    printName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Person.name, PersonName.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.print(); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class PersonName &#123;</span></span><br><span class="line"><span class="comment">    print() &#123;</span></span><br><span class="line"><span class="comment">        console.log(Person, PersonName)</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    printName() &#123;</span></span><br><span class="line"><span class="comment">        console.log(Person.name, PersonName.name)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">class PersonName &#123;</span></span><br><span class="line"><span class="comment">    print() &#123;</span></span><br><span class="line"><span class="comment">        console.log(Person, PersonName)</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    printName() &#123;</span></span><br><span class="line"><span class="comment">        console.log(Person.name, PersonName.name)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person.printName(); <span class="comment">// PersonName PersonName</span></span><br><span class="line">Person; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;constructor: ƒ, print: ƒ, printName: ƒ&#125;</span></span><br><span class="line"><span class="comment">constructor: class PersonName</span></span><br><span class="line"><span class="comment">arguments: (...)</span></span><br><span class="line"><span class="comment">caller: (...)</span></span><br><span class="line"><span class="comment">length: 0</span></span><br><span class="line"><span class="comment">name: "PersonName"</span></span><br><span class="line"><span class="comment">prototype: &#123;constructor: ƒ, print: ƒ, printName: ƒ&#125;</span></span><br><span class="line"><span class="comment">__proto__: ƒ ()</span></span><br><span class="line"><span class="comment">[[FunctionLocation]]: VM86:1</span></span><br><span class="line"><span class="comment">[[Scopes]]: Scopes[3]</span></span><br><span class="line"><span class="comment">print: ƒ print()</span></span><br><span class="line"><span class="comment">printName: ƒ printName()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Person.name; <span class="comment">// "PersonName"  打印的是原型上的name属性</span></span><br><span class="line">PersonName; <span class="comment">// Uncaught ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure><h4 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h4><p><code>constructor</code> 关键字用于在类定义块内部创建类的构造函数</p><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><ul><li>在内存中创建一个新的对象</li><li>这个新对象内部的<code>[[Prototype]]指针</code>被赋值为构造函数的 <code>prototype</code>属性</li><li>构造函数内部的<code>this</code> 被赋值为新对象</li><li>执行构造函数内部的代码</li><li>如果构造函数返回非空对象, 则返回该对象, 否则, 返回刚创建的新对象</li></ul><p>类实例化时传入的参数会用作构造函数的参数, </p><p>默认情况下, 类构造函数会在执行之后返回 this 对象, 如果认为的返回一个对象, 该对象是不会和类有任何关联</p><p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">"decade"</span>);</span><br><span class="line">person.name; <span class="comment">// decade</span></span><br><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: class Person</span></span><br><span class="line"><span class="comment">arguments: (...)</span></span><br><span class="line"><span class="comment">caller: (...)</span></span><br><span class="line"><span class="comment">length: 0</span></span><br><span class="line"><span class="comment">name: "Person"</span></span><br><span class="line"><span class="comment">prototype: &#123;constructor: ƒ, constructon: ƒ&#125;</span></span><br><span class="line"><span class="comment">__proto__: ƒ ()</span></span><br><span class="line"><span class="comment">[[FunctionLocation]]: VM20:1</span></span><br><span class="line"><span class="comment">[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPerson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rPerson = <span class="keyword">new</span> RPerson(<span class="string">"decade"</span>);</span><br><span class="line">rPerson.name; <span class="comment">// decade</span></span><br><span class="line">rPerson <span class="keyword">instanceof</span> RPerson; <span class="comment">// false </span></span><br><span class="line">rPerson; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;name: "decade"&#125;</span></span><br><span class="line"><span class="comment">name: "decade"</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FPerson</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FP = FPerson(); <span class="comment">// this指向 window</span></span><br><span class="line"><span class="keyword">const</span> CP = CPerson(); <span class="comment">// Uncaught TypeError: Class constructor CPerson cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure><h5 id="把类当成特殊函数"><a href="#把类当成特殊函数" class="headerlink" title="把类当成特殊函数"></a>把类当成特殊函数</h5><p>ECMAScript 中没有正式的类这个类型, 从各方面来看, ECMAScript 类就是一种特殊函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">typeof</span> Bar; <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure><p>类标识符有 <code>prototype</code> 属性, 而这个原型也有一个 <code>constructor</code> 属性指向类自身, 这样就可以使用<code>instanceof</code> </p><p>类中定义的 <code>constructor</code> 方法不会被当成构造函数, 在对它使用<code>instanceof</code>操作符时会返回 <code>false</code></p><p>类是 JavaScript 的一等公民, 因此可以像其他对象或函数引用一样把类作为参数传递</p><p>与立即调用函数表达式相似, 类也可以立即实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">"decade"</span>);</span><br><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> Person.constructor; <span class="comment">// false</span></span><br><span class="line">person.constructor === Person; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classList = [</span><br><span class="line">    <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        construtor(name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">classD, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classD(name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = createInstance(classList[<span class="number">0</span>], <span class="string">"decade"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">"decade"</span>);</span><br></pre></td></tr></table></figure><h4 id="实例-原型和类成员"><a href="#实例-原型和类成员" class="headerlink" title="实例, 原型和类成员"></a>实例, 原型和类成员</h4><p>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员, 以及应该存在于类本身的成员</p><h5 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h5><p>每次通过new调用类标识符时, 都会执行类构造函数, 在这个函数内部, 可以为新创建的实例<code>this</code>添加””自有”属性, 在构造函数执行完毕后, 仍然可以给实例继续添加新成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"black"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">"decade"</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">"zio"</span>);</span><br><span class="line">person1.colors === person2.colors; <span class="comment">// false</span></span><br><span class="line">person1.sayName(); <span class="comment">// "decade"</span></span><br><span class="line">person2.sayName(); <span class="comment">// "zio"</span></span><br></pre></td></tr></table></figure><h5 id="原型方法与访问器"><a href="#原型方法与访问器" class="headerlink" title="原型方法与访问器"></a>原型方法与访问器</h5><p>为了在实例间共享方法, 类定义语法把在类块中定义的方法作为原型方法</p><p>类方法等同于对象属性, 因此可以使用字符串、符号或计算的值作为键</p><p>类定义也支持获取和设置访问器, 语法与行为跟普通对象一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.loacte = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    locate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"prototype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;loacte: ƒ&#125;</span></span><br><span class="line"><span class="comment">loacte: () =&gt; &#123; console.log("instance"); &#125;</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: class Person</span></span><br><span class="line"><span class="comment">locate: ƒ locate()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SymbolKey = <span class="built_in">Symbol</span>(<span class="string">"key"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">    stringKey() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"stringKey"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [SymbolKey]() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"SymbolKey"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="string">"computed"</span> + <span class="string">"Key"</span>]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"computedKey"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person1();</span><br><span class="line">person1.stringKey(); <span class="comment">// stringKey</span></span><br><span class="line">person1.computedKey(); <span class="comment">// computedKey</span></span><br><span class="line">person1[SymbolKey](); <span class="comment">// SymbolKey</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> name(newName) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person2();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person2 &#123;&#125;</span></span><br><span class="line"><span class="comment">name: undefined</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: class Person2</span></span><br><span class="line"><span class="comment">name: undefined</span></span><br><span class="line"><span class="comment">get name: ƒ name()</span></span><br><span class="line"><span class="comment">set name: ƒ name(newName)</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">p.name = <span class="string">"decade"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person2 &#123;_name: "decade"&#125;</span></span><br><span class="line"><span class="comment">_name: "decade"</span></span><br><span class="line"><span class="comment">name: "decade"</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: class Person2</span></span><br><span class="line"><span class="comment">name: "decade"</span></span><br><span class="line"><span class="comment">get name: ƒ name()</span></span><br><span class="line"><span class="comment">set name: ƒ name(newName)</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h5><p>可以在类上定义静态方法, 这些方法通常用于执行不特定于实例的操作, 也不要求存在类的实例, 与原型成员类似，静态成员每个类上只能有一个, 静态类成员在类定义中使用 <code>static</code> 关键字作为前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.locate = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"instance"</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    locate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"prototype"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> locate() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"class"</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.locate();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">instance</span></span><br><span class="line"><span class="comment">Person &#123;locate: ƒ&#125;</span></span><br><span class="line"><span class="comment">locate: () =&gt; console.log("instance", this)</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: class Person</span></span><br><span class="line"><span class="comment">locate: ƒ locate()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Person.prototype.locate();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">prototype </span></span><br><span class="line"><span class="comment">&#123;constructor: ƒ, locate: ƒ&#125;</span></span><br><span class="line"><span class="comment">constructor: class Person</span></span><br><span class="line"><span class="comment">locate: ƒ locate()</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Person.locate();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class </span></span><br><span class="line"><span class="comment">class Person &#123;...&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h5><p>虽然类定义并不显式支持在原型或类上添加成员数据, 但在类定义外部, 可以手动添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.greeting = <span class="string">'my name is'</span>;</span><br><span class="line">Person.prototype.name = <span class="string">"decade"</span>;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.sayName(); <span class="comment">//  my name is decade</span></span><br></pre></td></tr></table></figure><h5 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.names = [<span class="string">"decade"</span>, <span class="string">"w"</span>, <span class="string">"zio"</span>, <span class="string">"build"</span>, <span class="string">"drive"</span>, <span class="string">"ooo"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    * createName() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"decade"</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"zio"</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"w"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> * createName() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"ooo"</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"build"</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"drive"</span></span><br><span class="line">    &#125;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> * <span class="keyword">this</span>.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> person.createName()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// decade zio w</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> Person.createName()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// ooo build drive</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// decade w zio build drive ooo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><h5 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h5><p>ES6 类支持单继承, 使用 <code>extends</code> 关键字, 就可以继承任何拥有<code>[[Construct]]</code>和原型的对象, 这意味着不仅可以继承一个类, 也可以继承普通的构造函数(保持向后兼容)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CParent</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FParent</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">CParent</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Child1();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child1 &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: CParent</span></span><br><span class="line"><span class="comment">constructor: class Child1</span></span><br><span class="line"><span class="comment">arguments: (...)</span></span><br><span class="line"><span class="comment">caller: (...)</span></span><br><span class="line"><span class="comment">length: 0</span></span><br><span class="line"><span class="comment">name: "Child1"</span></span><br><span class="line"><span class="comment">prototype: CParent &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">__proto__: class CParent</span></span><br><span class="line"><span class="comment">[[FunctionLocation]]: VM20:3</span></span><br><span class="line"><span class="comment">[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">FParent</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child2 &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: FParent</span></span><br><span class="line"><span class="comment">constructor: class Child2</span></span><br><span class="line"><span class="comment">length: 0</span></span><br><span class="line"><span class="comment">name: "Child2"</span></span><br><span class="line"><span class="comment">prototype: FParent &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">__proto__: ƒ FParent()</span></span><br><span class="line"><span class="comment">[[FunctionLocation]]: VM56:1</span></span><br><span class="line"><span class="comment">[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="构造函数-HomeObject-super"><a href="#构造函数-HomeObject-super" class="headerlink" title="构造函数 ,HomeObject ,  super()"></a>构造函数 ,HomeObject ,  super()</h5><p>派生类的方法可以通过 <code>super</code> 关键字引用它们的原型, 这个关键字只能在派生类中使用, 而且仅限于类构造函数, 实例方法和静态方法内部</p><p>在类构造函数中使用 <code>super</code> 可以调用父类构造函数</p><p>在静态方法中可以通过 <code>super</code> 调用继承的类上定义的静态方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Parent被实例化了"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> print() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Parent print"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Child被实例化"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> print() &#123;</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(); <span class="comment">// Parent被实例化了 Child被实例化</span></span><br><span class="line">Child.print(); <span class="comment">// Parent print</span></span><br><span class="line">Parent.print(); <span class="comment">// Parent print</span></span><br></pre></td></tr></table></figure><p>ES6 给类构造函数和静态方法添加了内部特性<code>[[HomeObject]]</code>, 这个特性是一个指针, 指向定义该方法的对象, 这个指针是自动赋值的, 而且只能在 JavaScript 引擎内部访问, super 始终会定义为<code>[[HomeObject]]</code>的原型</p><ul><li>super 只能在派生类构造函数和静态方法中使用</li><li>不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法</li><li>调用 super()会调用父类构造函数，并将返回的实例赋值给 this</li><li>super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入</li><li>如果没有定义类构造函数, 在实例化派生类时会调用 super(), 而且会传入所有传给派生类的参数</li><li>在类构造函数中，不能在调用 super()之前引用 this</li><li>如果在派生类中显式定义了构造函数, 则要么必须在其中调用 super(), 要么必须在其中返回一个对象</li></ul><h5 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h5><p>有时候可能需要定义这样一个类, 它可供其他类继承, 但本身不会被实例化, 虽然 ECMAScript 没有专门支持这种类的语法 , 但通过 <code>new.target</code> 也很容易实现。<code>new.target</code> 保存通过 <code>new</code> 关键字调用的类或函数, 通过在实例化时检测 <code>new.target</code> 是不是抽象基类, 可以阻止对抽象基类的实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">        <span class="comment">// 这是一个抽象类 本身不允许实例化</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Parent) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Parent cannot be directly instantiated'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.sayHi) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Inheriting class must define sayHi()'</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Child extends Parent &#123;</span></span><br><span class="line"><span class="comment">    constructor() &#123;</span></span><br><span class="line"><span class="comment">        super();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sayHi() &#123;</span></span><br><span class="line"><span class="comment">        console.log("hi")</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent(); <span class="comment">// Uncaught Error: Parent cannot be directly instantiated</span></span><br></pre></td></tr></table></figure><h5 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h5><p>ES6 类为继承内置引用类型提供了顺畅的机制, 开发者可以方便地扩展内置类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    shuffle() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; </span><br><span class="line">            <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>)); </span><br><span class="line">            [<span class="keyword">this</span>[i], <span class="keyword">this</span>[j]] = [<span class="keyword">this</span>[j], <span class="keyword">this</span>[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> myArr = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">myArr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">myArr <span class="keyword">instanceof</span> MyArray; <span class="comment">// true</span></span><br><span class="line">myArr.shuffle(); <span class="comment">// [4, 2, 5, 3, 1]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MyArray(5) [4, 2, 5, 3, 1]</span></span><br><span class="line"><span class="comment">0: 4</span></span><br><span class="line"><span class="comment">1: 2</span></span><br><span class="line"><span class="comment">2: 5</span></span><br><span class="line"><span class="comment">3: 3</span></span><br><span class="line"><span class="comment">4: 1</span></span><br><span class="line"><span class="comment">length: 5</span></span><br><span class="line"><span class="comment">__proto__: Array</span></span><br><span class="line"><span class="comment">constructor: class MyArray</span></span><br><span class="line"><span class="comment">shuffle: ƒ shuffle()</span></span><br><span class="line"><span class="comment">__proto__: Array(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>有些内置类型的方法会返回新实例, 默认情况下, 返回实例的类型与原始实例的类型是一致的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> a2 = a1.filter(<span class="function"><span class="params">v</span> =&gt;</span> !!(v % <span class="number">2</span>)); <span class="comment">// [1, 3, 5]</span></span><br><span class="line">a1 <span class="keyword">instanceof</span> MyArray; <span class="comment">// true</span></span><br><span class="line">a2 <span class="keyword">instanceof</span> MyArray; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果想覆盖这个默认行为, 则可以覆盖 <code>Symbol.species</code> 访问器, 这个访问器决定在创建返回的实例时使用的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> a2 = a1.filter(<span class="function"><span class="params">v</span> =&gt;</span> !!(v % <span class="number">2</span>)); <span class="comment">// [1, 3, 5]</span></span><br><span class="line">a1 <span class="keyword">instanceof</span> MyArray; <span class="comment">// true</span></span><br><span class="line">a2 <span class="keyword">instanceof</span> MyArray; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="类混入"><a href="#类混入" class="headerlink" title="类混入"></a>类混入</h5><p>把不同类的行为集中到一个类是一种常见的 JavaScript 模式, 虽然 ES6 没有显式支持多类继承, 但通过现有特性可以轻松地模拟这种行为</p><p>extends 关键字后面是一个 JavaScript 表达式, 任何可以解析为一个类或一个构造函数的表达式都是有效的, 这个表达式会在求值类定义时被求值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">getParent</span>() </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: Parent</span></span><br><span class="line"><span class="comment">constructor: class Child</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>多个类的混入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseC</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fooMixin = <span class="function">(<span class="params">superClass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> barMixin = <span class="function">(<span class="params">superClass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</span><br><span class="line">    bar() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bazMixin = <span class="function">(<span class="params">superClass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</span><br><span class="line">    baz() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"baz"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">fooMixin</span>(<span class="title">barMixin</span>(<span class="title">bazMixin</span>(<span class="title">BaseC</span>))) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Bus();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Bus &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: class Bus</span></span><br><span class="line"><span class="comment">arguments: (...)</span></span><br><span class="line"><span class="comment">caller: (...)</span></span><br><span class="line"><span class="comment">length: 0</span></span><br><span class="line"><span class="comment">name: "Bus"</span></span><br><span class="line"><span class="comment">prototype:</span></span><br><span class="line"><span class="comment">constructor: class Bus</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">constructor: class extends</span></span><br><span class="line"><span class="comment">foo: ƒ foo()</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">bar: ƒ bar()</span></span><br><span class="line"><span class="comment">constructor: class extends</span></span><br><span class="line"><span class="comment">__proto__: BaseC</span></span><br><span class="line"><span class="comment">baz: ƒ baz()</span></span><br><span class="line"><span class="comment">constructor: class extends</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">__proto__: class extends</span></span><br><span class="line"><span class="comment">[[FunctionLocation]]: VM53:17</span></span><br><span class="line"><span class="comment">[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版-第七章-笔记</title>
    <link href="http://blog.decade.run/2021/01/25/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2021/01/25/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-25T07:52:38.000Z</published>
    <updated>2021-01-27T08:17:52.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解迭代"><a href="#理解迭代" class="headerlink" title="理解迭代"></a>理解迭代</h3><p>在<code>JavaScript</code>中 循环计数就是一种最简单的迭代</p><p>循环是迭代机制的基础,  因为循环可以指定 <code>迭代的次数</code> , 每次迭代 <code>执行的操作</code>, 每次循环都会在下一次迭代开始之前完成, 而每次迭代的顺序都是事先定义好的</p><p>迭代会在一个有序集合上进行. (“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到, 特别是开始和结束项有明确的定义.) 数组是 JavaScript 中有序集合的最典型例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为数组有已知的长度, 且数组每一项都可以通过<code>索引</code>获取, 所以整个数组可以通过递增索引来遍历. 由于如下原因，通过这种循环来执行例程并不理想</p><ul><li>迭代之前需要事先知道如何使用<code>数据结构</code> </li><li><code>遍历顺序</code>并不是数据结构固有的 </li></ul><p>ES5 新增了 Array.prototype.forEach()方法, 向通用迭代需求迈进了一步(但仍然不够理想)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个方法解决了单独记录索引和通过数组对象取得值的问题, 不过, 没有办法标识迭代何时<code>终止</code>, 因此这个方法只适用于数组, 而且回调结构也比较笨拙</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式 (特别是在 ECMAScript 这个语境下)描述了一个方案, 即可以把有些结构称为”可迭代对象”(iterable), 因为它们实现了正式的 <code>Iterable</code>接口，而且可以通过迭代器 <code>Iterator</code>消费</p><p>可迭代对象是一种抽象的说法, 基本上, 可以把可迭代对象理解成<code>数组或集合</code>这样的集合类型的对象, 它们包含的元素都是<code>有限的</code>, 而且都具有无歧义的遍历顺序, 不过, 可迭代对象不一定是集合对象, 也可以是仅仅具有<code>类似数组行为</code>的其他数据结构</p><p>任何实现 <code>Iterable 接口</code>的数据结构都可以被实现 <code>Iterator 接口</code>的结构<code>&quot;消费&quot;(consume)</code>, 迭代器（iterator）是按需创建的一次性对象, 每个迭代器都会关联一个可迭代对象, 而迭代器会暴露迭代其关联可迭代对象的 API, 迭代器无须了解与其关联的可迭代对象的结构, 只需要知道如何取得连续的值, 这种概念上的分离正是 Iterable 和 Iterator 的强大之处</p><h4 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h4><p>实现可迭代的协议需要同时具备两种能力:</p><ol><li>支持迭代的自我识别能力</li><li>创建实现<code>Iterator</code>接口对象的能力</li></ol><p>在 ECMAScript 中, 这意味着必须暴露一个属性作为”默认迭代器”, 而且这个属性必须使用特殊的 <code>Symbol.iterator</code> 作为键, 这个默认迭代器属性必须引用一个迭代器工厂函数, 调用这个工厂函数必须返回一个新迭代器</p><p>很多内置类型都实现了<code>Iterator</code>接口</p><ol><li>字符串</li><li>数组</li><li>映射</li><li>集合</li><li>arguments对象</li><li>NodeList等DOM结合类型</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断一个方法是否有迭代属性</span></span><br><span class="line"><span class="keyword">const</span> isIterator = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[<span class="built_in">Symbol</span>.iterator] != <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"decade"</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">let els = document.querySelectorAll("div");</span><br><span class="line"></span><br><span class="line">str[Symbol.iterator](); // StringIterator &#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">StringIterator &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: String Iterator</span></span><br><span class="line"><span class="comment">next: ƒ next()</span></span><br><span class="line"><span class="comment">Symbol(Symbol.toStringTag): "String Iterator"</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">Symbol(Symbol.iterator): ƒ [Symbol.iterator]()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: Array Iterator</span></span><br><span class="line"><span class="comment">next: ƒ next()</span></span><br><span class="line"><span class="comment">Symbol(Symbol.toStringTag): "Array Iterator"</span></span><br><span class="line"><span class="comment">__proto__: </span></span><br><span class="line"><span class="comment">Symbol(Symbol.iterator): ƒ [Symbol.iterator]()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">map[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// MapIterator &#123;&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MapIterator &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: Map Iterator</span></span><br><span class="line"><span class="comment">next: ƒ next()</span></span><br><span class="line"><span class="comment">Symbol(Symbol.toStringTag): "Map Iterator"</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">Symbol(Symbol.iterator): ƒ [Symbol.iterator]()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">set</span>[Symbol.iterator](); // SetIterator &#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SetIterator &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: Set Iterator</span></span><br><span class="line"><span class="comment">next: ƒ next()</span></span><br><span class="line"><span class="comment">Symbol(Symbol.toStringTag): "Set Iterator"</span></span><br><span class="line"><span class="comment">__proto__:</span></span><br><span class="line"><span class="comment">Symbol(Symbol.iterator): ƒ [Symbol.iterator]()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">els[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="comment">__proto__: Array Iterator</span></span><br><span class="line"><span class="comment">next: ƒ next()</span></span><br><span class="line"><span class="comment">Symbol(Symbol.toStringTag): "Array Iterator"</span></span><br><span class="line"><span class="comment">__proto__: </span></span><br><span class="line"><span class="comment">Symbol(Symbol.iterator): ƒ [Symbol.iterator]()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>实际写代码过程中, 不需要显式调用这个工厂函数来生成迭代器, 实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性, 接收可迭代对象的原生语言特性包括</p><ol><li>for-of 循环</li><li>数组解构</li><li>扩展操作符</li><li>Array.from()</li><li>创建集合</li><li>创建映射</li><li>Promise.all()接收由期约组成的可迭代对象</li><li>Promise.race()接收由期约组成的可迭代对象</li><li>yield * 操作符, 在生成器中使用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> restArr = [...arr];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fromArr = <span class="built_in">Array</span>.from(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set(arr);</span><br><span class="line"></span><br><span class="line">const map = new Map(arr.map((v, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> [v, i];</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果对象原型链上的父类实现了 Iterable 接口, 那这个对象也就实现了这个接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> myArr = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> myArr) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(v); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h4><p>迭代器是一种一次性使用的对象, 用于迭代与其关联的可迭代的对象,  迭代器API使用 <code>next()</code> 方法在可迭代对象中遍历数据, 每次成功调用 next(), 都会返回一个 <code>IteratorResult</code> 对象, 其中包含迭代器返回的下一个值, 若不调用 next(), 则无法知道迭代器的当前位置</p><p><code>next()</code>方法返回的迭代器对象 <code>IteratorResult</code>包含两个属性: <code>done 和 value</code>, <code>done</code>是一个布尔值, 表示是否还可以再次调用 <code>next()</code>取得下一个值; <code>value</code>包含可迭代对象的下一个值<code>(done 为false)</code>, 或者 <code>undefined(done 为 true)</code>,  <code>done: true</code>状态称为”耗尽”, 可以通过以下简单的数组来演示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iterator.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>每个迭代器都表示对可迭代对象的一次性有序遍历, 不同迭代器的实例相互之间没有联系, 只会独立地遍历可迭代对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> iter1 = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="keyword">let</span> iter2 = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iter1.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iter2.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br></pre></td></tr></table></figure><p>迭代器并不与可迭代对象某个时刻的快照绑定, 而仅仅是使用游标来记录遍历可迭代对象的历程, 如果可迭代对象在迭代期间被修改了, 那么迭代器也会反映相应的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'bar'</span>);</span><br><span class="line">iter.next(); <span class="comment">// &#123;value: "bar", done: false&#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>“迭代器”的概念有时候容易模糊, 因为它可以指通用的迭代, 也可以指接口, 还可以指正式的迭代器类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> </span>&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            next() &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="string">'foo'</span> &#125;; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myIter = <span class="keyword">new</span> MyIterator();</span><br><span class="line">myIter[<span class="built_in">Symbol</span>.iterator]; <span class="comment">// &#123;next: ƒ&#125;</span></span><br></pre></td></tr></table></figure><h4 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h4><p>与 Iterable 接口类似, 任何实现 Iterator 接口的对象都可以作为迭代器使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(limit) &#123; </span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line">    next() &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.count &lt;= <span class="keyword">this</span>.limit) &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="keyword">this</span>.count++ &#125;; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再执行一次 发现什么都没打印出来 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原因</span></span><br><span class="line"><span class="keyword">const</span> iter = counter[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">iter.next(); <span class="comment">// &#123;done: true, value: undefined&#125;</span></span><br></pre></td></tr></table></figure><p>可以创建多个迭代器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(limit) &#123; </span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>,</span><br><span class="line">            limit = <span class="keyword">this</span>.limit;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">               <span class="keyword">if</span> (count &lt; limit) &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;; </span><br><span class="line">        &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h4><p>可选的 <code>return()</code> 方法用于指定在迭代器提前关闭时执行的逻辑, 执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以”关闭”迭代器</p><p>可能有以下情况</p><ol><li>for-of 循环通过 break、continue、return 或 throw 提前退出</li><li>解构操作并未消费所有值</li></ol><p><code>return()</code>方法必须返回一个有效的 <code>IteratorResult</code>对象, 简单情况下, 可以只返回{ done: true }</p><p>内置语言结构在发现还有更多值可以迭代, 但不会消费这些值时, 会自动调用<code>return()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(limit) &#123; </span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>,</span><br><span class="line">            limit = <span class="keyword">this</span>.limit;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">               <span class="keyword">if</span> (count &lt; limit) &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;; </span><br><span class="line">        &#125;  </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">return</span>() &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'Exiting early'</span>); </span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123; </span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;; <span class="comment">// Exiting early</span></span><br><span class="line"><span class="keyword">let</span> counter2 = <span class="keyword">new</span> Counter(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter2) &#123; </span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="string">'err'</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 0, 1, 2</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125; <span class="comment">// Exiting early</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter3 = <span class="keyword">new</span> Counter(<span class="number">5</span>); </span><br><span class="line"><span class="keyword">let</span> [a, b] = counter3; <span class="comment">// Exiting early</span></span><br></pre></td></tr></table></figure><p>如果迭代器没有关闭, 则还可以继续从上次离开的地方继续迭代, 比如, 数组的迭代器就是不能关闭的</p><p>因为 return()方法是可选的, 所以并非所有迭代器都是可关闭的, 要知道某个迭代器是否可关闭, 可以测试这个迭代器实例的 return 属性是不是函数对象, 不过, 仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的, 这是因为调用 return()不会强制迭代器进入关闭状态, 即便如此, return()方法还是会被调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </span><br><span class="line"><span class="keyword">const</span> iter = arr[<span class="built_in">Symbol</span>.iterator](); </span><br><span class="line"></span><br><span class="line">iter.return = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"try"</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        done: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 1, 2, 3</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器是 ECMAScript 6 新增的一个极为灵活的结构, 拥有在一个函数块内暂停和恢复代码执行的能力, 这种新能力具有深远的影响, 比如, 使用生成器可以自定义迭代器和实现协程</p><h4 id="生成器基础"><a href="#生成器基础" class="headerlink" title="生成器基础"></a>生成器基础</h4><p>生成器的形式是一个函数, 函数名称前面加一个星号 <code>*</code> 表示它是一个生成器, 只要是可以定义函数的地方, 就可以定义生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> generatorFunc2 = <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为对象字面量方法的生成器函数</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    * generatorFunc() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为类实例方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">    * generatorFunc() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为类静态方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OBJ</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> * generatorFunc() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数不能用来定义生成器函数。</span></span><br><span class="line"><span class="comment">// 标识生成器函数的星号不受两侧空格的影响</span></span><br></pre></td></tr></table></figure><p>调用生成器函数会产生一个生成器对象, 生成器对象一开始处于暂停执行<code>(suspended)</code>的状态, 与迭代器相似, 生成器对象也实现了 <code>Iterator</code> 接口, 因此具有 <code>next()</code>方法, 调用这个方法会让生成器开始或恢复执行</p><p>有两个状态, 一个是 <code>suspended</code> 一个是 <code>closed</code> 看打印出来的区域大概就是 <code>[[GeneratorState]]</code> 指的这个字段值不一样,  两个状态还有个一个不一样的地方, 处于<code>suspended</code>状态的 会有一个<code>[[Scopes]]</code>字段, 作用域的意思, 指当前函数的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">generatorFunc &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="comment">__proto__: Generator</span></span><br><span class="line"><span class="comment">__proto__: Generator</span></span><br><span class="line"><span class="comment">constructor: GeneratorFunction &#123;prototype: Generator, Symbol(Symbol.toStringTag): "GeneratorFunction", constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">next: ƒ next()</span></span><br><span class="line"><span class="comment">return: ƒ return()</span></span><br><span class="line"><span class="comment">throw: ƒ throw()</span></span><br><span class="line"><span class="comment">Symbol(Symbol.toStringTag): "Generator"</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">[[GeneratorLocation]]: VM248:1</span></span><br><span class="line"><span class="comment">[[GeneratorState]]: "suspended"</span></span><br><span class="line"><span class="comment">[[GeneratorFunction]]: ƒ * generatorFunc()</span></span><br><span class="line"><span class="comment">[[GeneratorReceiver]]: Window</span></span><br><span class="line"><span class="comment">[[Scopes]]: Scopes[3]</span></span><br><span class="line"><span class="comment">0: Local (generatorFunc) &#123;&#125;</span></span><br><span class="line"><span class="comment">1: Script &#123;g: generatorFunc&#125;</span></span><br><span class="line"><span class="comment">2: Global &#123;window: Window, self: Window, document: document, name: "", location: Location, …&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">g.next();</span><br><span class="line"><span class="built_in">console</span>.log(g);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">generatorFunc &#123;&lt;closed&gt;&#125;</span></span><br><span class="line"><span class="comment">__proto__: Generator</span></span><br><span class="line"><span class="comment">__proto__: Generator</span></span><br><span class="line"><span class="comment">constructor: GeneratorFunction &#123;prototype: Generator, Symbol(Symbol.toStringTag): "GeneratorFunction", constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">next: ƒ next()</span></span><br><span class="line"><span class="comment">return: ƒ return()</span></span><br><span class="line"><span class="comment">throw: ƒ throw()</span></span><br><span class="line"><span class="comment">Symbol(Symbol.toStringTag): "Generator"</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">[[GeneratorLocation]]: VM177:1</span></span><br><span class="line"><span class="comment">[[GeneratorState]]: "closed"</span></span><br><span class="line"><span class="comment">[[GeneratorFunction]]: ƒ * generatorFunc()</span></span><br><span class="line"><span class="comment">[[GeneratorReceiver]]: Window</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>next()方法的返回值类似于迭代器, 有一个<code>done</code>属性和一个 <code>value</code> 属性, 函数体为空的生成器函数中间不会停留, 调用一次 next()就会让生成器到达 <code>done: true</code>状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc();</span><br><span class="line">g.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>value 属性是生成器函数的返回值, 默认值为 <code>undefined</code>, 可以通过生成器函数的返回值指定</p><p>生成器函数只会在初次调用 next()方法后开始执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"first"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"generatorFunc"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc();</span><br><span class="line">g.next(); <span class="comment">// first  &#123;value: "generatorFunc", done: true&#125;</span></span><br></pre></td></tr></table></figure><p>生成器对象实现了 <code>Iterable</code> 接口, 它们默认的迭代器是自引用的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc();</span><br><span class="line">g === generatorFunc()[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="通过yield中断执行"><a href="#通过yield中断执行" class="headerlink" title="通过yield中断执行"></a>通过yield中断执行</h4><p><code>yield</code> 关键字可以让生成器停止和开始执行, 停止执行的生成器函数只能通过在生成器对象上调用 <code>next()</code>方法来恢复执行</p><p><code>yield</code>关键字有点像函数的中间返回语句, 它生成的值会出现在 <code>next()</code> 方法返回的对象里, 通过 <code>yield</code> 关键字退出的生成器函数会处在 <code>done: false</code>状态; 通过 <code>return</code>关键字退出的生成器函数会处于 <code>done: true</code> 状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc(); <span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// generatorFunc &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// generatorFunc &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>生成器函数内部的执行流程会针对每个生成器对象区分作用域, 在一个生成器对象上调用 <code>next()</code>不会影响其他生成器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"first"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"second"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"third"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc();</span><br><span class="line">g.next(); <span class="comment">// &#123;value: "first", done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: "second", done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: "third", done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p><code>yield</code>关键字只能在生成器函数内部使用, 用在其他地方会抛出错误, 类似函数的 <code>return</code> 关键字, <code>yield</code> 关键字必须直接位于生成器函数定义中, 出现在嵌套的非生成器函数中会抛出语法错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">validGeneratorFn</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效 a不是生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnA</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">yield</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效 b不是生成器函数, * 也不能用于箭头函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnB</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> b = <span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无效 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">invalidGeneratorFnC</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    (<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span>; </span><br><span class="line">    &#125;)(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="生成器对象作为可迭代对象"><a href="#生成器对象作为可迭代对象" class="headerlink" title="生成器对象作为可迭代对象"></a>生成器对象作为可迭代对象</h5><p>频繁调用 <code>next()</code> 看着就麻烦,  我们知道 <code>generatorFunc() === generatorFunc()[Symbol.iterator]()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"first"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"second"</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"third"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> generatorFunc()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// first second third</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-yield-实现输入和输出"><a href="#使用-yield-实现输入和输出" class="headerlink" title="使用 yield 实现输入和输出"></a>使用 <strong>yield</strong> 实现输入和输出</h5><p>除了可以作为函数的中间返回语句使用, <code>yield</code> 关键字还可以作为函数的中间参数使用, 上一次让生成器函数暂停的 <code>yield</code> 关键字会接收到传给 <code>next()</code>方法的第一个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">yield</span>); </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">yield</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc(<span class="string">"start"</span>);</span><br><span class="line">g.next(<span class="number">1</span>); <span class="comment">// start</span></span><br><span class="line">g.next(<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">g.next(<span class="number">3</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>yield 关键字可以同时用于输入和输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">'foo'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> g = generatorFunc(); </span><br><span class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123;done: false, value: 'foo'&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">'bar'</span>)); <span class="comment">// &#123;done: true, value: 'bar'&#125;</span></span><br><span class="line"><span class="comment">// 因为函数必须对整个表达式求值才能确定要返回的值, 所以它在遇到 yield 关键字时暂停执行并计算出要产生的值: "foo", 下一次调用 next()传入了"bar"，作为交给同一个 yield 的值, 然后这个值被确定为本次生成器函数要返回的值</span></span><br></pre></td></tr></table></figure><h5 id="产生可迭代对象"><a href="#产生可迭代对象" class="headerlink" title="产生可迭代对象"></a>产生可迭代对象</h5><p>可以使用星号增强 yield 的行为, 让它能够迭代一个可迭代对象, 从而一次产出一个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> generatorFunc()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc();</span><br><span class="line">g.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br></pre></td></tr></table></figure><p><code>yield*</code>的值是关联迭代器返回 <code>done: true</code>时的 value 属性, 对于普通迭代器来说, 这个值是undefined</p><h5 id="使用-yield-实现递归算法"><a href="#使用-yield-实现递归算法" class="headerlink" title="使用 yield*实现递归算法"></a>使用 <strong>yield*</strong>实现递归算法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">yield</span>* nTimes(n - <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">yield</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生成器作为默认迭代器"><a href="#生成器作为默认迭代器" class="headerlink" title="生成器作为默认迭代器"></a>生成器作为默认迭代器</h4><p>因为生成器对象实现了 <code>Iterator</code>接口, 而且生成器函数和默认迭代器被调用之后都产生迭代器, 所以生成器格外适合作为默认迭代器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.valuse = [<span class="number">1</span>, <span class="number">2</span> ,<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> * <span class="keyword">this</span>.valuse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里，for-of 循环调用了默认迭代器(它恰好又是一个生成器函数)并产生了一个生成器对象, 这个生成器对象是可迭代的，所以完全可以在迭代中使用</span></span><br></pre></td></tr></table></figure><h4 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h4><p>与迭代器类似, 生成器也支持”可关闭”的概念</p><p>实现<code>iterator</code> 的 <code>next()</code> 方法, 可选的 <code>return()</code>终止迭代, 第三个方法<code>throw()</code>,  <code>return()</code> 和 <code>throw()</code>方法都可以用于强制生成器进入关闭状态</p><p><code>return()</code> 方法会强制生成器进入关闭状态, 提供给 <code>return()</code>方法的值, 就是终止迭代器对象的值, 与迭代器不同, 所有生成器对象都有 return()方法, 只要通过它进入关闭状态，就无法恢复了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc();</span><br><span class="line">g.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">g.return(<span class="number">2</span>); <span class="comment">// &#123;value: 2, done: true&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p><code>for-of</code> 循环等内置语言结构会忽略状态为 <code>done: true</code> 的 IteratorObject 内部返回的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> g) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        g.return(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>throw()</code>方法会在暂停的时候将一个提供的错误注入到生成器对象中, 如果错误未被处理, 生成器就会关闭</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = generatorFunc(); <span class="comment">// generatorFunc &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    g.throw(<span class="string">'foo'</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(e);  <span class="comment">// foo</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(g); <span class="comment">// generatorFunc &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>不过, 假如生成器函数内部处理了这个错误, 那么生成器就不会关闭, 而且还可以恢复执行, 错误处理会跳过对应的 <code>yield</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="keyword">yield</span> v; </span><br><span class="line"> &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(v)</span><br><span class="line">        &#125; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = generatorFunc();</span><br><span class="line">g.next(); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">g.throw(<span class="string">"1"</span>); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版-第六章-笔记</title>
    <link href="http://blog.decade.run/2020/12/22/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2020/12/22/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-22T05:08:14.000Z</published>
    <updated>2021-01-25T07:48:53.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>到目前为止，大多数引用值的示例使用的是 Object 类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">obj.name = <span class="string">"decade"</span>;</span><br><span class="line">obj.age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="number">21</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.name; <span class="comment">// decade</span></span><br><span class="line">obj[<span class="string">"name"</span>]; <span class="comment">// decade</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"name"</span>;</span><br><span class="line">obj[str]; <span class="comment">// decade</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">"ame"</span>;</span><br><span class="line">obj[<span class="string">"n"</span> + str1]; <span class="comment">// decade</span></span><br></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// []</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>); <span class="comment">// [empty × 5] 传入一个数字 会赋值个length 返回的是一个长度为5的数组</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"5"</span>); <span class="comment">// ["5"]</span></span><br><span class="line"><span class="keyword">let</span> arr4 = []; <span class="comment">// []</span></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="string">"1"</span>, <span class="number">1</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="number">5</span>, <span class="string">"decade"</span>]; <span class="comment">// ["1", 1, "2", "3", 5, "decade"]</span></span><br></pre></td></tr></table></figure><p>Array.from() 用于将类数组转换为数组, 参数是一个类数组, 即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">"decade"</span>); <span class="comment">// ["d", "e", "c", "a", "d", "e"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">map.set(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">Map</span>(<span class="number">2</span>) &#123;<span class="number">1</span> =&gt; <span class="number">2</span>, <span class="number">2</span> =&gt; <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">Array</span>.from(map); <span class="comment">// [Array(2), Array(2)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add(2);</span><br><span class="line"><span class="keyword">set</span>.add(3); // Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">set</span>); // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">const iter = &#123; </span><br><span class="line"> *[<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line"> <span class="keyword">yield</span> <span class="number">4</span>; </span><br><span class="line"> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Array</span>.from(iter); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from(obj); <span class="comment">//  [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有length属性</span></span><br><span class="line">obj = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from(obj); <span class="comment">//  []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有length属性</span></span><br><span class="line">obj = &#123;</span><br><span class="line">    length: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from(obj); <span class="comment">// [undefined, undefined, undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有length属性 但是对象键值不为数字</span></span><br><span class="line">obj = &#123;</span><br><span class="line">    age: <span class="number">12</span>,</span><br><span class="line">    name: <span class="string">"decade"</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">    length: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from(obj); <span class="comment">// [undefined, undefined, 3, undefined]</span></span><br></pre></td></tr></table></figure><p>Array.from(), 还接收第二个可选的映射函数参数, </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将下面的对象转换成数组 并得到数组每一项值得平方</span></span><br><span class="line"><span class="keyword">let</span> arr = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">    length: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有使用第二个参数</span></span><br><span class="line"><span class="built_in">Array</span>.from(arr).map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item ** <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用第二个函数参数 方法只有两个形参 一个值 一个下标</span></span><br><span class="line"><span class="built_in">Array</span>.from(arr, (v, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> v ** <span class="number">2</span></span><br><span class="line">&#125;); <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><p>Array.from() 还接收第三个参数 用于指定第二个函数参数的this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arr, <span class="function"><span class="keyword">function</span>(<span class="params">v, i</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// &#123;name: "decade"&#125;</span></span><br><span class="line">&#125;, &#123;<span class="attr">name</span>: <span class="string">"decade"</span>&#125;);</span><br></pre></td></tr></table></figure><p>Array.of()可以把一组参数转换为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4] </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="literal">undefined</span>)); <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure><h4 id="数组空位"><a href="#数组空位" class="headerlink" title="数组空位"></a>数组空位</h4><p>使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [,,,,,]; <span class="comment">// [empty × 5]</span></span><br></pre></td></tr></table></figure><p>ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,,,,,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(item === <span class="literal">undefined</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.from(arr); <span class="comment">// [1, undefined, undefined, undefined, undefined, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr1) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(item === <span class="literal">undefined</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.of(...[,,,]); <span class="comment">// [undefined, undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> arr.entries()) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>ES6 之前的方法则会忽略这个空位，但具体的行为也会因方法而异：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,,,,,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  map()会跳过空位置</span></span><br><span class="line">arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1 0</span></span><br><span class="line"><span class="comment">// 5 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join()视空位置为空字符串</span></span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// "1----5"</span></span><br></pre></td></tr></table></figure><p>由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用 undefined 值代替</p><h4 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h4><p>要取得或设置数组的值，需要使用中括号并提供相应值的数字索引</p><p>数组 length 属性的独特之处在于，它不是只读的, 通过修改 length 属性，可以从数组末尾删除或添加元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.length = <span class="number">2</span>; </span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "blue"]</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br><span class="line">colors[<span class="number">4</span>] = <span class="string">"pink"</span></span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">// ["red", "blue", empty × 2, "pink"</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>数组最多可以包含 4 294 967 295 个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误</p><h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><p>Array.isArray()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"是"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"不是"</span>)<span class="string">'</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h4><p>在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和 entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries() 返回索引/值对的迭代器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// keys() 返回索引的迭代器</span></span><br><span class="line">colors.keys(); <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">Array</span>.from(colors.keys()); <span class="comment">// [0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values() 返回值得迭代器</span></span><br><span class="line">colors.values(); <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">Array</span>.from(colors.values()); <span class="comment">// ["red", "blue", "green"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// entries() 返回键值对迭代器</span></span><br><span class="line">colors.entries(); <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">Array</span>.from(colors.entries()); <span class="comment">// [Array(2), Array(2), Array(2)]</span></span><br></pre></td></tr></table></figure><h4 id="复制和填充方法"><a href="#复制和填充方法" class="headerlink" title="复制和填充方法"></a>复制和填充方法</h4><p>copyWithin(target, start = 0, end = length) 有三个参数, 三个参数都必须是整数,  这个方法会改变原数组, <strong>下面我的总结说的参数都是传入的是Number类型的</strong></p><ul><li><p>只传一个参数 第二个参数默认为0 第三个参数默认为数组长度</p><p>首先该方法的第一个参数代表着从0到target 即 下标在<code>[0, target)</code>内的元素是不会发生改变的</p><p>第一个参数的绝对值小于数组长度时,  按照上面的说法</p><p>当绝对值大于或者等于数组长度时, 直接返回原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(); <span class="comment">// 什么都没传 返回本身</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>); <span class="comment">// [1, 1, 2, 3, 4] 取[0,1)保持不变, 变的就是[1, 5], 被复制的元素为[0, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">2</span>); <span class="comment">// [1, 2, 1, 2, 3]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">3</span>); <span class="comment">// [1, 2, 3, 1, 2]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">4</span>); <span class="comment">// [1, 2, 3, 4, 1]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">5</span>); <span class="comment">// [1, 2, 3, 4, 5] 返回本身</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">6</span>); <span class="comment">// [1, 2, 3, 4, 5] 返回本身 超出数组长度 不发生拷贝</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">-6</span>); <span class="comment">// [1, 2, 3, 4, 5] 返回本身 绝对值超出数组长度 不发生拷贝</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">-5</span>); <span class="comment">// [1, 2, 3, 4, 5] 返回本身</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">-4</span>); <span class="comment">// [1, 1, 2, 3, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">-3</span>); <span class="comment">// [1, 2, 1, 2, 3]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">-2</span>); <span class="comment">// [1, 2, 3, 1, 2]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">-1</span>); <span class="comment">// [1, 2, 3, 4, 1]</span></span><br></pre></td></tr></table></figure></li><li><p>只传两个参数</p><p>该方法的第二个参数<code>(我的理解)</code> 就是从原数组开始复制的起点下标</p><p>当第二个参数的绝对值大于或者等于数组长度时, 第二个参数会变成0</p><p>第二个参数绝对值小于数组长度时, 如果是负数 则复制的的开始下标为 <code>数组长度 + start</code>, 如果是正数 开始下标为 <code>start</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// [1, 1, 2, 3, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// [1, 4, 5, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">4</span>); <span class="comment">// [1, 5, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">5</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">6</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-6</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-5</span>); <span class="comment">// [1, 1, 2, 3, 4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-4</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-3</span>); <span class="comment">// [1, 3, 4, 5, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-2</span>); <span class="comment">// [1, 4, 5, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-1</span>); <span class="comment">// [1, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>三个参数都传</p><p>该方法的第三个参数 <code>(我的理解)</code> 就是从原数组开始复制的结束下标</p><p>当第一个参数和第二个参数对应的下标相同时, 无论第三个参数是啥, 返回的都是原数组</p><p>当第二个参数和第三个参数相等时, 返回的都是原数组</p><p>当第二个参数为正数 <code>(大于数组长度变成0)</code></p><ol><li><p>当第三个参数为正数时, </p><ol><li>如果第三个参数值大于数组长度则会变成数组长度</li><li>当 <code>end &gt; start</code>时 <code>复制的区域为[start, end)</code> </li><li><code>end - start</code>的值小于 <code>数组length - target</code>的值时 会把<code>[start, end)</code> 内复制  </li><li>当<code>end &lt;= start</code>时 返回原数组</li></ol></li><li><p>当第三个参数为负数</p><ol><li>如果第三个参数值绝对值大于数组长度则会变成数组长度</li><li>当 <code>数组length + end &gt; start</code>时, <code>复制的区域为[start, end + 数组length)</code> </li><li><code>lenghth + end - start</code>的值小于 <code>数组length - target</code>的值时 会把<code>[start, end + 数组length)</code> 内的值复制,</li><li>当<code>end + 数组length &lt;= start</code>时 返回原数组</li></ol></li></ol><p>当第二个参数为负数时<code>(绝对值大于数组长度变成0)</code></p><p>ps: <code>总结还有逻辑问题</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">3</span>, <span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// [1, 4, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>); <span class="comment">// [1, 4, 5, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// [1, 4, 5, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// [1, 4, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-6</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-5</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-4</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-3</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-2</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// [1, 4, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-2</span>, <span class="number">4</span>); <span class="comment">// [1, 4, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>传入的参数不是整数的时候</p><p>第一个参数被传入小数时, 都会被舍弃掉小数位  <strong>这里主要是如果是正小数行为同 <code>Math.floor</code>, 但是如果是负小数行为等同于 <code>Math.ceil</code></strong>, 但是当小数位数达到足够多的时候比如 <code>2.9999999999999999</code> 时 会被当做 <code>3</code> 而  <code>-3.9999999999999999</code> 会被当做 <code>-4</code> 我觉得可能和存储有关</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.1</span>); <span class="comment">// [1, 1, 2, 3 ,4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.9</span>); <span class="comment">// [1, 1, 2, 3 ,4]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-1.9</span>); <span class="comment">// [1, 2, 3, 4, 1]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-1.1</span>); <span class="comment">// [1, 2, 3, 4, 1]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">2.9999999999999999</span>); <span class="comment">// [1, 2, 3, 1, 2]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-3.9999999999999999</span>); <span class="comment">// [1, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>第二个参数也传入的是小数时, 行为同第一个参数, 变成整数 同传整数的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.1</span>, <span class="number">2.1</span>); <span class="comment">// [1, 3, 4, 5, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.1</span>, <span class="number">2.9</span>); <span class="comment">// [1, 3, 4, 5, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.1</span>, <span class="number">2.9999999999999999</span>); <span class="comment">// [1, 4, 5, 4, 5] </span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.1</span>, <span class="number">-2.9999999999999999</span>); <span class="comment">// [1, 3, 4, 5, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-2.9</span>); <span class="comment">// [1, 4, 5, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-2.1</span>); <span class="comment">// [1, 4, 5, 4, 5]</span></span><br></pre></td></tr></table></figure><p>第三个传的也是小数, 同上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.1</span>, <span class="number">2.9</span>, <span class="number">4.1</span>); <span class="comment">// [1, 3, 4, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.1</span>, <span class="number">2.9</span>, <span class="number">4.9999999999999999</span>); <span class="comment">// [1, 3, 4, 5, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.1</span>, <span class="number">2.9</span>, <span class="number">4.9</span>); <span class="comment">//  [1, 3, 4, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1.1</span>, <span class="number">-2.9</span>, <span class="number">-4.9999999999999999</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-3.9</span>, <span class="number">-1.1</span>); <span class="comment">// [1, 3, 4, 4, 5]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="number">-3.9</span>, <span class="number">-1.9</span>); <span class="comment">// [1, 3, 4, 4, 5]</span></span><br></pre></td></tr></table></figure></li><li><p>传入的字符串, 能通过 <code>parseInt</code>方法返回数字的 字符串能传入, 返回NaN的则按默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">1</span>, <span class="string">"1.9999999999999999xxx"</span>, <span class="number">4</span>); <span class="comment">// [1, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li></ul><p><code>fill()</code> 方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾, 负值索引从数组末尾开始计算, 也可以将负索引想象成数组长度加上它得到的一个正索引, 会改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">arr.fill(<span class="number">1</span>); <span class="comment">// [1, 1, 1, 1, 1]</span></span><br><span class="line"><span class="comment">// 下标大于3的 都会被填充</span></span><br><span class="line">arr.fill(<span class="number">6</span>, <span class="number">3</span>); <span class="comment">// [1, 1, 1, 6, 6]</span></span><br><span class="line">arr.fill(<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// [1, 1, 7, 7, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">arr.fill(&#123;<span class="attr">name</span>: <span class="string">"decade"</span>&#125;); <span class="comment">// [&#123;name: "decade"&#125;, &#123;name: "decade"&#125;, &#123;name: "decade"&#125;, &#123;name: "decade"&#125;, &#123;name: "decade"&#125;]</span></span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">"DECADE"</span>; <span class="comment">// [&#123;name: "DECADE"&#125;, &#123;name: "DECADE"&#125;, &#123;name: "DECADE"&#125;, &#123;name: "DECADE"&#125;, &#123;name: "DECADE"&#125;]</span></span><br></pre></td></tr></table></figure><p><code>fill</code> 填充对象, 将会都会指向同一个地址</p><h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><p><code>push()</code>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度,  <strong>改变原数组</strong></p><p><code>pop()</code>方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项  <strong>改变原数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr.push(<span class="string">"a"</span>); <span class="comment">// 1</span></span><br><span class="line">arr.push(<span class="string">"c"</span>); <span class="comment">// 2</span></span><br><span class="line">arr.pop(); <span class="comment">// "c"</span></span><br><span class="line">arr.push(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><p><code>shift()</code> 删除数组的第一项并返回它, 然后数组长度减 1   <strong>改变原数组</strong></p><p><code>unshift()</code> 在数组开头添加任意多个值，然后返回新的数组长度     <strong>改变原数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr.unshift(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// 4</span></span><br><span class="line">arr.unshift(<span class="string">"a"</span>); <span class="comment">// 5</span></span><br><span class="line">arr.shift(); <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure><h4 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h4><p><code>reverse()</code> 让数组内元素 倒过来  <strong>改变原数组</strong></p><p><code>sort()</code> 默认情况下，sort()会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，sort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序, 另外可以接收一个比较函数, 比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值  <strong>改变原数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span> ,<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"A"</span>];</span><br><span class="line">arr.reverse(); <span class="comment">// ["A", "b", "a", 5, 4, 3, 2, 1]</span></span><br><span class="line">arr.sort(); <span class="comment">// [1, 2, 3, 4, 5, "A", "a", "b"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line">arr1.sort(); <span class="comment">// [1, 10, 2, 20, 3, 30, 4, 40, 5, 50]</span></span><br><span class="line">arr1.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;); <span class="comment">//  [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]</span></span><br></pre></td></tr></table></figure><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><p><code>concat()</code>方法可以在现有数组全部元素基础上创建一个新数组如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.concat(<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();</span><br><span class="line"><span class="built_in">console</span>.log(arr === arr2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：<code>Symbol.isConcatSpreadable</code>。这个符号能够阻止 <code>concat()</code>打平参数数组。相反，把这个值设置为 true 可以强制打平类数组对象</p><p><code>slice()</code> 用于创建一个包含原有数组中一个或多个元素的新数组, 该方法接收一个或者两个参数, 开始位置, 结束位置, 只有一个参数的时候, 第二个参数默认为数组末尾, 如果参数为负数, 则用这个<code>负数+数组长度</code>转换为正的, 如果只有一个参数, 且负数的绝对值大于数组长度, 则会变成0, 同理第二个参数绝对值超过数组长度, 会变成数组长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colorArr = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"yellow"</span>, <span class="string">"pink"</span>, <span class="string">"blue"</span>, <span class="string">"black"</span>, <span class="string">"white"</span>];</span><br><span class="line">colorArr.slice(); <span class="comment">// ["red", "green", "yellow", "pink", "blue", "black", "white"]</span></span><br><span class="line">colorArr.slice(<span class="number">2</span>); <span class="comment">// ["yellow", "pink", "blue", "black", "white"]</span></span><br><span class="line">colorArr.slice(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// ["yellow", "pink"]</span></span><br></pre></td></tr></table></figure><p><code>splice()</code> 方法始终返回这样一个数组，它包含从数组中被删除的元素(如果没有删除元素，则返回空数组)  <strong>改变原数组</strong></p><ul><li>删除  需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素</li><li>插入  需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素</li><li>替换  splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> removeArr = arr.splice(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="built_in">console</span>.log(removeArr); <span class="comment">// [1];</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2, 3, 4]</span></span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="keyword">let</span> removedArr2 = arr.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(removedArr2); <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [7. 8, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h4 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h4><p>ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索</p><h5 id="按严格相等搜索"><a href="#按严格相等搜索" class="headerlink" title="按严格相等搜索"></a>按严格相等搜索</h5><p><code>indexOf()</code> 接收两个参数, 待查找的元素和检索开始的索引,  找到便返回元素的索引,否则返回<code>-1</code></p><p><code>lastIndexOf()</code> 接收两个参数, 待查找的元素和检索开始的索引, 找到便返回元素的索引,否则返回<code>-1</code></p><p><code>includes()</code>  接收一个参数, 待查找的元素, 找到返回 <code>true</code> 找不到 返回 <code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>];</span><br><span class="line">arr.indexOf(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">arr.indexOf(<span class="string">"1"</span>); <span class="comment">// -1</span></span><br><span class="line">arr.indexOf(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">arr.lastIndexOf(<span class="number">1</span>); <span class="comment">// 4</span></span><br><span class="line">arr.lastIndexOf(<span class="string">"-1"</span>); <span class="comment">// -1</span></span><br><span class="line">arr.lastIndexOf(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1</span></span><br><span class="line">arr.includes(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="string">"1"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h5><p>断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配</p><p><code>find()</code>和 <code>findIndex()</code>方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> item = arr.find(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> index = arr.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(index); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">item = arr.find((<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt; <span class="keyword">this</span>.count</span><br><span class="line">&#125;), &#123;<span class="attr">count</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// 2 箭头函数不行</span></span><br></pre></td></tr></table></figure><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><p>ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3个参数：数组元素、元素索引和数组本身</p><p><code>every()</code> 数组每一项传入函数,如果所有项都让函数返回<code>true</code>, 该方法返回<code>true</code> 否则返回 <code>false</code></p><p><code>filter()</code> 数组每一项传入函数, 返回使函数返回<code>true</code>的项拼装的数组</p><p><code>forEach()</code> 数组每一项传入函数, 没有返回值</p><p><code>map()</code> 数组每一项传入函数, 返回由每次函数调用的结果构成的数组</p><p><code>some()</code> 数组每一项传入函数, 只要有一项让函数返回 <code>true</code>, 该方法返回<code>true</code>, 否则返回 <code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> forEachResult = arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(forEachResult); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapResult = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(mapResult); <span class="comment">// [undefined, undefined, undefined, undefined, undefined] </span></span><br><span class="line">mapResult = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item ** <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(mapResult); <span class="comment">// [1, 4, 9, 16, 25] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> everyResult = arr.every(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// false  </span></span><br><span class="line">everyResult = arr.every(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filterResult = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(filterResult); <span class="comment">// [3, 4, 5]</span></span><br><span class="line">filterResult = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(filterResult); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someResult = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(someResult); <span class="comment">// true</span></span><br><span class="line">someResult = arr.some(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(someResult); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><p>ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项, 而 reduceRight()从最后一项开始遍历至第一项</p><p>这两个方法都接收两个参数, 第一个参数是一个函数, 函数的形参有四个(上一次归并值, 当前项, 当前项的索引, 数组本身), 第二个参数为归并起点的初始值, 如果没有传入第二个参数, 则默认数组的第一项为初始值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = arr.reduce(<span class="function">(<span class="params">prev, curr, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(prev, curr, index, arr);</span><br><span class="line">    <span class="keyword">return</span> prev + curr;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1 2 1 [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 3 3 2 [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 6 4 3 [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 10 5 4 [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">sum = arr.reduce(<span class="function">(<span class="params">prev, curr, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(prev, curr, index, arr);</span><br><span class="line">    <span class="keyword">return</span> prev + curr;</span><br><span class="line">&#125;, <span class="number">15</span>);</span><br><span class="line"><span class="comment">// 15 1 0 [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 16 2 1 [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 18 3 2 [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 21 4 3 [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">// 25 5 4 [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h3 id="定型数组"><a href="#定型数组" class="headerlink" title="定型数组"></a>定型数组</h3><p>定型数组（typed array）是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率, 实际上, JavaScript 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组</p><h4 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h4><p>Float32Array 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的预分配内存, ArrayBuffer 是所有定型数组及视图引用的基本单位ArrayBuffer()是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间, ArrayBuffer 一经创建就不能再调整大小。不过，可以使用 slice()复制其全部或部分到一个新实例中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>); <span class="comment">// 分配16个字节</span></span><br><span class="line"><span class="keyword">let</span> buffer1 = buffer.slice(<span class="number">2</span>); <span class="comment">// 14个字节</span></span><br></pre></td></tr></table></figure><p>ArrayBuffer 某种程度上类似于 C++的 malloc()，但也有几个明显的区别</p><ul><li><code>malloc()</code>在分配失败时会返回一个 null 指针,  <code>ArrayBuffer</code> 在分配失败时会抛出错误</li><li><code>malloc()</code>可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制, <code>ArrayBuffer</code>分配的内存不能超过 <code>Number.MAX_SAFE_INTEGER（2^53 - 1）</code>字节</li><li><code>malloc()</code>调用成功不会初始化实际的地址, 声明 <code>ArrayBuffer</code> 则会将所有二进制位初始化为 0</li><li>1malloc()1分配的堆内存除非调用 free()或程序退出，否则系统不能再使用, 而通过声明<code>ArrayBuffer</code> 分配的堆内存可以被当成垃圾回收，不用手动释放</li></ul><p>不能仅通过对 ArrayBuffer 的引用就读取或写入其内容。要读取或写入 ArrayBuffer，就必须通过视图, 视图有不同的类型，但引用的都是 ArrayBuffer 中存储的二进制数据</p><h4 id="DataView"><a href="#DataView" class="headerlink" title="DataView"></a>DataView</h4><p>第一种允许你读写 ArrayBuffer 的视图是 DataView, 这个视图专为文件 I/O 和网络 I/O 设计，其API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些, DataView 对缓冲内容没有任何预设，也不能迭代</p><p>必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或部分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataView 默认使用整个 ArrayBuffer </span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer); <span class="comment">// buffer: ArrayBuffer(16) byteLength: 16  byteOffset: 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(fullDataView.byteOffset); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(fullDataView.byteLength); <span class="comment">// 16 </span></span><br><span class="line"><span class="built_in">console</span>.log(fullDataView.buffer === buffer); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数接收一个可选的字节偏移量和字节长度</span></span><br><span class="line"><span class="comment">// byteOffset=0 表示视图从缓冲起点开始</span></span><br><span class="line"><span class="comment">// byteLength=8 限制视图为前 8 个字节</span></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">0</span>, <span class="number">8</span>); </span><br><span class="line"><span class="built_in">console</span>.log(firstHalfDataView.byteOffset); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(firstHalfDataView.byteLength); <span class="comment">// 8 </span></span><br><span class="line"><span class="built_in">console</span>.log(firstHalfDataView.buffer === buffer); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不指定，则 DataView 会使用剩余的缓冲</span></span><br><span class="line"><span class="comment">// byteOffset=8 表示视图从缓冲的第 9 个字节开始</span></span><br><span class="line"><span class="comment">// byteLength 未指定，默认为剩余缓冲</span></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">8</span>); </span><br><span class="line"><span class="built_in">console</span>.log(secondHalfDataView.byteOffset); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">console</span>.log(secondHalfDataView.byteLength); <span class="comment">// 8 </span></span><br><span class="line"><span class="built_in">console</span>.log(secondHalfDataView.buffer === buffer); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要通过 DataView 读取缓冲，还需要几个组件</p><ul><li>首先是要读或写的字节偏移量, 可以看成 DataView 中的某种””地址”</li><li>DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换</li><li>最后是内存中值的字节序。默认为大端字节序</li></ul><h5 id="ElementType"><a href="#ElementType" class="headerlink" title="ElementType"></a>ElementType</h5><p>DataView 对存储在缓冲内的数据类型没有预设, 它暴露的 API 强制开发者在读、写时指定一个ElementType，然后 DataView 就会忠实地为读、写而完成相应的转换</p><table><thead><tr><th align="center">ElementType</th><th align="center">字节</th><th align="center">说明</th><th align="center">等价C类型</th><th align="center">值的范围</th></tr></thead><tbody><tr><td align="center">Int8</td><td align="center">1</td><td align="center">8 位有符号整数</td><td align="center">signed char</td><td align="center">-128~127</td></tr><tr><td align="center">Uint8</td><td align="center">1</td><td align="center">8 位无符号整数</td><td align="center">unsigned char</td><td align="center">0~255</td></tr><tr><td align="center">Int16</td><td align="center">2</td><td align="center">16 位有符号整数</td><td align="center">short</td><td align="center">-32 768~32 767</td></tr><tr><td align="center">Uint16</td><td align="center">2</td><td align="center">16 位无符号整数</td><td align="center">unsigned short</td><td align="center">0~65 535</td></tr><tr><td align="center">Int32</td><td align="center">4</td><td align="center">32 位有符号整数</td><td align="center">int</td><td align="center">-2 147 483 648~2 147 483 647</td></tr><tr><td align="center">Uint32</td><td align="center">4</td><td align="center">32 位无符号整数</td><td align="center">unsigned int</td><td align="center">0~4 294 967 295</td></tr><tr><td align="center">Float32</td><td align="center">4</td><td align="center">32 位 IEEE-754 浮点数</td><td align="center">float</td><td align="center">-3.4e+38~+3.4e+38</td></tr><tr><td align="center">Float64</td><td align="center">8</td><td align="center">64 位 IEEE-754 浮点数</td><td align="center">double</td><td align="center">-1.7e+308~+1.7e+308</td></tr></tbody></table><p>DataView 为上表中的每种类型都暴露了 get 和 set 方法，这些方法使用 byteOffset (字节偏移量) 定位要读取或写入值的位置, 类型是可以互换使用的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buff = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[Int8Array]]: Int8Array(16) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">[[Int16Array]]: Int16Array(8) [0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">[[Int32Array]]: Int32Array(4) [0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">[[Uint8Array]]: Uint8Array(16) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">byteLength: 16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buff);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">buffer: ArrayBuffer(16)</span></span><br><span class="line"><span class="comment">byteLength: 16</span></span><br><span class="line"><span class="comment">byteOffset: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明整个缓冲确实所有二进制位都是 0 </span></span><br><span class="line"><span class="comment">// 检查第一个和第二个字符</span></span><br><span class="line">view.getInt8(<span class="number">0</span>); <span class="comment">// 0 </span></span><br><span class="line">view.getInt8(<span class="number">1</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 检查整个缓冲</span></span><br><span class="line">view.getInt16(<span class="number">0</span>); <span class="comment">// 0 </span></span><br><span class="line"><span class="comment">// 将整个缓冲都设置为 1 </span></span><br><span class="line"><span class="comment">// 255 的二进制表示是 11111111（2^8 - 1）</span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">255</span>); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[Int8Array]]: Int8Array(16) [-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">[[Int16Array]]: Int16Array(8) [255, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">[[Int32Array]]: Int32Array(4) [255, 0, 0, 0]</span></span><br><span class="line"><span class="comment">[[Uint8Array]]: Uint8Array(16) [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// DataView 会自动将数据转换为特定的 ElementType </span></span><br><span class="line"><span class="comment">// 255 的十六进制表示是 0xFF </span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0xFF</span>); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[Int8Array]]: Int8Array(16) [-1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">[[Int16Array]]: Int16Array(8) [-1, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">[[Int32Array]]: Int32Array(4) [65535, 0, 0, 0]</span></span><br><span class="line"><span class="comment">[[Uint8Array]]: Uint8Array(16) [255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 现在，缓冲里都是 1 了</span></span><br><span class="line"><span class="comment">// 如果把它当成二补数的有符号整数，则应该是-1 </span></span><br><span class="line">view.getInt16(<span class="number">0</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h5 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h5><p>指的是计算系统维护的一种字节顺序的约定。DataView 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。</p><p>DataView 的所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 true 即可启用小端字节序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个 DataView </span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">2</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 填充缓冲，让第一位和最后一位都是 1 </span></span><br><span class="line">view.setUint8(<span class="number">0</span>, <span class="number">0x80</span>); <span class="comment">// 设置最左边的位等于 1 </span></span><br><span class="line">view.setUint8(<span class="number">1</span>, <span class="number">0x01</span>); <span class="comment">// 设置最右边的位等于 1 </span></span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x8 0x0 0x0 0x1 </span></span><br><span class="line"><span class="comment">// 1000 0000 0000 0001 </span></span><br><span class="line"><span class="comment">// 按大端字节序读取 Uint16 </span></span><br><span class="line"><span class="comment">// 0x80 是高字节，0x01 是低字节</span></span><br><span class="line"><span class="comment">// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769 </span></span><br><span class="line">view.getUint16(<span class="number">0</span>); <span class="comment">// 32769 </span></span><br><span class="line"><span class="comment">// 按小端字节序读取 Uint16 </span></span><br><span class="line"><span class="comment">// 0x01 是高字节，0x80 是低字节</span></span><br><span class="line"><span class="comment">// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384 </span></span><br><span class="line">view.getUint16(<span class="number">0</span>, <span class="literal">true</span>); <span class="comment">// 384 </span></span><br><span class="line"><span class="comment">// 按大端字节序写入 Uint16 </span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0004</span>); </span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x0 0x0 0x4 </span></span><br><span class="line"><span class="comment">// 0000 0000 0000 0100 </span></span><br><span class="line">view.getUint8(<span class="number">0</span>); <span class="comment">// 0 </span></span><br><span class="line">view.getUint8(<span class="number">1</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="comment">// 按小端字节序写入 Uint16 </span></span><br><span class="line">view.setUint16(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>); </span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0 0x2 0x0 0x0 </span></span><br><span class="line"><span class="comment">// 0000 0010 0000 0000 </span></span><br><span class="line">view.getUint8(<span class="number">0</span>); <span class="comment">// 2 </span></span><br><span class="line">view.getUint8(<span class="number">1</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h5 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h5><p>DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">6</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf); </span><br><span class="line"><span class="comment">// 尝试读取部分超出缓冲范围的值</span></span><br><span class="line">view.getInt32(<span class="number">4</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.getInt32(<span class="number">8</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.getInt32(<span class="number">-1</span>); </span><br><span class="line"><span class="comment">// RangeError </span></span><br><span class="line"><span class="comment">// 尝试写入超出缓冲范围的值</span></span><br><span class="line">view.setInt32(<span class="number">4</span>, <span class="number">123</span>); </span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p>DataView 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则抛出错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buf); </span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="number">1.5</span>); </span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 1 </span></span><br><span class="line">view.setInt8(<span class="number">0</span>, [<span class="number">4</span>]); </span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 4 </span></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="string">'f'</span>); </span><br><span class="line">alert(view.getInt8(<span class="number">0</span>)); <span class="comment">// 0 </span></span><br><span class="line">view.setInt8(<span class="number">0</span>, <span class="built_in">Symbol</span>()); </span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 是一种新的集合类型，为这门语言带来了真正的键/值存储机制</p><h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><p>使用 new 关键字和 Map 构造函数可以创建一个空映射</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空映射</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想在创建的同时初始化实例，可以给 Map 构造函数传入一个可迭代对象，需要包含键/值对数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用嵌套数组初始化映射</span></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>, <span class="string">"decade"</span>], [<span class="string">"age"</span>, <span class="number">20</span>], [<span class="string">"like"</span>, <span class="string">"code"</span>]]);</span><br><span class="line">map1.size; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义迭代器初始化映射</span></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> [<span class="string">"name"</span>, <span class="string">"decade"</span>];</span><br><span class="line">        <span class="keyword">yield</span> [<span class="string">"age"</span>, <span class="number">20</span>];</span><br><span class="line">        <span class="keyword">yield</span> [<span class="string">"like"</span>, <span class="string">"code"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">map2.size; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射期待的键/值对，无论是否提供</span></span><br><span class="line"><span class="keyword">const</span> map3 = <span class="keyword">new</span> <span class="built_in">Map</span>([]);</span><br><span class="line">map3.has(<span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line">map3.get(<span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化之后，可以使用 set()方法再添加键/值对。另外，可以使用 get()和 has()进行查询，可以通过 size 属性获取映射中的键/值对的数量，还可以使用 delete()和 clear()删除值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map4 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map4.has(<span class="string">"name"</span>); <span class="comment">// false</span></span><br><span class="line">map4.has(<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line">map4.delete(<span class="string">"age"</span>); <span class="comment">// false</span></span><br><span class="line">map4.size; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">map4.set(<span class="string">"name"</span>, <span class="string">"decade"</span>).set(<span class="string">"age"</span>, <span class="number">20</span>);</span><br><span class="line">map4.has(<span class="string">"name"</span>); <span class="comment">// true;</span></span><br><span class="line">map4.get(<span class="string">"age"</span>); <span class="comment">// 20</span></span><br><span class="line">map4.size; <span class="comment">// 2</span></span><br><span class="line">map4.delete(<span class="string">"name"</span>); <span class="comment">// true</span></span><br><span class="line">map4.size; <span class="comment">// 1</span></span><br><span class="line">map4.clear(); </span><br><span class="line">map4.size; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用任何 JavaScript 数据类型作为键, Map 内部使用 SameValueZero 比较操作 基本上相当于使用严格对象相等的标准来检查键的匹配性, 与 Object 类似，映射的值是没有限制的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> functionKey = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectKey = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"></span><br><span class="line">m.set(functionKey, <span class="string">"functionValue"</span>); </span><br><span class="line">m.set(symbolKey, <span class="string">"symbolValue"</span>); </span><br><span class="line">m.set(objectKey, <span class="string">"objectValue"</span>); </span><br><span class="line"></span><br><span class="line">m.get(functionKey); <span class="comment">// functionValue </span></span><br><span class="line">m.get(symbolKey); <span class="comment">// symbolValue </span></span><br><span class="line">m.get(objectKey); <span class="comment">// objectValue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址不一样</span></span><br><span class="line">m.get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// undefiend;</span></span><br></pre></td></tr></table></figure><p>与严格相等一样，在映射中用作键和值的对象及其他“集合”类型，在自己的内容或属性被修改时仍然保持不变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> objKey = &#123;&#125;, </span><br><span class="line">      objVal = &#123;&#125;, </span><br><span class="line">      arrKey = [], </span><br><span class="line">      arrVal = []; </span><br><span class="line">m.set(objKey, objVal); </span><br><span class="line">m.set(arrKey, arrVal); </span><br><span class="line">objKey.foo = <span class="string">"foo"</span>; </span><br><span class="line">objVal.bar = <span class="string">"bar"</span>; </span><br><span class="line">arrKey.push(<span class="string">"foo"</span>); </span><br><span class="line">arrVal.push(<span class="string">"bar"</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Map(2) &#123;&#123;…&#125; =&gt; &#123;…&#125;, Array(1) =&gt; Array(1)&#125;</span></span><br><span class="line"><span class="comment">0: &#123;Object =&gt; Object&#125;</span></span><br><span class="line"><span class="comment">key: &#123;foo: "foo"&#125;</span></span><br><span class="line"><span class="comment">value: &#123;bar: "bar"&#125;</span></span><br><span class="line"><span class="comment">1: &#123;Array(1) =&gt; Array(1)&#125;</span></span><br><span class="line"><span class="comment">key: ["foo"]</span></span><br><span class="line"><span class="comment">value: ["bar"]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>SameValueZero 比较也可能导致意想不到的冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line"><span class="keyword">const</span> a = <span class="number">0</span>/<span class="string">""</span>, <span class="comment">// NaN </span></span><br><span class="line">      b = <span class="number">0</span>/<span class="string">""</span>, <span class="comment">// NaN </span></span><br><span class="line">      pz = +<span class="number">0</span>,</span><br><span class="line">      nz = <span class="number">-0</span>;</span><br><span class="line">a === b; <span class="comment">// false</span></span><br><span class="line">pz === nz; <span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line">m.set(a, <span class="string">"foo"</span>); </span><br><span class="line">m.set(pz, <span class="string">"bar"</span>);</span><br><span class="line"></span><br><span class="line">m.get(b); <span class="comment">// foo</span></span><br><span class="line">m.get(nz); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><h4 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h4><p>与 Object 类型的一个主要差异是，Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作</p><p>映射实例可以提供一个迭代器(Iterator), 能以插入顺序生成[key, value]形式的数组; 可以通过 entries()方法 (或者 Symbol.iterator 属性，它引用 entries()) 取得这个迭代器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">"name"</span>, <span class="string">"decade"</span>],</span><br><span class="line">    [<span class="string">"age"</span>, <span class="number">20</span>],</span><br><span class="line">    [<span class="string">"like"</span>, <span class="string">"code"</span>]</span><br><span class="line">]);</span><br><span class="line">map.entries === map[<span class="built_in">Symbol</span>.iterator]; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([...map]); <span class="comment">// [["name", "decade"], ["age", 20], ["like", "code"]]</span></span><br></pre></td></tr></table></figure><h4 id="选择-Object-还是-Map"><a href="#选择-Object-还是-Map" class="headerlink" title="选择 Object 还是 Map"></a>选择 <strong>Object</strong> 还是 Map</h4><p>对于多数 Web 开发任务来说，选择 Object 还是 Map 只是个人偏好问题，影响不大。不过，对于在乎内存和性能的开发者来说，对象和映射之间确实存在显著的差别</p><ol><li><p>内存占用</p><p>Object 和 Map 的工程级实现在不同浏览器间存在明显差异, 但存储单个键/值对所占用的内存数量都会随键的数量线性增加. 批量添加或删除键/值对则取决于各浏览器对该类型内存分配的工程实现. 不同浏览器的情况不同, 但给定固定大小的内存, Map 大约可以比 Object 多存储 50%的键/值对</p></li><li><p>插入性能</p><p>Object 和 Map 中插入新键/值对的消耗大致相当, 不过插入 Map 在所有浏览器中一般会稍微快一点儿. 对这两个类型来说, 插入速度并不会随着键/值对数量而线性增加. 如果代码涉及大量插入操作, 那么显然 Map 的性能更佳</p></li><li><p>查找速度</p><p>与插入不同, 从大型 Object 和 Map 中查找键/值对的性能差异极小, 但如果只包含少量键/值对, 则 Object 有时候速度更快. 在把 Object 当成数组使用的情况下(比如使用连续整数作为属性), 浏览器引擎可以进行优化, 在内存中使用更高效的布局. 这对 Map 来说是不可能的. 对这两个类型而言, 查找速度不会随着键/值对数量增加而线性增加. 如果代码涉及大量查找操作, 那么某些情况下可能选择 Object 更好一些</p></li><li><p>删除性能</p><p>使用 delete 删除 Object 属性的性能一直以来饱受诟病, 目前在很多浏览器中仍然如此. 为此, 出现了一些伪删除对象属性的操作, 包括把属性值设置为 undefined 或 null. 但很多时候, 这都是一种讨厌的或不适宜的折中. 而对大多数浏览器引擎来说, Map 的 delete()操作都比插入和查找更快. 如果代码涉及大量删除操作, 那么毫无疑问应该选择 Map</p></li></ol><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>ECMAScript 6 新增的 <strong>“弱映射”</strong> (WeakMap)是一种新的集合类型, 为这门语言带来了增强的键/值对存储机制. WeakMap 是 Map 的”兄弟”类型, 其 API 也是 Map 的子集. WeakMap 中的”weak”(弱), 描述的是 JavaScript 垃圾回收程序对待”弱映射”中键的方式</p><h4 id="基本API-1"><a href="#基本API-1" class="headerlink" title="基本API"></a>基本API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 new 关键字实例化一个空的 WeakMap</span></span><br><span class="line"><span class="keyword">const</span> weakMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱映射中的键只能是 Object 或者继承自 Object 的类型, 尝试使用非对象设置键会抛出TypeError 值的类型没有限制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想在初始化时填充弱映射, 则构造函数可以接收一个可迭代对象, 其中需要包含键/值对数组. 可迭代对象中的每个键/值都会按照迭代顺序插入新实例中</span></span><br><span class="line"><span class="keyword">const</span> key1 = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">      key2 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;,</span><br><span class="line">      key3 = &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([ </span><br><span class="line">    [key1, <span class="string">"val1"</span>], </span><br><span class="line">    [key2, <span class="string">"val2"</span>], </span><br><span class="line">    [key3, <span class="string">"val3"</span>] </span><br><span class="line">]);</span><br><span class="line">wm1.get(key1); <span class="comment">// val1</span></span><br><span class="line">wm1.get(key2); <span class="comment">// val2</span></span><br><span class="line">wm1.get(key3); <span class="comment">// val3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([ </span><br><span class="line">    [key1, <span class="string">"val1"</span>], </span><br><span class="line">    [<span class="string">"BADKEY"</span>, <span class="string">"val2"</span>], </span><br><span class="line">    [key3, <span class="string">"val3"</span>] </span><br><span class="line">]); <span class="comment">// TypeError: Invalid value used as WeakMap key </span></span><br><span class="line"><span class="keyword">typeof</span> wm2; <span class="comment">// ReferenceError: wm2 is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始值可以先包装成对象再用作键</span></span><br><span class="line"><span class="keyword">const</span> stringKey = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"key1"</span>); </span><br><span class="line"><span class="keyword">const</span> wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([ </span><br><span class="line">    stringKey, <span class="string">"val1"</span> </span><br><span class="line">]);</span><br><span class="line">wm3.get(stringKey); <span class="comment">// val1</span></span><br></pre></td></tr></table></figure><p>初始化之后可以使用 set()再添加键/值对, 可以使用 get()和 has()查询,还可以使用 delete()删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key1 = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">      key2 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;;</span><br><span class="line">wm.has(key1); <span class="comment">// false;</span></span><br><span class="line">wm.get(key1); <span class="comment">// undefined</span></span><br><span class="line">wm.set(key1, <span class="string">"val1"</span>).set(key2, <span class="string">"val2"</span>);</span><br><span class="line">wm.has(key1); <span class="comment">// true</span></span><br><span class="line">wm.get(key2); <span class="comment">// val2</span></span><br><span class="line">wm.delete(key1); <span class="comment">// true</span></span><br><span class="line">wm.has(key1); <span class="comment">// false</span></span><br><span class="line">wm.has(key2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="弱键"><a href="#弱键" class="headerlink" title="弱键"></a>弱键</h4><p>WeakMap 中 “weak” 表示弱映射的键是 “弱弱地拿着” 的. 意思就是, 这些键不属于正式的引用, 不会阻止垃圾回收. 但要注意的是, 弱映射中值的引用可不是”弱弱地拿着”的, 只要键存在, 键/值对就会存在于映射中, 并被当作对值的引用, 因此就不会被当作垃圾回收</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">wm.set(&#123;&#125;, <span class="string">"val"</span>);</span><br><span class="line"><span class="comment">// &#123;&#125; 没有在其他地方使用到, 执行完之后 会被当做垃圾回收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = &#123; </span><br><span class="line">    key: &#123;&#125; </span><br><span class="line">&#125;; </span><br><span class="line">wm.set(container.key, <span class="string">"val"</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeReference</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    container.key = <span class="literal">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// container 对象维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标, 不过, 如果调用了 removeReference(), 就会摧毁键对象的最后一个引用, 垃圾回收程序就可以把这个键/值对清理掉</span></span><br></pre></td></tr></table></figure><h4 id="不可迭代键"><a href="#不可迭代键" class="headerlink" title="不可迭代键"></a>不可迭代键</h4><p>因为 WeakMap 中的键/值对任何时候都可能被销毁, 所以没必要提供迭代其键/值对的能力, 当然, 也用不着像 clear()这样一次性销毁所有键/值的方法, WeakMap 确实没有这个方法。因为不可能迭代, 所以也不可能在不知道对象引用的情况下从弱映射中取得值. 即便代码可以访问 WeakMap 实,  也没办法看到其中的内容WeakMap 实例之所以限制只能用对象作为键, 是为了保证只有通过键对象的引用才能取得值, 如果允许原始值, 那就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的清空一个weakmap</span></span><br><span class="line">weakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); <span class="comment">// 再重新初始化一下就好了</span></span><br></pre></td></tr></table></figure><h4 id="使用弱映射"><a href="#使用弱映射" class="headerlink" title="使用弱映射"></a>使用弱映射</h4><ol><li><p>私有变量</p><p>弱映射造就了在 JavaScript 中实现真正私有变量的一种新方式。前提很明确：私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.idProperty = <span class="built_in">Symbol</span>(<span class="string">'id'</span>);</span><br><span class="line">            <span class="keyword">this</span>.setId(id);</span><br><span class="line">        &#125;</span><br><span class="line">        setPrivate(property, value) &#123; </span><br><span class="line">            <span class="keyword">const</span> privateMembers = wm.get(<span class="keyword">this</span>) || &#123;&#125;; </span><br><span class="line">            privateMembers[property] = value; </span><br><span class="line">            wm.set(<span class="keyword">this</span>, privateMembers); </span><br><span class="line">        &#125; </span><br><span class="line">        getPrivate(property) &#123; </span><br><span class="line">            <span class="keyword">return</span> wm.get(<span class="keyword">this</span>)[property]; </span><br><span class="line">        &#125; </span><br><span class="line">        setId(id) &#123; </span><br><span class="line">            <span class="keyword">this</span>.setPrivate(<span class="keyword">this</span>.idProperty, id); </span><br><span class="line">        &#125;</span><br><span class="line">        getId(id) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getPrivate(<span class="keyword">this</span>.idProperty); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> User;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User(<span class="number">123</span>);</span><br><span class="line">user.getId(); <span class="comment">// 123</span></span><br><span class="line">user.setId(<span class="number">456</span>);</span><br><span class="line">user.getId(); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure></li><li><p>DOM节点元数据</p><p>因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="built_in">document</span>.querySelector(<span class="string">"#login"</span>);</span><br><span class="line">vm.set(loginButton, &#123; <span class="attr">disabled</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>ECMAScript 6 新增的 Set 是一种新集合类型，为这门语言带来集合数据结构, Set 在很多方面都像是加强的 Map, 这是因为它们的大多数 API 和行为都是共有的</p><h4 id="基本API-2"><a href="#基本API-2" class="headerlink" title="基本API"></a>基本API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 new 关键字和 Set 构造函数可以创建一个空集合</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line">// 如果想在创建的同时初始化实例，则可以给 Set 构造函数传入一个可迭代对象, 其中需要包含插入到新集合实例中的元素</span><br><span class="line">// 使用数组初始化集合</span><br><span class="line">const set1 = new Set(["val1", "val2", "val3"]);</span><br><span class="line">set1.size; // 3</span><br><span class="line"></span><br><span class="line">// 使用自定义迭代器初始化集合</span><br><span class="line">const set2 = new Set(&#123; </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"val1"</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"val2"</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"val3"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br><span class="line">set2.size; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>初始化之后, 可以使用 add()增加值, 使用 has()查询, 通过 size 取得元素数量, 以及使用 delete()和 clear()删除元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.has("name"); // false</span><br><span class="line"><span class="keyword">set</span>.delete("name"); // false</span><br><span class="line"><span class="keyword">set</span>.size; // 0</span><br><span class="line"><span class="keyword">set</span>.add(1).add(2).add(3).add(4);</span><br><span class="line"><span class="keyword">set</span>.size; // 4</span><br><span class="line"><span class="keyword">set</span>.has(1); // true</span><br><span class="line"><span class="keyword">set</span>.delete(1); // true</span><br><span class="line"><span class="keyword">set</span>.size; // 3</span><br><span class="line"><span class="keyword">set</span>.clear(); </span><br><span class="line"><span class="keyword">set</span>.size; // 0</span><br></pre></td></tr></table></figure><p>与 Map 类似，Set 可以包含任何 JavaScript 数据类型作为值, 集合也使用 SameValueZero 操作基本上相当于使用严格对象相等的标准来检查值的匹配性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set(); </span><br><span class="line"></span><br><span class="line">const functionVal = function() &#123;&#125;; </span><br><span class="line"><span class="keyword">const</span> symbolVal = <span class="built_in">Symbol</span>(); </span><br><span class="line"><span class="keyword">const</span> objectVal = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(functionVal).add(symbolVal).add(objectVal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.has(function() &#123;&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="顺序与迭代-1"><a href="#顺序与迭代-1" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h4><p>Set 会维护值插入时的顺序，因此支持按顺序迭代</p><p>集合实例可以提供一个迭代器(Iterator), 能以插入顺序生成集合内容。可以通过 values()方法及其别名方法 keys() (或者 Symbol.iterator 属性, 它引用 values())取得这个迭代器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set(["val1", "val2", "val3"]);</span><br><span class="line"><span class="keyword">set</span>.values === <span class="keyword">set</span>[Symbol.iterator]; // true</span><br><span class="line"><span class="keyword">set</span>.keys === <span class="keyword">set</span>[Symbol.iterator]; // true</span><br><span class="line"></span><br><span class="line">let arr = [...<span class="keyword">set</span>]; // ["val1", "val2", "val3"]</span><br></pre></td></tr></table></figure><h4 id="定义正式集合操作"><a href="#定义正式集合操作" class="headerlink" title="定义正式集合操作"></a>定义正式集合操作</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookSet</span> <span class="title">extend</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">    union(...sets) &#123; </span><br><span class="line">        <span class="keyword">return</span> BookSet.union(<span class="keyword">this</span>, ...sets) </span><br><span class="line"> &#125; </span><br><span class="line"> intersection(...sets) &#123; </span><br><span class="line"> <span class="keyword">return</span> BookSet.intersection(<span class="keyword">this</span>, ...sets); </span><br><span class="line"> &#125; </span><br><span class="line"> difference(<span class="keyword">set</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> BookSet.difference(<span class="keyword">this</span>, <span class="keyword">set</span>); </span><br><span class="line"> &#125; </span><br><span class="line"> symmetricDifference(<span class="keyword">set</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> BookSet.symmetricDifference(<span class="keyword">this</span>, <span class="keyword">set</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> cartesianProduct(<span class="keyword">set</span>) &#123; </span><br><span class="line"> <span class="keyword">return</span> BookSet.cartesianProduct(<span class="keyword">this</span>, <span class="keyword">set</span>); </span><br><span class="line"> &#125;</span><br><span class="line"> powerSet() &#123; </span><br><span class="line"> <span class="keyword">return</span> BookSet.powerSet(<span class="keyword">this</span>); </span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// 返回两个或者多个集合的并集</span></span><br><span class="line">    <span class="keyword">static</span> union(a, ...bSets) &#123; </span><br><span class="line">        <span class="keyword">const</span> unionSet = <span class="keyword">new</span> BookSet(a); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123; </span><br><span class="line">                unionSet.add(bValue); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回两个或者多个的交集</span></span><br><span class="line">    <span class="keyword">static</span> intersection(a, ...bSets) &#123; </span><br><span class="line">        <span class="keyword">const</span> intersectionSet = <span class="keyword">new</span> BookSet(a); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> intersectionSet) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> b <span class="keyword">of</span> bSets) &#123; </span><br><span class="line">                <span class="keyword">if</span> (!b.has(aValue)) &#123; </span><br><span class="line">                    intersectionSet.delete(aValue); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersectionSet; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回两个集合的差集</span></span><br><span class="line">    <span class="keyword">static</span> difference(a, b) &#123; </span><br><span class="line">        <span class="keyword">const</span> differenceSet = <span class="keyword">new</span> XSet(a); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123; </span><br><span class="line">            <span class="keyword">if</span> (a.has(bValue)) &#123; </span><br><span class="line">                differenceSet.delete(bValue); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> differenceSet; </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 返回两个集合的对称差集</span></span><br><span class="line">    <span class="keyword">static</span> symmetricDifference(a, b) &#123; </span><br><span class="line">        <span class="comment">// 按照定义，对称差集可以表达为</span></span><br><span class="line">        <span class="keyword">return</span> a.union(b).difference(a.intersection(b)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回两个集合（数组对形式）的笛卡儿积</span></span><br><span class="line"> <span class="comment">// 必须返回数组集合，因为笛卡儿积可能包含相同值的对</span></span><br><span class="line"> <span class="keyword">static</span> cartesianProduct(a, b) &#123; </span><br><span class="line">        <span class="keyword">const</span> cartesianProductSet = <span class="keyword">new</span> XSet(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> bValue <span class="keyword">of</span> b) &#123; </span><br><span class="line">                cartesianProductSet.add([aValue, bValue]); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> cartesianProductSet; </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 返回一个集合的幂集</span></span><br><span class="line"> <span class="keyword">static</span> powerSet(a) &#123; </span><br><span class="line"> <span class="keyword">const</span> powerSet = <span class="keyword">new</span> XSet().add(<span class="keyword">new</span> XSet()); </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> aValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">set</span> of new XSet(powerSet)) &#123; </span><br><span class="line">            powerSet.add(<span class="keyword">new</span> XSet(<span class="keyword">set</span>).add(aValue)); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">        return powerSet; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>ECMAScript 6 新增的”弱集合”(WeakSet)是一种新的集合类型, 为这门语言带来了集合数据结构, WeakSet 是 Set 的”兄弟”类型, 其 API 也是 Set 的子集, WeakSet 中的”weak”(弱), 描述的是 JavaScript 垃圾回收程序对待”弱集合”中值的方式</p><h4 id="基本API-3"><a href="#基本API-3" class="headerlink" title="基本API"></a>基本API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 new 关键字实例化一个空的 WeakSet</span></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱集合中的值只能是 Object 或者继承自 Object 的类型，尝试使用非对象设置值会抛出 TypeError。</span></span><br><span class="line"><span class="comment">// 如果想在初始化时填充弱集合，则构造函数可以接收一个可迭代对象，其中需要包含有效的值, 可迭代对象中的每个值都会按照迭代顺序插入到新实例中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> val1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;, </span><br><span class="line">      val2 = &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;, </span><br><span class="line">      val3 = &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 使用数组初始化弱集合</span></span><br><span class="line"><span class="keyword">const</span> ws1 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, val2, val3]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">// 只要有一个值无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="keyword">const</span> ws2 = <span class="keyword">new</span> <span class="built_in">WeakSet</span>([val1, <span class="string">"BADVAL"</span>, val3]); </span><br><span class="line"><span class="comment">// TypeError: Invalid value used in WeakSet </span></span><br><span class="line"><span class="keyword">typeof</span> ws2; </span><br><span class="line"><span class="comment">// ReferenceError: ws2 is not defined</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版-第五章-笔记</title>
    <link href="http://blog.decade.run/2020/11/19/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2020/11/19/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-19T07:42:39.000Z</published>
    <updated>2020-12-22T05:07:06.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>​     ECMAScript 的 Date 类型参考了 Java 早期版本中的 java.util.Date。为此，Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间 1970 年 1 月 1 日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285 616 年的日期</p><p>要创建日期对象，就使用 new 操作符来调用 Date 构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 不传参数, 默认创建当前时间的日期</span></span><br></pre></td></tr></table></figure><p>要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX 纪元 1970 年 1 月 1 日午夜之后的毫秒数）。ECMAScript为此提供了两个辅助方法：Date.parse()和 Date.UTC()</p><ul><li>“月/日/年”，如”5/23/2019”</li><li>“月名 日, 年”，如”May 23, 2019”</li><li>“周几 月名 日 年 时:分:秒 时区”，如”Tue May 23 2019 00:00:00 GMT-0700”</li><li>ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容 ES5 的实现)</li></ul><p>如果传给 Date.parse()的字符串并不表示日期，则该方法会返回 NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()</p><p>Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。传给 Date.UTC()的参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1 ~ 31）、时（0 ~ 23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> year = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure><p>与 Date.parse()一样，Date.UTC()也会被 Date 构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是 GMT 日期</p><p>ECMAScript 还提供了 Date.now()方法，返回表示方法执行时日期和时间的毫秒数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始时间</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="built_in">Date</span>.now(); </span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">doSomething(); </span><br><span class="line"><span class="comment">// 结束时间</span></span><br><span class="line"><span class="keyword">let</span> stop = <span class="built_in">Date</span>.now(), </span><br><span class="line">result = stop - start;</span><br></pre></td></tr></table></figure><h4 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h4><p>​     与其他类型一样，Date 类型重写了 toLocaleString()、toString()和 valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date 类型的 toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间, toString()方法通常返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示</p><h4 id="日期格式化的方法"><a href="#日期格式化的方法" class="headerlink" title="日期格式化的方法"></a>日期格式化的方法</h4><ul><li>toDateString()显示日期中的周几、月、日、年 (格式特定于实现)</li><li>toTimeString()显示日期中的时、分、秒和时区 (格式特定于实现)</li><li>toLocaleDateString()显示日期中的周几、月、日、年  (格式特定于实现和地区)</li><li>toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）</li><li>toUTCString()显示完整的 UTC 日期（格式特定于实现）</li></ul><h4 id="日期-时间组件方法"><a href="#日期-时间组件方法" class="headerlink" title="日期/时间组件方法"></a>日期/时间组件方法</h4><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">getTime()</td><td align="center">返回日期的毫秒表示；与 valueOf()相同</td></tr><tr><td align="center">setTime(milliseconds)</td><td align="center">设置日期的毫秒表示，从而修改整个日期</td></tr><tr><td align="center">getFullYear()</td><td align="center">返回 4 位数年（即 2019 而不是 19）</td></tr><tr><td align="center">getUTCFullYear()</td><td align="center">返回 UTC 日期的 4 位数年</td></tr><tr><td align="center">setFullYear(year)</td><td align="center">设置日期的年（year 必须是 4 位数）</td></tr><tr><td align="center">setUTCFullYear(year)</td><td align="center">设置 UTC 日期的年（year 必须是 4 位数）</td></tr><tr><td align="center">getMouth()</td><td align="center">返回日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td align="center">getUTCMouth()</td><td align="center">返回 UTC 日期的月（0 表示 1 月，11 表示 12 月）</td></tr><tr><td align="center">setMouth(mouth)</td><td align="center">设置日期的月（month为大于 0 的数值，大于 11 加年）</td></tr><tr><td align="center">setUTCMouth(mouth)</td><td align="center">设置 UTC 日期的月（month为大于 0 的数值，大于 11 加年）</td></tr><tr><td align="center">getDate()</td><td align="center">返回日期中的日（1~31）</td></tr><tr><td align="center">getUTCDate()</td><td align="center">返回 UTC 日期中的日（1~31）</td></tr><tr><td align="center">setDate(date)</td><td align="center">设置日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td align="center">setUTCDate(data)</td><td align="center">设置 UTC 日期中的日（如果 date 大于该月天数，则加月）</td></tr><tr><td align="center">getDay()</td><td align="center">返回日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td align="center">getUTCDay()</td><td align="center">返回 UTC 日期中表示周几的数值（0 表示周日，6 表示周六）</td></tr><tr><td align="center">getHours()</td><td align="center">返回日期中的时（0~23）</td></tr><tr><td align="center">getUTCHours()</td><td align="center">返回 UTC 日期中的时（0~23）</td></tr><tr><td align="center">setHours(hours)</td><td align="center">设置日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td align="center">setUTCHours(hours)</td><td align="center">设置 UTC 日期中的时（如果 hours 大于 23，则加日）</td></tr><tr><td align="center">getMinutes()</td><td align="center">返回日期中的分（0~59）</td></tr><tr><td align="center">getUTCMinutes()</td><td align="center">返回 UTC 日期中的分（0~59）</td></tr><tr><td align="center">setMinutes(minutes)</td><td align="center">设置日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td align="center">setUTCMinutes(minutes)</td><td align="center">设置 UTC 日期中的分（如果 minutes 大于 59，则加时）</td></tr><tr><td align="center">getSeconds()</td><td align="center">返回日期中的秒（0~59）</td></tr><tr><td align="center">getUTCSeconds()</td><td align="center">返回 UTC 日期中的秒（0~59）</td></tr><tr><td align="center">setSeconds(seconds)</td><td align="center">设置日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td align="center">setUTCSeconds(seconds)</td><td align="center">设置 UTC 日期中的秒（如果 seconds 大于 59，则加分）</td></tr><tr><td align="center">getMilliseconds()</td><td align="center">返回日期中的毫秒</td></tr><tr><td align="center">getUTCMilliseconds()</td><td align="center">返回 UTC 日期中的毫秒</td></tr><tr><td align="center">setMilliseconds(milliseconds)</td><td align="center">设置日期中的毫秒</td></tr><tr><td align="center">setUTCMilliseconds(milliseconds)</td><td align="center">设置 UTC 日期中的毫秒</td></tr><tr><td align="center">getTimezoneOffset()</td><td align="center">返回以分钟计的 UTC 与本地时区的偏移量</td></tr></tbody></table><h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p>ECMAScript 通过 RegExp 类型支持正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure><p>这个正则表达式的 pattern（模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags（标记），用于控制正则表达式的行为</p><ul><li>g: 全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束</li><li>i: 不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写</li><li>m: 多行模式，表示查找到一行文本末尾时会继续查找</li><li>y: 粘附模式，表示只查找从 lastIndex 开始及之后的字符串</li><li>u: Unicode 模式，启用 Unicode 匹配。</li><li>s: dotAll 模式，表示元字符.匹配任何字符(包括\n 或\r)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/at/g</span>; <span class="comment">// 匹配所有的at</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/[bc]at/i</span>; <span class="comment">// 匹配第一个"bat"或"cat"，忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/.at/gi</span>; <span class="comment">// 匹配所有以"at"结尾的三字符组合，忽略大小写</span></span><br></pre></td></tr></table></figure><p>与其他语言中的正则表达式类似，所有元字符在模式中也必须转义，包括 <strong><code>( [ { \ ^ $ | ) ] } ? * + .</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>; <span class="comment">// 匹配第一个"[bc]at"，忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/\.at/gi</span>; <span class="comment">// 匹配所有".at"，忽略大小写</span></span><br></pre></td></tr></table></figure><p>正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>); <span class="comment">// 匹配第一个"bat"或"cat"，忽略大小写</span></span><br></pre></td></tr></table></figure><p>因为 RegExp 的模式参数是字符串，所以在某些情况下需要二次转义。所有元字符都必须二次转义，包括转义字符序列，如\n（\转义后的字符串是\，在正则表达式字符串中则要写成\\）</p><table><thead><tr><th align="center">字面量模式</th><th align="center">对应的字符串</th></tr></thead><tbody><tr><td align="center">/[bc]at/</td><td align="center">“\ [bc\ ]at”</td></tr><tr><td align="center">/.at/</td><td align="center">“\ .at”</td></tr><tr><td align="center">/name/age/</td><td align="center">“name\ /age”</td></tr><tr><td align="center">/\d.\d{1,2}/</td><td align="center">“\ \d.\ \d{1,2}”</td></tr><tr><td align="center">/\w\ \hello\ \123/</td><td align="center">“\w\ \ \ \hello\ \ \ \123”</td></tr></tbody></table><p>此外，使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/cat/g</span>; </span><br><span class="line"><span class="built_in">console</span>.log(re1); <span class="comment">// "/cat/g" </span></span><br><span class="line"><span class="keyword">const</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1); </span><br><span class="line"><span class="built_in">console</span>.log(re2); <span class="comment">// "/cat/g" </span></span><br><span class="line"><span class="keyword">const</span> re3 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(re1, <span class="string">"i"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(re3); <span class="comment">// "/cat/i"</span></span><br></pre></td></tr></table></figure><h4 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h4><p>每个 RegExp 实例都有下列属性，提供有关模式的各方面信息</p><ul><li>global: 布尔值, 表示是否设置了<code>g</code>标记</li><li>ignoreCase: 布尔值, 表示是否设置<code>i</code>标记</li><li>unicode: 布尔值, 表示是否设置`u标记</li><li>sticky: 布尔值, 不是是否设置<code>y</code>标记</li><li>lastIndex: 整数, 表示在下一次搜索的开始位置, 始终从0开始</li><li>multiline: 布尔值, 表示是否设置<code>m</code>标记</li><li>dotAll: 布尔值，表示是否设置了 s 标记</li><li>source: 正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠</li><li>flags: 正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\[bc\]at/i</span></span><br><span class="line"><span class="built_in">console</span>.dir(pattern);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/\[bc\]at/i</span></span><br><span class="line"><span class="comment">dotAll: false</span></span><br><span class="line"><span class="comment">flags: "i"</span></span><br><span class="line"><span class="comment">global: false</span></span><br><span class="line"><span class="comment">ignoreCase: true</span></span><br><span class="line"><span class="comment">lastIndex: 0</span></span><br><span class="line"><span class="comment">multiline: false</span></span><br><span class="line"><span class="comment">source: "\[bc\]at"</span></span><br><span class="line"><span class="comment">sticky: false</span></span><br><span class="line"><span class="comment">unicode: false</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="RegExp的实例方法"><a href="#RegExp的实例方法" class="headerlink" title="RegExp的实例方法"></a>RegExp的实例方法</h4><p>RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"mom and dad and baby"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"><span class="built_in">console</span>.dir(pattern);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dotAll: false</span></span><br><span class="line"><span class="comment">flags: "gi"</span></span><br><span class="line"><span class="comment">global: true</span></span><br><span class="line"><span class="comment">ignoreCase: true</span></span><br><span class="line"><span class="comment">lastIndex: 0</span></span><br><span class="line"><span class="comment">multiline: false</span></span><br><span class="line"><span class="comment">source: "mom( and dad( and baby)?)?"</span></span><br><span class="line"><span class="comment">sticky: false</span></span><br><span class="line"><span class="comment">unicode: false</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text); <span class="comment">// ["mom and dad and baby", " and dad and baby", " and baby", index: 0, input: "mom and dad and baby", groups: undefined]</span></span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">0: "mom and dad and baby"</span></span><br><span class="line"><span class="comment">1: " and dad and baby"</span></span><br><span class="line"><span class="comment">2: " and baby"</span></span><br><span class="line"><span class="comment">groups: undefined</span></span><br><span class="line"><span class="comment">index: 0</span></span><br><span class="line"><span class="comment">input: "mom and dad and baby"</span></span><br><span class="line"><span class="comment">length: 3</span></span><br><span class="line"><span class="comment">__proto__: Array(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.dir(pattern);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/mom( and dad( and baby)?)?/gi</span></span><br><span class="line"><span class="comment">dotAll: false</span></span><br><span class="line"><span class="comment">flags: "gi"</span></span><br><span class="line"><span class="comment">global: true</span></span><br><span class="line"><span class="comment">ignoreCase: true</span></span><br><span class="line"><span class="comment">lastIndex: 20</span></span><br><span class="line"><span class="comment">multiline: false</span></span><br><span class="line"><span class="comment">source: "mom( and dad( and baby)?)?"</span></span><br><span class="line"><span class="comment">sticky: false</span></span><br><span class="line"><span class="comment">unicode: false</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>调用一次<code>exec()</code>方法后lastIndex值变成了20</p><p>下面我们不用去掉全局的<code>g</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/g</span>; </span><br><span class="line"><span class="built_in">console</span>.dir(pattern);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/.at/g</span></span><br><span class="line"><span class="comment">dotAll: false</span></span><br><span class="line"><span class="comment">flags: "g"</span></span><br><span class="line"><span class="comment">global: true</span></span><br><span class="line"><span class="comment">ignoreCase: false</span></span><br><span class="line"><span class="comment">lastIndex: 0</span></span><br><span class="line"><span class="comment">multiline: false</span></span><br><span class="line"><span class="comment">source: ".at"</span></span><br><span class="line"><span class="comment">sticky: false</span></span><br><span class="line"><span class="comment">unicode: false</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> matches = pattern.exec(text); <span class="comment">// ["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.dir(pattern); <span class="comment">// lastIndex 变成了3</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/.at/g</span></span><br><span class="line"><span class="comment">dotAll: false</span></span><br><span class="line"><span class="comment">flags: "g"</span></span><br><span class="line"><span class="comment">global: true</span></span><br><span class="line"><span class="comment">ignoreCase: false</span></span><br><span class="line"><span class="comment">lastIndex: 3</span></span><br><span class="line"><span class="comment">multiline: false</span></span><br><span class="line"><span class="comment">source: ".at"</span></span><br><span class="line"><span class="comment">sticky: false</span></span><br><span class="line"><span class="comment">unicode: false</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">matches = pattern.exec(text); <span class="comment">// ["bat", index: 5, input: "cat, bat, sat, fat", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.dir(pattern); <span class="comment">// lastIndex 变成了8</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/.at/g</span></span><br><span class="line"><span class="comment">dotAll: false</span></span><br><span class="line"><span class="comment">flags: "g"</span></span><br><span class="line"><span class="comment">global: true</span></span><br><span class="line"><span class="comment">ignoreCase: false</span></span><br><span class="line"><span class="comment">lastIndex: 8</span></span><br><span class="line"><span class="comment">multiline: false</span></span><br><span class="line"><span class="comment">source: ".at"</span></span><br><span class="line"><span class="comment">sticky: false</span></span><br><span class="line"><span class="comment">unicode: false</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">matches = pattern.exec(text); <span class="comment">// ["sat", index: 10, input: "cat, bat, sat, fat", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.dir(pattern); <span class="comment">// lastIndex 变成了13</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/.at/g</span></span><br><span class="line"><span class="comment">dotAll: false</span></span><br><span class="line"><span class="comment">flags: "g"</span></span><br><span class="line"><span class="comment">global: true</span></span><br><span class="line"><span class="comment">ignoreCase: false</span></span><br><span class="line"><span class="comment">lastIndex: 13</span></span><br><span class="line"><span class="comment">multiline: false</span></span><br><span class="line"><span class="comment">source: ".at"</span></span><br><span class="line"><span class="comment">sticky: false</span></span><br><span class="line"><span class="comment">unicode: false</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">matches = pattern.exec(text); <span class="comment">// ["fat", index: 15, input: "cat, bat, sat, fat", groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.dir(pattern); <span class="comment">// lastIndex 变成了18</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/.at/g</span></span><br><span class="line"><span class="comment">dotAll: false</span></span><br><span class="line"><span class="comment">flags: "g"</span></span><br><span class="line"><span class="comment">global: true</span></span><br><span class="line"><span class="comment">ignoreCase: false</span></span><br><span class="line"><span class="comment">lastIndex: 18</span></span><br><span class="line"><span class="comment">multiline: false</span></span><br><span class="line"><span class="comment">source: ".at"</span></span><br><span class="line"><span class="comment">sticky: false</span></span><br><span class="line"><span class="comment">unicode: false</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">matches = pattern.exec(text); <span class="comment">// null 匹配完了 </span></span><br><span class="line"><span class="built_in">console</span>.dir(pattern); <span class="comment">// exec()没有找到匹配项 所以将lastIndex 变回了0 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/.at/g</span></span><br><span class="line"><span class="comment">dotAll: false</span></span><br><span class="line"><span class="comment">flags: "g"</span></span><br><span class="line"><span class="comment">global: true</span></span><br><span class="line"><span class="comment">ignoreCase: false</span></span><br><span class="line"><span class="comment">lastIndex: 0</span></span><br><span class="line"><span class="comment">multiline: false</span></span><br><span class="line"><span class="comment">source: ".at"</span></span><br><span class="line"><span class="comment">sticky: false</span></span><br><span class="line"><span class="comment">unicode: false</span></span><br><span class="line"><span class="comment">__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，否则返回 false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"000-00-0000"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>; </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"The pattern was matched."</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正则表达式的 valueOf()方法返回正则表达式本身。</p><h4 id="RegExp-构造函数属性"><a href="#RegExp-构造函数属性" class="headerlink" title="RegExp 构造函数属性"></a>RegExp 构造函数属性</h4><p>RegExp 构造函数本身也有几个属性. 这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化. 这些属性还有一个特点就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写</p><table><thead><tr><th align="center">全名</th><th align="center">简写</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">input</td><td align="center">$_</td><td align="center">最后搜索的字符串</td></tr><tr><td align="center">lastMatch</td><td align="center">$&amp;</td><td align="center">最后匹配的文本</td></tr><tr><td align="center">lastParen</td><td align="center">$+</td><td align="center">最后匹配的捕获组</td></tr><tr><td align="center">leftContext</td><td align="center">$`</td><td align="center">input 字符串中出现在 lastMatch 前面的文本</td></tr><tr><td align="center">rightContext</td><td align="center">$’</td><td align="center">input 字符串中出现在 lastMatch 后面的文本</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"this has been a short summer"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/(.)hort/g</span>; </span><br><span class="line"><span class="keyword">if</span> (pattern.test(text)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="built_in">RegExp</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    $1: "s"</span></span><br><span class="line"><span class="comment">$2: ""</span></span><br><span class="line"><span class="comment">$3: ""</span></span><br><span class="line"><span class="comment">$4: ""</span></span><br><span class="line"><span class="comment">$5: ""</span></span><br><span class="line"><span class="comment">$6: ""</span></span><br><span class="line"><span class="comment">$7: ""</span></span><br><span class="line"><span class="comment">$8: ""</span></span><br><span class="line"><span class="comment">$9: ""</span></span><br><span class="line"><span class="comment">$&amp;: "short"</span></span><br><span class="line"><span class="comment">$': " summer"</span></span><br><span class="line"><span class="comment">$+: "s"</span></span><br><span class="line"><span class="comment">$_: "this has been a short summer"</span></span><br><span class="line"><span class="comment">$`: "this has been a "</span></span><br><span class="line"><span class="comment">input: "this has been a short summer"</span></span><br><span class="line"><span class="comment">lastMatch: "short"</span></span><br><span class="line"><span class="comment">lastParen: "s"</span></span><br><span class="line"><span class="comment">leftContext: "this has been a "</span></span><br><span class="line"><span class="comment">length: 2</span></span><br><span class="line"><span class="comment">name: "RegExp"</span></span><br><span class="line"><span class="comment">rightContext: " summer"</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模式局限"><a href="#模式局限" class="headerlink" title="模式局限"></a>模式局限</h4><p>虽然 ECMAScript 对正则表达式的支持有了长足的进步，但仍然缺少 Perl 语言中的一些高级特性。下列特性目前还没有得到 ECMAScript 的支持</p><ul><li>\A 和\Z 锚（分别匹配字符串的开始和末尾）</li><li>联合及交叉类</li><li>原子组</li><li>x（忽略空格）匹配模式</li><li>条件式匹配</li><li>正则表达式注释</li></ul><h3 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h3><p>为了方便操作原始值，ECMAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"some text"</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>第二行访问 s1 时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下 3 步</p><ul><li>创建一个 String 类型的实例</li><li>调用实例上的特定方法</li><li>销毁实例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>); </span><br><span class="line"><span class="keyword">let</span> s2 = s1.substring(<span class="number">2</span>); </span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上 3 步也会在后台发生，只不过使用的是 Boolean 和 Number 包装类型而已</p><p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"some text"</span>; </span><br><span class="line">s1.color = <span class="string">"red"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(s1.color); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入true 或 false，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> booleanObj = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调用时也会被覆盖，返回字符串”true”或”false”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>; <span class="comment">// 所有的对象都会转成true</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>; </span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>; </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>Number 是对应数值的引用类型, 要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>与 Boolean 类型一样，Number 类型重写了 valueOf()、toLocaleString()和 toString()方法。valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串</p><p>toFixed()方法返回包含指定小数点位数的数值字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>)); <span class="comment">// "10.00"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动四舍五入</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">10.005</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num1.toFixed(<span class="number">2</span>)); <span class="comment">// "10.01"</span></span><br></pre></td></tr></table></figure><p>toExponential()，返回以科学记数法（也称为指数记数法）表示的数值字符串, 接收一个参数，表示结果中小数的位数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">1</span>)); <span class="comment">// "1.0e+1"</span></span><br></pre></td></tr></table></figure><p>toPrecision()方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式, 这个方法接收一个参数，表示结果中数字的总位数（不包含指数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">99</span>; </span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">1</span>)); <span class="comment">// "1e+2" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">2</span>)); <span class="comment">// "99" </span></span><br><span class="line"><span class="built_in">console</span>.log(num.toPrecision(<span class="number">3</span>)); <span class="comment">// "99.0"</span></span><br></pre></td></tr></table></figure><p>ES6 新增了 Number.isInteger()方法，用于辨别一个数值是否保存为整数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.00</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.01</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>IEEE 754 数值格式有一个特殊的数值范围，在这个范围内二进制值可以表示一个整数值。这个数值范围从 Number.MIN_SAFE_INTEGER（253 + 1）到 Number.MAX_SAFE_INTEGER（253  1）。对超出这个范围的数值，即使尝试保存为整数，IEEE 754 编码格式也意味着二进制值可能会表示一个完全不同的数值。为了鉴别整数是否在这个范围内，可以使用 Number.isSafeInteger()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">-1</span> * (<span class="number">2</span> ** <span class="number">53</span>))); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">-1</span> * (<span class="number">2</span> ** <span class="number">53</span>) + <span class="number">1</span>)); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger(<span class="number">2</span> ** <span class="number">53</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isSafeInteger((<span class="number">2</span> ** <span class="number">53</span>) - <span class="number">1</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String 是对应字符串的引用类型。要创建一个 String 对象，使用 String 构造函数并传入一个数值，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><p>String 对象的方法可以在所有字符串原始值上调用。3个继承的方法 valueOf()、toLocaleString()和 toString()都返回对象的原始字符串值。</p><p>每个 String 对象都有一个 length 属性，表示字符串中字符的数量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// "11"</span></span><br></pre></td></tr></table></figure><ol><li><p>JavaScript 字符串</p><p>JavaScript 字符串由 16 位码元（code unit）组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">"abcde"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>charAt()方法返回给定索引的字符, 参数是整数, 这个方法查找指定索引位置的 16 位码元，并返回该码元对应的字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">"abcde"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.charAt(<span class="number">4</span>)); <span class="comment">// e</span></span><br></pre></td></tr></table></figure><p>JavaScript 字符串使用了两种 Unicode 编码混合的策略：UCS-2 和 UTF-16。对于可以采用 16 位编码的字符（U+0000~U+FFFF），这两种编码实际上是一样的</p><p>charCodeAt()方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">"abcde"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message.charCodeAt(<span class="number">2</span>)); <span class="comment">// 99</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">99</span> === <span class="number">0x63</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>fromCharCode()方法用于根据给定的 UTF-16 码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>)); <span class="comment">// "abcde"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// "abcde"</span></span><br></pre></td></tr></table></figure><p>对于 U+0000~U+FFFF 范围内的字符，length、charAt()、charCodeAt()和 fromCharCode()返回的结果都跟预期是一样的。这是因为在这个范围内，每个字符都是用 16 位表示的，而这几个方法也都基于 16 位码元完成操作</p><p>这个对应关系在扩展到 Unicode 增补字符平面时就不成立了。问题很简单，即 16 位只能唯一表示65 536 个字符。这对于大多数语言字符集是足够了，在 Unicode 中称为基本多语言平面（BMP）。为了表示更多的字符，Unicode 采用了一个策略，即每个字符使用另外 16 位去选择一个增补平面。这种每个`字符使用两个 16 位码元的策略称为代理对</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">"ab😊de"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.length); <span class="comment">// 6</span></span><br><span class="line">msg.charAt(<span class="number">2</span>); <span class="comment">// "�"</span></span><br><span class="line">msg.charAt(<span class="number">3</span>); <span class="comment">// "�"</span></span><br></pre></td></tr></table></figure><p>codePointAt(), 接收 16 位码元的索引并返回该索引位置上的码点(code point), 码点是 Unicode 中一个字符的完整标识.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg.charCodeAt(<span class="number">2</span>); <span class="comment">// 55357</span></span><br><span class="line">msg.charCodeAt(<span class="number">3</span>); <span class="comment">// 56842</span></span><br></pre></td></tr></table></figure><p>fromCodePoint()。这个方法接收任意数量的码点，返回对应字符拼接起来的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCodePoint(<span class="number">97</span>, <span class="number">98</span>, <span class="number">128522</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab😊de</span></span><br></pre></td></tr></table></figure></li><li><p>normalize()方法</p><p>某些 Unicode 字符可以有多种编码方式。有的字符既可以通过一个 BMP 字符表示，也可以通过一个代理对表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// U+00C5：上面带圆圈的大写拉丁字母 A </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>)); <span class="comment">// Å</span></span><br><span class="line"><span class="comment">// U+212B：长度单位“埃”</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>)); <span class="comment">// Å </span></span><br><span class="line"><span class="comment">// U+004：大写拉丁字母 A </span></span><br><span class="line"><span class="comment">// U+030A：上面加个圆圈</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>)); <span class="comment">// Å</span></span><br></pre></td></tr></table></figure><p>比较操作符不在乎字符看起来是什么样的，因此这 3 个字符互不相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>), </span><br><span class="line"> a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>), </span><br><span class="line"> a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>); </span><br><span class="line"><span class="built_in">console</span>.log(a1, a2, a3); <span class="comment">// Å, Å, Å </span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a2); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a3); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a3); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>为解决这个问题，Unicode提供了 4种规范化形式，可以将类似上面的字符规范化为一致的格式，无论底层字符的代码是什么。这 4种规范化形式是：NFD（Normalization Form D）、NFC（Normalization Form C）、NFKD（Normalization Form KD）和 NFKC（Normalization Form KC）。可以使用 normalize()方法对字符串应用上述规范化形式，使用时需要传入表示哪种形式的字符串：”NFD”、”NFC”、”NFKD”或”NFKC”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>), </span><br><span class="line"> a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>), </span><br><span class="line"> a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// U+00C5 是对 0+212B 进行 NFC/NFKC 规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">"NFD"</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">"NFC"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">"NFKD"</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(a1 === a1.normalize(<span class="string">"NFKC"</span>)); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// U+212B 是未规范化的</span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">"NFD"</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">"NFC"</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">"NFKD"</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(a2 === a2.normalize(<span class="string">"NFKC"</span>)); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// U+0041/U+030A 是对 0+212B 进行 NFD/NFKD 规范化之后的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">"NFD"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">"NFC"</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">"NFKD"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(a3 === a3.normalize(<span class="string">"NFKC"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>选择同一种规范化形式可以让比较操作符返回正确的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x00C5</span>), </span><br><span class="line"> a2 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x212B</span>), </span><br><span class="line"> a3 = <span class="built_in">String</span>.fromCharCode(<span class="number">0x0041</span>, <span class="number">0x030A</span>); </span><br><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">"NFD"</span>) === a2.normalize(<span class="string">"NFD"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(a2.normalize(<span class="string">"NFKC"</span>) === a3.normalize(<span class="string">"NFKC"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(a1.normalize(<span class="string">"NFC"</span>) === a3.normalize(<span class="string">"NFC"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>字符串操作方法</p><ul><li><p>cancat() 可以拼接多个字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"test"</span>;</span><br><span class="line"><span class="keyword">let</span> result = str.cancat(<span class="string">"卧槽"</span>, <span class="string">"nb"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// test卧槽nb</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// test</span></span><br></pre></td></tr></table></figure></li><li><p>slice(), substr(), substring(), 3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开</p><p>始的位置，第二个参数表示子字符串结束的位置对 slice()和 substring()而言，第二个参数是提取结束的位置(即该位置之前的字符会被提取出来), 对 substr()而言，第二个参数表示返回的子字符串数量, 任何情况下, 省略第二个参数都意味着提取到字符串末尾, 与 concat()方法一样, slice(), substr()</p><p>和 substring()也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>)); <span class="comment">// "lo world" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">3</span>)); <span class="comment">// "lo world" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>)); <span class="comment">// "lo world" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo w" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// "lo w" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// "lo worl"</span></span><br></pre></td></tr></table></figure><p>当某个参数是负值时，这 3 个方法的行为又有不同。比如，slice()方法将所有负值参数都当成字符串长度加上负参数值</p><p>slice()方法将所有负值参数都当成字符串长度加上负参数值而 substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为 0, substring()方法会将所有负参数值都转换为 0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">-3</span>)); <span class="comment">// "rld" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">-3</span>)); <span class="comment">// "hello world" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">-3</span>)); <span class="comment">// "rld" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.slice(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// "lo w" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// "hel" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.substr(<span class="number">3</span>, <span class="number">-4</span>)); <span class="comment">// "" (empty string)</span></span><br></pre></td></tr></table></figure></li><li><p>字符串位置方法</p><p>有两个方法用于在字符串中定位子字符串：indexOf()和 lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）两者的区别在于，indexOf()方法从字符串开头开始查找子字符串，而 lastIndexOf()方法从字符串末尾开始查找子字符串, 这两个方法都可以接收可选的第二个参数，表示开始搜索的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"o"</span>)); <span class="comment">// 4 </span></span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">"o"</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">// 7 </span></span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">"o"</span>, <span class="number">6</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li><p>字符串包含方法</p><p>ECMAScript 6 增加了 3 个用于判断字符串中是否包含另一个字符串的方法：startsWith()、endsWith()和 includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引 0 的匹配项，endsWith()检查开始于索引(string.length - substring.length)的匹配项，而 includes()检查整个字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">"foobarbaz"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"foo"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"bar"</span>)); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"baz"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"bar"</span>)); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"bar"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"qux"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这三个方法都有着第二个参数, startsWith和includes表示 开始搜索的位置, endWith表示 指定的位置当做字符串末尾的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">"foobarbaz"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"foo"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.startsWith(<span class="string">"foo"</span>, <span class="number">1</span>)); <span class="comment">// false </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"bar"</span>)); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(message.includes(<span class="string">"bar"</span>, <span class="number">4</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"bar"</span>)); <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(message.endsWith(<span class="string">"bar"</span>, <span class="number">6</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>trim()方法</p><p>ECMAScript 在所有字符串上都提供了 trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">" hello world "</span>; </span><br><span class="line"><span class="keyword">let</span> result = str.trim(); </span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// " hello world " </span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure><p>trimLeft()和 trimRight()方法分别用于从字符串开始和末尾清理空格符</p></li><li><p>repeat()方法</p><p>ECMAScript 在所有字符串上都提供了 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"d "</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">3</span>) + <span class="string">"decade"</span>); <span class="comment">// d d d decade</span></span><br></pre></td></tr></table></figure></li><li><p>padStart()和 padEnd()方法</p><p>padStart()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格(U+0020)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"foo"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.padStart(<span class="number">8</span>, <span class="string">"bar"</span>)); <span class="comment">// "barbafoo" 添加到长度为8 所以只需要添加5 bar第二次添加被截取</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padStart(<span class="number">2</span>)); <span class="comment">// "foo" 原字符串长度够 不添加</span></span><br><span class="line"><span class="built_in">console</span>.log(str.padEnd(<span class="number">8</span>, <span class="string">"bar"</span>)); <span class="comment">// "foobarba" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.padEnd(<span class="number">2</span>)); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure></li><li><p>字符串迭代与解构</p><p>字符串的原型上暴露了一个@@iterator 方法，表示可以迭代字符串的每个字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">"abc"</span>; </span><br><span class="line"><span class="keyword">let</span> stringIterator = msg[<span class="built_in">Symbol</span>.iterator](); </span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next()); <span class="comment">// &#123;value: "a", done: false&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next()); <span class="comment">// &#123;value: "b", done: false&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next()); <span class="comment">// &#123;value: "c", done: false&#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(stringIterator.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 for-of 循环中可以通过这个迭代器按序访问每个字符：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">"abcde"</span>) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(c); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构</span></span><br><span class="line"><span class="built_in">console</span>.log([...msg]); <span class="comment">// ["a", "b", "c"]</span></span><br></pre></td></tr></table></figure></li><li><p>字符串大小写转换</p><p>toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(str.toLocaleUpperCase()); <span class="comment">// "HELLO WORLD" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.toUpperCase()); <span class="comment">// "HELLO WORLD" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.toLocaleLowerCase()); <span class="comment">// "hello world" </span></span><br><span class="line"><span class="built_in">console</span>.log(str.toLowerCase()); <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure></li><li><p>字符串模式匹配方法</p><p>String 类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是 match()方法，这个方法本质上跟 RegExp 对象的 exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>; </span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 pattern.exec(text) </span></span><br><span class="line"><span class="keyword">let</span> matches = text.match(pattern); <span class="comment">// ["cat", index: 0, input: "cat, bat, sat, fat", groups: undefined]</span></span><br></pre></td></tr></table></figure><p>另一个查找模式的字符串方法是 search()。这个方法唯一的参数与 match()方法一样：正则表达式字符串或 RegExp 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1, search()始终从字符串开头向后匹配模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>; </span><br><span class="line"><span class="keyword">let</span> pos = text.search(<span class="regexp">/at/</span>); </span><br><span class="line"><span class="built_in">console</span>.log(pos); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>ECMAScript 提供了 replace()方法。这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串（这个字符串不会转换为正则表达式），第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，第一个参数必须为正则表达式并且带全局标记</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>; </span><br><span class="line"><span class="keyword">let</span> result = text.replace(<span class="string">"at"</span>, <span class="string">"ond"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "cond, bat, sat, fat"</span></span><br><span class="line"></span><br><span class="line">result = text.replace(<span class="regexp">/at/g</span>, <span class="string">"ond"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "cond, bond, sond, fond"</span></span><br></pre></td></tr></table></figure><p>第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值, ECMA-262 中规定了下表中的值</p><table><thead><tr><th align="center">字符序列</th><th align="center">替换文本</th></tr></thead><tbody><tr><td align="center">$$</td><td align="center">$</td></tr><tr><td align="center">$&amp;</td><td align="center">匹配整个模式的子字符串。与 RegExp.lastMatch 相同</td></tr><tr><td align="center">$’</td><td align="center">匹配的子字符串之前的字符串。与 RegExp.rightContext 相同</td></tr><tr><td align="center">$`</td><td align="center">匹配的子字符串之后的字符串。与 RegExp.leftContext 相同</td></tr><tr><td align="center">$n</td><td align="center">匹配第 <em>n</em> 个捕获组的字符串，其中 <em>n</em> 是 0~9。比如，$1 是匹配第一个捕获组的字符串，$2 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr><tr><td align="center">$nn</td><td align="center">匹配第 <em>nn</em> 个捕获组字符串，其中 <em>nn</em> 是 01~99。比如，$01 是匹配第一个捕获组的字符串，$02 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"cat, bat, sat, fat"</span>; </span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($$)"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "word ($), word ($), word ($), word ($)"</span></span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($&amp;)"</span>); <span class="comment">// "word (cat), word (bat), word (sat), word (fat)"</span></span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($`)"</span>); <span class="comment">// "word (), word (cat, ), word (cat, bat, ), word (cat, bat, sat, )"</span></span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($')"</span>); <span class="comment">// "word (, bat, sat, fat), word (, sat, fat), word (, fat), word ()"</span></span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($1)"</span>); <span class="comment">// "word (cat), word (bat), word (sat), word (fat)"</span></span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($2)"</span>); <span class="comment">// "word ($2), word ($2), word ($2), word ($2)"</span></span><br><span class="line">result = text.replace(<span class="regexp">/(.at)/g</span>, <span class="string">"word ($01)"</span>); <span class="comment">// "word (cat), word (bat), word (sat), word (fat)"</span></span><br></pre></td></tr></table></figure><p>replace()的第二个参数可以是一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span>  str = <span class="string">"&lt;p class=\"greeting\"&gt;Hello world!&lt;/p&gt;"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceFun</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// 参数有三个 整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串</span></span><br><span class="line">    <span class="keyword">switch</span>(rest[<span class="number">0</span>]) &#123; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">"&lt;"</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">"&amp;lt;"</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">"&gt;"</span>: </span><br><span class="line"><span class="keyword">return</span> <span class="string">"&amp;gt;"</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">"&amp;"</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">"&amp;amp;"</span>; </span><br><span class="line"> <span class="keyword">case</span> <span class="string">"\""</span>: </span><br><span class="line"> <span class="keyword">return</span> <span class="string">"&amp;quot;"</span>; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">str.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, replaceFun); <span class="comment">// 匹配到了六次</span></span><br><span class="line"><span class="comment">// ["&lt;", 0, "&lt;p class="greeting"&gt;Hello world!&lt;/p&gt;"]</span></span><br><span class="line"><span class="comment">// [""", 9, "&lt;p class="greeting"&gt;Hello world!&lt;/p&gt;"]</span></span><br><span class="line"><span class="comment">// [""", 18, "&lt;p class="greeting"&gt;Hello world!&lt;/p&gt;"]</span></span><br><span class="line"><span class="comment">// ["&gt;", 19, "&lt;p class="greeting"&gt;Hello world!&lt;/p&gt;"]</span></span><br><span class="line"><span class="comment">// ["&lt;", 32, "&lt;p class="greeting"&gt;Hello world!&lt;/p&gt;"]</span></span><br><span class="line"><span class="comment">// ["&gt;", 35, "&lt;p class="greeting"&gt;Hello world!&lt;/p&gt;"]</span></span><br></pre></td></tr></table></figure><p>最后一个与模式匹配相关的字符串方法是 split(), 数组。作为分隔符的参数可以是字符串，也可以是 RegExp 对象, (字符串分隔符不会被这个方法当成</p><p>正则表达式) 还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小,这个方法会根据传入的分隔符将字符串拆分成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colorText = <span class="string">"red,blue,green,yellow"</span>; </span><br><span class="line"><span class="keyword">let</span> colors1 = colorText.split(<span class="string">","</span>); <span class="comment">// ["red", "blue", "green", "yellow"] </span></span><br><span class="line"><span class="keyword">let</span> colors2 = colorText.split(<span class="string">","</span>, <span class="number">2</span>); <span class="comment">// ["red", "blue"] </span></span><br><span class="line"><span class="keyword">let</span> colors3 = colorText.split(<span class="regexp">/[^,]+/</span>); <span class="comment">// ["", ",", ",", ",", ""]</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h3><p>ECMA-262 对内置对象的定义是“任何由 ECMAScript 实现提供、与宿主环境无关，并在 ECMAScript程序开始执行时就存在的对象”</p><h4 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h4><ol><li><p>URL编码方法</p><p>encodeURI() 只会编译url中的空格(编译成了%20), 特殊字符是不会编译的</p><p>encodeURIComponent() 会把url中所以的特殊字符全部编译</p><p>相应的</p><p>使用 <code>encodeURI</code> 编译就 使用 decodeURI解码</p><p>使用 <code>encodeURIComponent</code> 编译就是用 decodeURIComponent 解码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">"http://www.bai.com/xxx= 123&amp;xxx=#...zzz"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(decodeURL(url)); <span class="comment">// "http://www.bai.com/xxx=%20123&amp;xxx=#...zzz"</span></span><br><span class="line"><span class="built_in">console</span>.log(decodeURLComponent(url)) <span class="comment">// "http%3A%2F%2Fwww.bai.com%2Fxxx%3D%20123%26xxx%3D%23...zzz"</span></span><br></pre></td></tr></table></figure></li><li><p>eval() 方法</p><p>它接收一个参数，即一个要执行的 ECMAScript（JavaScript）字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"console.log('hi')"</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br></pre></td></tr></table></figure><p>当解释器发现 eval()调用时，会将参数解释为实际的 ECMAScript 语句，然后将其插入到该位置。通过 eval()执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">"我在eval之前定义"</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"consolo.log(msg)"</span>); <span class="comment">// 我在eval之前定义</span></span><br></pre></td></tr></table></figure><p>可以在 eval()内部定义一个函数或变量，然后在外部代码中引用，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"function sayHi() &#123; console.log('hi'); &#125;"</span>); </span><br><span class="line">sayHi(); <span class="comment">// hi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"let msg = 'hello DECADE';"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(msg); <span class="comment">// Reference Error: msg is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>Global 对象属性</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">特殊值 undefined</td></tr><tr><td align="center">NaN</td><td align="center">特殊值 NaN</td></tr><tr><td align="center">Infinity</td><td align="center">特殊值 Infinity</td></tr><tr><td align="center">Object</td><td align="center">Object 的构造函数</td></tr><tr><td align="center">Array</td><td align="center">Array的构造函数</td></tr><tr><td align="center">Function</td><td align="center">Function 的构造函数</td></tr><tr><td align="center">Boolean</td><td align="center">Boolean 的构造函数</td></tr><tr><td align="center">String</td><td align="center">String 的构造函数</td></tr><tr><td align="center">Number</td><td align="center">Number 的构造函数</td></tr><tr><td align="center">Date</td><td align="center">Date 的构造函数</td></tr><tr><td align="center">RegExp</td><td align="center">RegExp 的构造函数</td></tr><tr><td align="center">Symbol</td><td align="center">Symbol 的伪构造函数</td></tr><tr><td align="center">Error</td><td align="center">Error 的构造函数</td></tr><tr><td align="center">EvalError</td><td align="center">EvalError 的构造函数</td></tr><tr><td align="center">RangeError</td><td align="center">RangeError 的构造函数</td></tr><tr><td align="center">ReferenceError</td><td align="center">ReferenceError 的构造函数</td></tr><tr><td align="center">SyntaxError</td><td align="center">SyntaxError 的构造函数</td></tr><tr><td align="center">TypeError</td><td align="center">TypeError 的构造函数</td></tr><tr><td align="center">URIError</td><td align="center">URIError 的构造函数</td></tr></tbody></table></li><li><p>window 对象</p><p>浏览器将 window 对象实现为 Global对象的代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"decade"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">sayName(); <span class="comment">// decade</span></span><br></pre></td></tr></table></figure></li><li><p>Math 对象</p><ul><li><p>Math属性对象</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Math.E</td><td align="center">自然对数的基数 e 的值</td></tr><tr><td align="center">Math.LN10</td><td align="center">10 为底的自然对数</td></tr><tr><td align="center">Math.LN2</td><td align="center">2 为底的自然对数</td></tr><tr><td align="center">Math.LOG2E</td><td align="center">以 2 为底 e 的对数</td></tr><tr><td align="center">Math.LOG10E</td><td align="center">以 10 为底 e 的对数</td></tr><tr><td align="center">Math.PI</td><td align="center">π 的值</td></tr><tr><td align="center">Math.SQRT1_2</td><td align="center">1/2 的平方根</td></tr><tr><td align="center">Math.SQRT2</td><td align="center">2 的平方根</td></tr></tbody></table></li><li><p>min()和 max()方法</p><p>min()和 max()方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">30</span>, <span class="number">20</span>];</span><br><span class="line">min(...arr); <span class="comment">// 1</span></span><br><span class="line">max(...arr); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li><li><p>舍入方法</p><p>Math.ceil() 向上取舍</p><p>Math.floor() 向下取舍</p><p>Math.round()  四舍五入</p><p>Math.fround() 返回数值最接近的单精度（32 位）浮点值表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">25.9</span>); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">25.5</span>); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">25.1</span>); <span class="comment">// 26 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">25.9</span>); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">25.5</span>); <span class="comment">// 26 </span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">25.1</span>); <span class="comment">// 25 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.4</span>); <span class="comment">// 0.4000000059604645 </span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.5</span>); <span class="comment">// 0.5 </span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">25.9</span>); <span class="comment">// 25.899999618530273 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">25.9</span>); <span class="comment">// 25 </span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">25.5</span>); <span class="comment">// 25 </span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="number">25.1</span>); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure></li><li><p>random()方法</p><p>Math.random()方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1</p></li><li><p>其他方法</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Math.abs(x)</td><td align="center">返回 x 的绝对值</td></tr><tr><td align="center">Math.e<em>x</em>p(x)</td><td align="center">返回 Math.E 的 x 次幂</td></tr><tr><td align="center">Math.e<em>x</em>pm1(x)</td><td align="center">等于 Math.e<em>x</em>p(x) - 1</td></tr><tr><td align="center">Math.log(x)</td><td align="center">返回 x 的自然对数</td></tr><tr><td align="center">Math.log1p(x)</td><td align="center">等于 1 + Math.log(x)</td></tr><tr><td align="center">Math.pow(x, power)</td><td align="center">返回 x 的 power 次幂</td></tr><tr><td align="center">Math.hypot(…nums)</td><td align="center">返回 nums 中每个数平方和的平方根</td></tr><tr><td align="center">Math.clz32(x)</td><td align="center">返回 32 位整数 x 的前置零的数量</td></tr><tr><td align="center">Math.sign(x)</td><td align="center">返回表示 x 符号的 1、0、-0 或-1</td></tr><tr><td align="center">Math.trunc(x)</td><td align="center">返回 x 的整数部分，删除所有小数</td></tr><tr><td align="center">Math.sqrt(x)</td><td align="center">返回 x 的平方根</td></tr><tr><td align="center">Math.cbrt(x)</td><td align="center">返回 x 的立方根</td></tr><tr><td align="center">Math.acos(x)</td><td align="center">返回 x 的反余弦</td></tr><tr><td align="center">Math.acosh(x)</td><td align="center">返回 x 的反双曲余弦</td></tr><tr><td align="center">Math.asin(x)</td><td align="center">返回 x 的反正弦</td></tr><tr><td align="center">Math.asinh(x)</td><td align="center">返回 x 的反双曲正弦</td></tr><tr><td align="center">Math.atan(x)</td><td align="center">返回 x 的反正切</td></tr><tr><td align="center">Math.atanh(x)</td><td align="center">返回 x 的反双曲正切</td></tr><tr><td align="center">Math.atan2(y, x)</td><td align="center">返回 y / x 的反正切</td></tr><tr><td align="center">Math.cos(x)</td><td align="center">返回 x 的余弦</td></tr><tr><td align="center">Math.sin(x)</td><td align="center">返回 x 的正弦</td></tr><tr><td align="center">Math.tan(x)</td><td align="center">返回 x 的正切</td></tr></tbody></table></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版-第四章-笔记</title>
    <link href="http://blog.decade.run/2020/11/18/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2020/11/18/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-18T03:17:02.000Z</published>
    <updated>2020-11-19T07:37:54.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原始值与引用值"><a href="#原始值与引用值" class="headerlink" title="原始值与引用值"></a>原始值与引用值</h3><p>ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值, 原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象,    保存原始值的变量是按值（by value）访问的 ,  JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间保存引用值的变量是按引用（by reference）访问的</p><ol><li><p>动态属性</p><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用值</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">"decade"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// decade</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始值</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'decade'</span></span><br><span class="line">str.name = <span class="string">"123"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">"decade"</span>; </span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"decade"</span>); </span><br><span class="line">name1.age = <span class="number">18</span>; </span><br><span class="line">name2.age = <span class="number">18</span>; </span><br><span class="line"><span class="built_in">console</span>.log(name1.age); <span class="comment">// undefined </span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age); <span class="comment">// 18 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1); <span class="comment">// string </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure></li><li><p>复制值</p><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num1 = num;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用值 复制 复制的是指针</span></span><br><span class="line"><span class="comment">// obj obj1 指向的是同一个地址</span></span><br><span class="line">obj.name = <span class="string">"decade"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// decade</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// decade</span></span><br><span class="line"><span class="built_in">console</span>.log(obj === obj1); <span class="comment">// true 说明是一个地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始值 复制的是副本</span></span><br><span class="line"><span class="comment">// num num1 互不关联</span></span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">//20</span></span><br></pre></td></tr></table></figure></li><li><p>传递参数</p><p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(addTen(num)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"decade"</span>; <span class="comment">// 这里的obj 就相当于和传入的obj同指向一个地址</span></span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 改变指向 但是外面的不会改变</span></span><br><span class="line">    obj.name = <span class="string">"zi-o"</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">setName(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// decade</span></span><br></pre></td></tr></table></figure></li><li><p>确定类型</p><p>typeof 操作符最适合用来判断一个变量是否为原始类型, 更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式</p><p>通过 instanceof 操作符检测任何引用值和Object 构造函数都会返回 true</p></li></ol><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>​       执行上下文的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它</p><p>​       全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象，因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p><p>​        每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的</p><p>​        上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (color === <span class="string">"red"</span>) &#123;</span><br><span class="line">        color = <span class="string">"blue"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        color = <span class="string">"red"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">// "red"</span></span><br><span class="line">changeColor();</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">// "blue"</span></span><br><span class="line"><span class="comment">// changeColor()函数作用域里面没有color这个变量 它会自动往上一级作用域 查找变量名为color的变量, 找到 就执行 ,没找到就报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myColor = <span class="string">"red"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeMyColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> funcColor = <span class="string">"blue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> swapColor = funcColor;</span><br><span class="line">        funcColor = myColor;</span><br><span class="line">        myColor = swapColor;</span><br><span class="line">        <span class="comment">// swapColor 在swapColor的作用域 所以能访问</span></span><br><span class="line">        <span class="comment">// funcColor 在swapColor的上一级 所以能访问</span></span><br><span class="line">        <span class="comment">// myColor 在上一级的上一级 所以能访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// swapColor是定义在swapColor里面的 并不是changeMyColor的上一级或者上上一级.. 所以不能访问</span></span><br><span class="line">    <span class="comment">// funcColor就是定义在changeMyColor, 所以能访问</span></span><br><span class="line">    <span class="comment">// myColor在上一级 所以能访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 就只能访问 myColor了</span></span><br></pre></td></tr></table></figure><p>函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则</p><ul><li><p>作用域链增强</p><p>虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除</p><ol><li>try/catch 语句的 catch 块</li><li>with语句</li></ol><p>这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">    <span class="keyword">with</span> (location) &#123;</span><br><span class="line">        <span class="keyword">let</span> url = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildUrl(); <span class="comment">//Uncaught ReferenceError: url is not defined</span></span><br></pre></td></tr></table></figure><p>首先开始分析有哪几个作用域:</p><p>​        最大的scope是<code>Global</code>(也就是window), 执行函数里面的代码 这时候又有一个scope <code>Local</code>, 里面有个变量qs, 还有一个this 指向的window,代码执行到<code>with</code>语句, 一般来说 只会多一个 with语句那个scope <code>Block</code> 但是这时还会临时添加一个scope <code>With Block</code> , <code>With Block</code>中的就是location变量的所有属性, 而<code>Block</code>里面只有一个url变量</p><p>接着我们分析作用域层级关系:</p><p>​       <code>Global</code> -&gt; <code>Local</code> -&gt; <code>Block</code> -&gt; <code>With Block</code></p><p>然后我们分析每个作用域我们能访问到什么: </p><p>​       <code>With Block</code>:  location里面的所有属性(With Block), url (Block), qs(Local), window上面挂载的所有属性(Global)</p><p>​       <code>Block</code>:  url (Block), qs(Local), window上面挂载的所有属性(Global)</p><p>​       <code>Local</code>:  qs(Local), window上面挂载的所有属性(Global)</p><p>​       <code>Global</code>:  window上面挂载的所有属性(Global)</p><p>最后我们看在<code>Local</code> 这里是访问不到 <code>Block</code>里面的url 的 所以 报错 url未定义</p><p>如果我们把<code>let url = href  + qs</code> 改成 <code>var url = href + qs</code>的 在 <code>Local</code>里面是能访问到url的, 为什么呢?  <strong>因为 在使用 var 声明变量时，变量会被自动添加到最接近的上下文</strong>  大概和下面的代码一个道理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url;</span><br><span class="line">    <span class="keyword">let</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">    <span class="keyword">with</span> (location) &#123;</span><br><span class="line">        url = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line">buildUrl();</span><br></pre></td></tr></table></figure></li><li><p>变量声明</p><ol><li><p>使用var的函数作用域声明</p><p>在使用 var 声明变量时，变量会被自动添加到最接近的上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2; <span class="comment">// 没有var 变量sum在window上</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 报错 </span></span><br><span class="line"><span class="comment">// sum 变量在add 这个函数的作用域里面</span></span><br></pre></td></tr></table></figure><p>var 声明会被拿到函数或全局作用域的顶部</p></li><li><p>使用let 的块级作用域声明</p><p>ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是 JavaScript 中的新概念。块级作用域由最近的一对包含花括号{}界定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> a; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a 没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b 没有定义</span></span><br></pre></td></tr></table></figure></li><li><p>使用const的常量声明</p><p>除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num; <span class="comment">// SyntaxError: 常量声明时没有初始化</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>; </span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3 </span></span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br></pre></td></tr></table></figure></li><li><p>标识符查找</p><p>当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure><p>在这个例子中，调用函数 getColor()时会引用变量 color。为确定 color 的值会进行两步搜索。第一步，搜索 getColor()的变量对象，查找名为 color 的标识符。结果没找到，于是继续搜索下一个变量对象（来自全局上下文），然后就找到了名为 color 的标识符。因为全局变量对象上有 color的定义，所以搜索结束</p><p>对这个搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">"red"</span>;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure><p>使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">"red"</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> color = <span class="string">"green"</span></span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getColor()); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure><p>标识符查找并非没有代价。访问局部变量比访问全局变量要快，因为不用切换作用域。不过，JavaScript 引擎在优化标识符查找上做了很多工作，将来这个差异可能就微不足道了</p></li></ol></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>​      JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存, JavaScript 为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。</p><p>​      我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数</p><ul><li><p>标记清理</p><p>​      JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p><p>​       给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。</p><p>​       垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p><ol><li><p>引用计数</p><p>​       另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存</p><p>引用计数存在<strong>循环引用</strong>的问题</p></li><li><p>性能</p><p>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作</p></li></ol></li><li><p>内存管理</p><p>​       在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过，JavaScript 运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量 JavaScript 的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。</p><p>​       将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用。这也可以叫作解除引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    localPerson.name = name;</span><br><span class="line">    <span class="keyword">return</span> localPerson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> globalPerson = createPerson(<span class="string">"decade"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(globalPerson.name); <span class="comment">// "decade"</span></span><br><span class="line"><span class="comment">// 解除引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ol><li><p>通过<code>const</code> 和 <code>let</code> 提升性能</p><p>ES6 增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为 const let 都以块（而非函数）为作用域，所以相比于使用 var，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。在块作用域比函数作用域更早终止的情况下，这就有可能发生</p></li><li><p>隐藏类和删除操作</p><p>根据 JavaScript 所在的运行环境，有时候需要根据浏览器使用的 JavaScript 引擎来采取不同的性能优化策略.  运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = <span class="string">"假面骑士"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在这两个共享一个隐藏类</span></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article(); <span class="comment">// Article &#123;title: "假面骑士"&#125;</span></span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(); <span class="comment">// Article &#123;title: "假面骑士"&#125;</span></span><br><span class="line"><span class="comment">// Article &#123; title: string &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在就不共享同一个隐藏类了</span></span><br><span class="line">a1.name = <span class="string">"decade"</span>; <span class="comment">// Article &#123;title: "假面骑士", name: "decade"&#125;</span></span><br><span class="line"><span class="comment">// Article &#123;title: string, name: string&#125;</span></span><br><span class="line">a2 </span><br><span class="line"><span class="comment">// Article &#123; title: string &#125;;</span></span><br></pre></td></tr></table></figure><p>解决方案就是避免 JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在构造函数中一次性声明所有属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params">opt_author</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.title = <span class="string">'Inauguration Ceremony Features Kazoo Band'</span>; </span><br><span class="line"> <span class="keyword">this</span>.author = opt_author; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Article(); </span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Article(<span class="string">'Jake'</span>);</span><br><span class="line"><span class="comment">// 这样，两个实例基本上就一样了（不考虑 hasOwnProperty 的返回值），因此可以共享一个隐藏类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果使用了delete 又不是了, 但是你最好重置为null</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>内存泄露</p><p>写得不好的 JavaScript 可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span> </span>&#123;</span><br><span class="line">    name = <span class="string">"decade"</span>;</span><br><span class="line">&#125;</span><br><span class="line">setName();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 外部能访问</span></span><br></pre></td></tr></table></figure><p>定时器也可能会悄悄地导致内存泄漏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Jake'</span>; </span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(name); </span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 这个定时器销毁 name就不会销毁</span></span><br></pre></td></tr></table></figure><p>使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"decade"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 outer()会导致分配给 name 的内存被泄漏</span></span><br></pre></td></tr></table></figure><ol><li><p>静态分配和对象池</p><p>​       为了提升 JavaScript 性能，最后要考虑的一点往往就是压榨浏览器了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能</p><p>​        浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVector</span>(<span class="params">a, b</span>) </span>&#123; </span><br><span class="line"> <span class="keyword">let</span> resultant = <span class="keyword">new</span> Vector(); </span><br><span class="line"> resultant.x = a.x + b.x; </span><br><span class="line"> resultant.y = a.y + b.y; </span><br><span class="line"> <span class="keyword">return</span> resultant; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 频繁调用 会频繁的创建一个Vertor对象, 解决办法 是 把需要计算的那个对象一起传进来</span></span><br></pre></td></tr></table></figure><p>静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。</p></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计第四版 第三章 笔记</title>
    <link href="http://blog.decade.run/2020/11/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.decade.run/2020/11/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-11T01:31:37.000Z</published>
    <updated>2020-11-18T06:23:06.232Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h3><ol><li><p>无论是变量, 函数名, 函数名, 都区分大小写</p></li><li><p><strong><code>标识符</code></strong>: 变量, 函数, 属性或者函数参数的名称, 推荐写法驼峰形式(firstExample )</p><ul><li>第一个字符必须是一个字母(_),  下划线或者美元符($)</li><li>剩下的其他字符可以是字母, 下划线, 美元符号或者数字</li></ul></li><li><p>单行注释用双斜线<code>//</code> 多行用 <code>/* 我是多行注释 */</code></p></li><li><p>严格模式 <code>use strict</code>;</p><ul><li><code>ECMAScript 5</code> 增加的严格模式, 就是一个预处理指令</li><li>为了针对<code>ECMAScript 3</code>的一些不规范写法, 然后抛出错误</li><li>放在js脚本开头, 或者函数体第一行都可以</li></ul></li><li><p><code>ECMAScript</code>中的语句以分号结尾</p><ul><li><p>最好不要省略分号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> sum1 = a + b; <span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">let</span> sum2 = a + b  <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure></li><li><p>if条件语句在某种情况下也不要省略中括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h3><ol><li><p><code>ECMA-262 第 6 版</code>规定的所有关键字如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   break      do         in            typeof</span></span><br><span class="line"><span class="comment">   case       else       instanceof    var</span></span><br><span class="line"><span class="comment">   catch      export     new           void</span></span><br><span class="line"><span class="comment">   class      extends    return        while</span></span><br><span class="line"><span class="comment">   const      finally    super         with</span></span><br><span class="line"><span class="comment">   continue   for        switch        yield</span></span><br><span class="line"><span class="comment">   debugger   function   this</span></span><br><span class="line"><span class="comment">   default    if         throw</span></span><br><span class="line"><span class="comment">   delete     import     try</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>ECMA-262 第 6 版</code>为未来保留的关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   始终保留</span></span><br><span class="line"><span class="comment">   enum</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   严格模式保留</span></span><br><span class="line"><span class="comment">   implements    package     public</span></span><br><span class="line"><span class="comment">   interface     protected   static</span></span><br><span class="line"><span class="comment">   let           private</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   模块代码中保留</span></span><br><span class="line"><span class="comment">   await</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li><p><strong><code>var</code></strong> 关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">// 没有赋值 默认undefined</span></span><br><span class="line">message = <span class="number">123</span>; <span class="comment">// 赋值 123  </span></span><br><span class="line"><span class="comment">// javascript 是弱类型语言 所以 message可以是赋值为Number, Object, String, Boolean 等类型的</span></span><br><span class="line"><span class="comment">// 这样的写法不推荐</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li><p><code>var</code>声明作用域  使用 var 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 <code>var</code>在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 执行完 销毁 局部变量message</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 如果在函数内申明的变量 省略了var 如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    message1 = <span class="string">"test1"</span>; <span class="comment">// 这样的message1是一个全局变量 不推荐这么做, 在局部声明全局变量就很离谱</span></span><br><span class="line">&#125;</span><br><span class="line">test1();</span><br><span class="line"><span class="built_in">console</span>.log(message1); <span class="comment">// test1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多个变量时可以用逗号</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c;</span><br></pre></td></tr></table></figure></li><li><p><code>var</code>声明提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// undefined </span></span><br><span class="line"><span class="comment">// 这样执行时不会报错的 因为 var声明提升到函数作用顶部 相当于下面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age; <span class="comment">// 默认undefined</span></span><br><span class="line">    <span class="built_in">console</span>.loe(age);</span><br><span class="line">    age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>let</code>声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 是函数作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Matt'</span>; </span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let 是块级作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="string">'decade'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name1); <span class="comment">// decade</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1); <span class="comment">// ReferenceError: age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 块作用域 是函数作用域的子集</span></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> name: <span class="comment">// 这样不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age; <span class="comment">// SyntaxError age已经申明过了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'decade'</span>; </span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 'decade' </span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">'zio'</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(name); <span class="comment">// 'zio' </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>; </span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 30 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> age = <span class="number">26</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(age); <span class="comment">// 26 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> name; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><ul><li><p>暂时性死区</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// name 会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'decade'</span>; </span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">name = <span class="string">'decade'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// age 不会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError：age 没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure></li><li><p>全局声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性(var 声明的变量则会)</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'decade'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// decade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>条件声明</p><ol><li>在使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它</li><li>使用 try/catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。</li></ol></li><li><p><strong>for</strong> 循环中的 <strong>let</strong> 声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">0</span>) <span class="comment">// 5, 5, 5 ,5, 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用let</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, <span class="number">0</span>) <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// ReferenceError 未定义</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>const</strong> 声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>; </span><br><span class="line">age = <span class="number">36</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'decade'</span>; </span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'zio'</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'decade'</span>; </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> name = <span class="string">'zio'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// decade</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 声明的限制只适用于它指向的变量的引用。</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.name = <span class="string">'decade'</span>; <span class="comment">// 这样是没有问题的</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>六种简单数据类型(原始类型): Undefined, Null, Number, Boolean, String, Symbol(ES6新增), 一种复杂数据类型: Object</p><ol><li><p><code>typeof</code>操作符   <strong><code>不是函数 不是函数 不是函数</code></strong></p><ul><li>“undefined”  表示值为未定义</li><li>“boolean” 表示值为布尔值</li><li>“string”  表示值为字符串</li><li>“number”  表示值为数字</li><li>“object”  表示值为对象或者null</li><li>“function”  表示值为函数</li><li>“symbol”  表示值为符号(Symbol)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"some string"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// "string" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message)); <span class="comment">// "string" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>); <span class="comment">// "number"</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Undefined</strong> 类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值</span></span><br><span class="line"><span class="keyword">var</span> name; </span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Null</strong> 类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Null 类型同样只有一个值，即特殊值 null, 逻辑上将null是一个空指针</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">typeof</span> obj; <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Boolean</strong> 类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false</span></span><br><span class="line"><span class="keyword">let</span> win = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> lose = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">let</span> messageBoolean = <span class="built_in">Boolean</span>(message);</span><br><span class="line"><span class="built_in">console</span>.log(messageBoolean); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">数据类型</th><th align="center">转换为true的值</th><th align="center">转换为false的值</th></tr></thead><tbody><tr><td align="center">Boolean</td><td align="center">true</td><td align="center">false</td></tr><tr><td align="center">String</td><td align="center">非空字符串</td><td align="center">空字符串</td></tr><tr><td align="center">Number</td><td align="center">非零数值(包括无穷值)</td><td align="center">0, NaN</td></tr><tr><td align="center">Object</td><td align="center">任意对象</td><td align="center">null</td></tr><tr><td align="center">Undefined</td><td align="center">没有</td><td align="center">undefined</td></tr></tbody></table></li><li><p><strong>Number</strong> 类型</p><ul><li><p>声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> intNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span>  octalNum = <span class="number">070</span>; <span class="comment">// 八进制的56</span></span><br><span class="line"><span class="keyword">let</span> octalNum = <span class="number">079</span>; <span class="comment">// 八进制没有9 所以 忽略前面的0 当成十进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> hexNum =<span class="number">0xA</span>; <span class="comment">// 十六进制的10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">.1</span>; <span class="comment">// 这样也行 但是不推荐</span></span><br><span class="line"><span class="comment">// 存储浮点值使用的内存空间是存储整数值的两倍, 所以会想法设法的转成整数</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">1.0</span>; <span class="comment">// 1忽略小数点后面的0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 科学计数法表示</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">3.125e7</span>; <span class="comment">// 31250000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>值得范围</p><p>​       由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>NaN</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> / +<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> / <span class="number">0</span>); <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-5</span> / <span class="number">0</span>); <span class="comment">// -Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false NaN不等于任何值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isNaN()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>数值转换</p><ol><li><p>Number()</p><p> 布尔值，true 转换为 1，false 转换为 0。 </p><p> 数值，直接返回。</p><p> null，返回 0。 </p><p> undefined，返回 NaN。 </p><p> 字符串，应用以下规则。</p><p>​     如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”)返回 1，Number(“123”)返回      123，Number(“011”)返回 11（忽略前面的零）。</p><p>​     如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。</p><p>​     如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。</p><p>​     如果是空字符串（不包含字符），则返回 0。 </p><p>​     如果字符串包含除上述情况之外的其他字符，则返回 NaN。 </p><p> 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用toString()方法，再按照转换字符串的规则转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"Hello World"</span>)); <span class="comment">// NaN</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">" "</span>)); <span class="comment">// 0</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"000111"</span>)); <span class="comment">// 111</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>parseInt(str, ?radix)</p><p>更专注于字符串是否包含数值模式</p><p>字符串最前面的空格会被忽略，从第一个非空格字符开始转换,</p><p>如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN</p><p>如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"1234a34"</span>)); <span class="comment">// 1234</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"1.2"</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"0xa"</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">""</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"077"</span>)); <span class="comment">// 77</span></span><br></pre></td></tr></table></figure><p>如上我输入的是一个8进制的“077” 所以我们需要使用第二参数, 指定进制 范围为2-36,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"070"</span>, <span class="number">8</span>)); <span class="comment">// 63</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"078"</span>), <span class="number">8</span>)); <span class="comment">// 7 因为八进制中没有数字8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第二个参数为undefined, 0, 或者未指定的情况下, 相当于让方法根据当前环境来判断是多少进制的</span></span><br><span class="line"><span class="comment">// 现在浏览器一般都是十进制 当然 "0x"开头 会认为是十六进制</span></span><br><span class="line"><span class="comment">// 所以在使用parseInt的时候, 第二个参数最好不要省略</span></span><br></pre></td></tr></table></figure></li><li><p>parseFloat()</p><p>都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"1234a.333"</span>)); <span class="comment">// 1234</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"01.2.3"</span>)); <span class="comment">// 0.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"xxx"</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>)); <span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ol><ol start="6"><li><p><strong>String</strong> 类型</p><p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列, 可以用双引号(“”), 单引号(‘’), 反引号(``)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="keyword">let</span> str3 = <span class="string">`hello world`</span>;</span><br></pre></td></tr></table></figure><ul><li><p>字符字面量</p><table><thead><tr><th align="center">字面量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">制表</td></tr><tr><td align="center">\b</td><td align="center">退格</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\f</td><td align="center">换页</td></tr><tr><td align="center">\\</td><td align="center">反斜杠</td></tr><tr><td align="center">&#39;</td><td align="center">单引号</td></tr><tr><td align="center">&quot;</td><td align="center">双引号</td></tr><tr><td align="center">`</td><td align="center">反引号</td></tr><tr><td align="center">\xnn</td><td align="center">以十六进制编码 <em>nn</em> 表示的字符，例如\x41 等于”A”</td></tr><tr><td align="center">\unnnn</td><td align="center">以十六进制编码 <em>nnnn</em> 表示的 Unicode 字符，例如\u03a3 等于希腊字</td></tr></tbody></table><p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释</p><p>如果字符串中包含双字节字符，那么length 属性返回的值可能不是准确的字符数</p></li><li><p>字符串的特点</p><p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量</p></li><li><p>转换为字符串</p><p>使用几乎所有值都有的 toString()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> numStr = num.toString(); <span class="comment">// "11"</span></span><br><span class="line"><span class="keyword">let</span> isEdit = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> isEditStr = isEdit.toString(); <span class="comment">// "true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了undefined 和 null 都有toString() 方法 </span></span><br><span class="line"><span class="comment">// toString() 传入一个参数可以转换将原数字 转换成相应进制的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// "1011"</span></span><br></pre></td></tr></table></figure><p>如果你不确定是否是<code>undefined</code> 和 <code>null</code> 时你可以使用 <code>String()</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">10</span>)); <span class="comment">// "10" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">true</span>)); <span class="comment">// "true" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">null</span>)); <span class="comment">// "null" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">undefined</span>)); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure></li><li><p>模板字面量</p><p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"firstLine \n secondLine"</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">`firstLine</span></span><br><span class="line"><span class="string">secondLine`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); </span><br><span class="line"><span class="comment">// firstLine </span></span><br><span class="line"><span class="comment">// secondLine"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str1); </span><br><span class="line"><span class="comment">// firstLine </span></span><br><span class="line"><span class="comment">// secondLine</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字面量会保持反引号内部的空格</span></span><br></pre></td></tr></table></figure></li><li><p>字符串插值</p><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">'second'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前，字符串插值是这样实现的：</span></span><br><span class="line"><span class="keyword">let</span> str = value + <span class="string">' to the '</span> + exponent + <span class="string">' power is '</span> + (value * value); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，可以用模板字面量这样实现：</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value * value &#125;</span>`</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 5 to the second power is 25 </span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// 5 to the second power is 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有插入的值都会使用 toString()强制转型为字符串</span></span><br><span class="line"><span class="comment">// 模板里面也能直接执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`打印的是: <span class="subst">$&#123;printMessage(<span class="string">"wocao"</span>)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure></li><li><p>模板字面量标签函数</p><p>模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...rest</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(strings);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> _v <span class="keyword">of</span> rest) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(_v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"foobar"</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>; <span class="comment">// 三个变量 标签函数就是4个参数</span></span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>; </span><br><span class="line"><span class="comment">// ["", " + ", " = ", ""] </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 9 </span></span><br><span class="line"><span class="comment">// 15 </span></span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult); <span class="comment">// "6 + 9 = 15" </span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult); <span class="comment">// "foobar"</span></span><br></pre></td></tr></table></figure></li><li><p>原始字符串</p><p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此，可以使用默认的 String.raw 标签函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode 示例</span></span><br><span class="line"><span class="comment">// \u00A9 是版权符号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>); <span class="comment">// © </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>); <span class="comment">// \u00A9 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line\nsecond line`</span>); </span><br><span class="line"><span class="comment">// first line </span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// "first line\nsecond line"</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Symbol</strong> 类型</p><p>Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p><ul><li><p>基本用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> mySymbol);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以传入一个字符串 作为discription(描述)</span></span><br><span class="line"><span class="keyword">let</span> discriptionSymbol = <span class="built_in">Symbol</span>(<span class="string">"discription"</span>);</span><br><span class="line"><span class="keyword">let</span> discriptionSymvol1 = <span class="built_in">Symbol</span>(<span class="string">"discription"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(discriptionSymbol == discriptionSymvol1); <span class="comment">// fasle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol()函数不能与 new 关键字一起作为构造函数使用</span></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure></li><li><p>使用全局符号注册表</p><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol1 = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(globalSymbol === globalSymbol1); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 这里的global将会变成描述</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> globalSymbol2 = <span class="built_in">Symbol</span>.for(<span class="string">"xxx"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(globalSymbol2)); <span class="comment">// xxx</span></span><br><span class="line"><span class="comment">// keyFor() 这个方法接收全局符号，返回该全局符号对应的字符串键(描述), 如果不是返回undefined, 如果传入的不是Symbol 抛出类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>(<span class="string">"my"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(mySymbol)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(<span class="number">123</span>)); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></li><li><p>使用符号作为属性</p><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"s1"</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">"s2"</span>),</span><br><span class="line">    s3 = <span class="built_in">Symbol</span>(<span class="string">"s3"</span>),</span><br><span class="line">    s4 = <span class="built_in">Symbol</span>(<span class="string">"s4"</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [s1]: <span class="string">'s1'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;Symbol(s1): s1&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, s2, &#123;<span class="attr">value</span>: <span class="string">"s2"</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//  &#123;Symbol(s1): s1, Symbol(s2): s2&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    [s3]: &#123; <span class="attr">value</span>: <span class="string">"s3"</span> &#125;,</span><br><span class="line">    [s4]: &#123; <span class="attr">value</span>: <span class="string">"s4"</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;Symbol(s1): s1, Symbol(s2): s2, Symbol(s3): s3, Symbol(s4): s4&#125;</span></span><br></pre></td></tr></table></figure><p>类似于 Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"s1"</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">"s2"</span>),</span><br><span class="line">    s3 = <span class="string">'s3'</span>,</span><br><span class="line">    s4 = <span class="string">'s4'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [s1]: <span class="string">'s1'</span>,</span><br><span class="line">    [s2]: <span class="string">'s2'</span>,</span><br><span class="line">    s3,</span><br><span class="line">    s4</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">// ["s3", "s4"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj)); <span class="comment">// [Symbol(s1), Symbol(s2)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)); <span class="comment">// &#123;s3: &#123;...&#125;, s4: &#123;...&#125;, Symbol(s1): &#123;...&#125;, Symbol(s2): &#123;...&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj)); <span class="comment">// ["s3", "s4", Symbol(s1), Symbol(s2)]</span></span><br></pre></td></tr></table></figure><p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> [<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="string">'foo val'</span>, </span><br><span class="line"> [<span class="built_in">Symbol</span>(<span class="string">'bar'</span>)]: <span class="string">'bar val'</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(o); <span class="comment">// &#123;Symbol(foo): "foo val", Symbol(bar): "bar val"&#125; </span></span><br><span class="line"><span class="keyword">let</span> barSymbol = <span class="built_in">Object</span>.getOwnPropertySymbols(o) </span><br><span class="line"> .find(<span class="function">(<span class="params">symbol</span>) =&gt;</span> symbol.toString().match(<span class="regexp">/bar/</span>)); </span><br><span class="line"><span class="built_in">console</span>.log(barSymbol); <span class="comment">// Symbol(bar)</span></span><br></pre></td></tr></table></figure></li><li><p>常用的内置符号</p><p>ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。</p><p>这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为</p><p>这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p></li><li><p>Symbol.asyncIterator</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的 AsyncIterator。 由 for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器 API 的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for-await-of 循环会利用这个函数执行异步迭代操作。循环时，它们会调用以 Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API的 AsyncGenerator</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(test[<span class="built_in">Symbol</span>.asyncIterator]()); <span class="comment">//  AsyncGenerator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>技术上，这个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回Promise 实例。可以通过显式地调用 next()方法返回，也可以隐式地通过异步生成器函数返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(max) &#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        <span class="keyword">this</span>.asyncIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.asyncIndex &lt; <span class="keyword">this</span>.max) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="keyword">this</span>.asyncIndex++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span>(<span class="keyword">const</span> v <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncCount();<span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用的next()</span></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>Symbol.hasInstance</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例,由 instanceof 操作符使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系。以 Symbol.hasInstance 为键的函数会执行同样的操作，只是操作数对调了一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](foo)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>像之前的<code>Symbol.asyncIterator</code>一样我们也可以自定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFoo</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance] () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myFoo = <span class="keyword">new</span> MyFoo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myFoo <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](myFoo)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myFoo <span class="keyword">instanceof</span> MyFoo); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(MyFoo[<span class="built_in">Symbol</span>.hasInstance](myFoo)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.isConcatSpreadable</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat()打平其数组元素”。覆盖 Symbol.isConcatSpreadable 的值可以修改这个行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1[<span class="built_in">Symbol</span>.isConcatSpreadable]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.concat(arr1)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>; <span class="comment">// false 或者 假值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.cancat(arr1)); <span class="comment">// [1, 2, Array(2)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> likeArr = &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> likeArr1 = &#123;<span class="number">2</span>: <span class="string">'b'</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(likeArr1[<span class="built_in">Symbol</span>.isConcatSpreadable]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(likeArr.concat(likeArr1)); <span class="comment">// ['a', &#123;...&#125;]</span></span><br><span class="line">likeArr1[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(likeArr.concat(likeArr1)); <span class="comment">// ['a', 'b']</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.Iterator</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器 API 的函数。for-of 循环这样的语言结构会利用这个函数执行迭代操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line"> *[<span class="built_in">Symbol</span>.iterator]() &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// Generator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>技术上，这个由 Symbol.iterator 函数生成的对象应该通过其 next()方法陆续返回值。可以通过显式地调用 next()方法返回，也可以隐式地通过生成器函数返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(max) &#123;</span><br><span class="line">    <span class="keyword">this</span>.max = max;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">this</span>.index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count(); <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用next()</span></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: undefined, done: false &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.match</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用”。String.prototype.match()方法会使用以 Symbol.match 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.match]); <span class="comment">// ƒ [Symbol.match]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fof'</span>.match(<span class="regexp">/f/</span>)); <span class="comment">// ["f", index: 0, input: "fof", groups: undefined]</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义 Symbol.match 函数以取代默认对正则表达式求值的行为，从而让match()方法使用非正则表达式实例。Symbol.match 函数接收一个参数，就是调用 match()方法的字符串实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript"</span>;</span><br><span class="line">str.match(); <span class="comment">// ["", index: 0, input: "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript.", groups: undefined]</span></span><br><span class="line">str.match(<span class="string">"number"</span>); <span class="comment">// ["number", index: 16, input: "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript.", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">[<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">        <span class="keyword">return</span> target.includes(<span class="keyword">this</span>.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobar'</span>.match(<span class="keyword">new</span> MyMatcher(<span class="string">'foo'</span>))); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barbaz'</span>.match(<span class="keyword">new</span> MyMatcher(<span class="string">'qux'</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.replace</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用”。String.prototype.replace()方法会使用以 Symbol.replace 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.replace]); <span class="comment">// ƒ [Symbol.replace]() &#123; [native code] &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobarbaz'</span>.replace(<span class="regexp">/bar/</span>, <span class="string">'qux'</span>)); <span class="comment">// 'fooquxbaz'</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.replace 函数以取代默认对正则表达式求值的行为，从而让replace()方法使用非正则表达式实例。Symbol.replace 函数接收两个参数，即调用 replace()方法的字符串实例和替换字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str.replace(<span class="string">"number"</span>, <span class="string">"Number"</span>); <span class="comment">// "NaN means not a Number. Infinity contains -Infinity and +Infinity in JavaScript"</span></span><br><span class="line">str.replace(<span class="literal">NaN</span>, <span class="string">'nAn'</span>); <span class="comment">// "nAn means not a number. Infinity contains -Infinity and +Infinity in JavaScript"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReplacer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">        <span class="keyword">return</span> target.split(<span class="keyword">this</span>.str).join(replacement);</span><br><span class="line">        <span class="comment">// return false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barfoobaz'</span>.replace(<span class="keyword">new</span> MyReplacer(<span class="string">'foo'</span>), <span class="string">'qux'</span>)); <span class="comment">// "barquxbaz"</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.search</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用”。String.prototype.search()方法会使用以 Symbol.search 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.search]); <span class="comment">// ƒ [Symbol.search]() &#123; [native code] &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobar'</span>.search(<span class="regexp">/bar/</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.search 函数以取代默认对正则表达式求值的行为，从而让search()方法使用非正则表达式实例。Symbol.search 函数接收一个参数，就是调用 match()方法的字符串实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">        <span class="keyword">return</span> target.indexOf(<span class="keyword">this</span>.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobar'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'foo'</span>))); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barfoo'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'foo'</span>))); <span class="comment">// 3 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barbaz'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'qux'</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.species</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray1 = <span class="keyword">new</span> MyArray1();</span><br><span class="line"><span class="built_in">console</span>.log(myArray1 <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myArray1 <span class="keyword">instanceof</span> MyArray1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray2 = <span class="keyword">new</span> MyArray2();</span><br><span class="line"><span class="built_in">console</span>.log(myArray2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myArray2 <span class="keyword">instanceof</span> MyArray2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.split</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用”。String.prototype.split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.split]); <span class="comment">// ƒ [Symbol.split]() &#123; [native code] &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobarbaz'</span>.split(<span class="regexp">/bar/</span>)); <span class="comment">// ['foo', 'baz']</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.split 函数以取代默认对正则表达式求值的行为，从而让 split()方法使用非正则表达式实例。Symbol.split 函数接收一个参数，就是调用 match()方法的字符串实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpliter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">        <span class="keyword">return</span> target.split(<span class="keyword">this</span>.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barfoobaz'</span>.split(<span class="keyword">new</span> MySpliter(<span class="string">'foo'</span>))); <span class="comment">// ["bar", "baz"]</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.toPrimitive</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的 Symbol.toPrimitive 属性上定义一个函数可以改变默认行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125; </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + foo); <span class="comment">// "3[object Object]" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - foo); <span class="comment">// NaN </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(foo)); <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyToPrimitive</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123; <span class="comment">// hint 暗示 会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型</span></span><br><span class="line">            <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'number'</span>: </span><br><span class="line">                    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'string primitive'</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'default'</span>: </span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'我是默认值'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mytp = <span class="keyword">new</span> MyToPrimitive();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + mytp); <span class="comment">// 10 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - mytp); <span class="comment">// -7 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(mytp)); <span class="comment">// "string primitive"</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.toStringTag</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用”。通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为”Object”。内置类型已经指定了这个值，但自定义类实例还需要明确定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'MyObject'</span>; <span class="comment">// 这里的xxx 就相当于 你toString() [object xxx]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="built_in">console</span>.log(my) <span class="comment">// MyObject &#123; [Symbol(Symbol.toStringTag)]: 'MyObject' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(my.toString()); <span class="comment">// [object MyObject]</span></span><br><span class="line"><span class="built_in">console</span>.log(my[<span class="built_in">Symbol</span>.toStringTag]); <span class="comment">// MyObject</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol.unscopables</p><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除”。设置这个符号并让其映射对应属性的键值为 true，就可以阻止该属性出现在 with 环境绑定中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;; </span><br><span class="line"><span class="keyword">with</span> (o) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(foo); <span class="comment">// bar </span></span><br><span class="line">&#125; </span><br><span class="line">o[<span class="built_in">Symbol</span>.unscopables] = &#123; </span><br><span class="line"> foo: <span class="literal">true</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">with</span> (o) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐使用 with，因此也不推荐使用 Symbol.unscopables</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Object</strong> 类型</p><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>每个 Object 实例都有如下属性和方法。</p><ul><li><p>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object() 函数。</p></li><li><p>hasOwnProperty(<em>propertyName</em>)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串或符号。</p></li><li><p>isPrototypeOf(<em>object</em>)：用于判断当前对象是否为另一个对象的原型</p></li><li><p>propertyIsEnumerable(<em>propertyName</em>)：用于判断给定的属性是否可以使用）for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</p></li><li><p>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</p></li><li><p>toString()：返回对象的字符串表示。</p></li><li><p>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同</p></li></ul></li></ol><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ol><li><p>一元操作符</p><p>只操作一个值的操作符叫一元操作符（unary operator）一元操作符是 ECMAScript中最简单的操作符</p><ul><li><p>递增/递减操作符</p><p>前加加/前减减 都是先加/减之后的值 再计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> result = ++num - <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = --num - <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>后加加/后减减 是先计算 再自增/自减</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> result = ++num - <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = --num - <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>参与操作的值 的类型可以为 数字, 字符串, 布尔值, 对象,</p><p>都遵循以下的规则: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"2"</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">"z"</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> valueOf() &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</span></span><br><span class="line">s1++; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值</span></span><br><span class="line">s2++; <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值</span></span><br><span class="line"><span class="comment">// 对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。</span></span><br><span class="line">b++; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于浮点值，加 1 或减 1。</span></span><br><span class="line">f++; <span class="comment">// 2.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是对象，则调用其valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值</span></span><br><span class="line">o--; <span class="comment">// -2</span></span><br></pre></td></tr></table></figure></li><li><p>一元加和减</p><p>将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换：布尔值 false和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toString()方法以得到可以转换的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"01"</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">"1.1"</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">"z"</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> valueOf() &#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">s1 = +s1; <span class="comment">//  1 </span></span><br><span class="line">s2 = +s2; <span class="comment">//  1.1 </span></span><br><span class="line">s3 = +s3; <span class="comment">// NaN </span></span><br><span class="line">b = +b; <span class="comment">// 0 </span></span><br><span class="line">f = +f; <span class="comment">// 1.1 </span></span><br><span class="line">o = +o; <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>一元减由一个减号（-）表示，放在变量前头，主要用于把数值变成负值，如把 1 转换为-1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> num1 = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>对数值使用一元减会将其变成相应的负值（如上面的例子所示）。在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = -s1; <span class="comment">// -1 </span></span><br><span class="line">s2 = -s2; <span class="comment">// -1.1 </span></span><br><span class="line">s3 = -s3; <span class="comment">// NaN </span></span><br><span class="line">b = -b; <span class="comment">// 0 </span></span><br><span class="line">f = -f; <span class="comment">// -1.1 </span></span><br><span class="line">o = -o; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>位操作符</p><p>有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式</p><p>正值以真正的二进制格式存储，即 31位中的每一位都代表 2 的幂</p><p>负值以一种称为二补数（或补码）的二进制编码存储</p><ul><li><p>按位非 (按位取反)</p><p>按位非操作符用波浪符（~）表示，它的作用是返回数值的一补数。按位非是 ECMAScript 中为数不多的几个二进制数学操作符之一</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> num1 = ~num;</span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">// -31</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">30</th></tr></thead><tbody><tr><td align="center">二进制</td><td align="center">0000 0000 0000 0000 0000 0000 0001 1110</td></tr><tr><td align="center">按位非</td><td align="center">1111 1111 1111 1111 1111 1111  1110 0001</td></tr><tr><td align="center">减1</td><td align="center">1111 1111 1111 1111 1111 1111 1110 0000</td></tr><tr><td align="center">取反</td><td align="center">1000 0000 0000 0000 0000 0000 0001 1111</td></tr><tr><td align="center">按位非十进制</td><td align="center">-31</td></tr></tbody></table><p>按位非操作符作用到了数值 25，得到的结果是26。由此可以看出，按位非的最终效果是对数值取反并减 1</p></li><li><p>按位与</p><p>按位与操作符用和号（&amp;）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作</p><p>两个都是1 才为1</p><table><thead><tr><th align="center">第一个数值位</th><th align="center">第二个数值位</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">28</span> &amp; <span class="number">9</span>; <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">二进制</th></tr></thead><tbody><tr><td align="center">28</td><td align="center">0000 0000 0000 0000 0000 0000 0001 1100</td></tr><tr><td align="center">9</td><td align="center">0000 0000 0000 0000 0000 0000 0000 1001</td></tr><tr><td align="center">最后结果</td><td align="center">0000 0000 0000 0000 0000 0000 0000 1000</td></tr></tbody></table></li><li><p>按位或</p><p>按位或操作符用管道符（|）表示，同样有两个操作数  有1才为1</p><table><thead><tr><th align="center">第一个数值位</th><th align="center">第二个数值位</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">28</span> | <span class="number">9</span>; <span class="comment">// 29</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">二进制</th></tr></thead><tbody><tr><td align="center">28</td><td align="center">0000 0000 0000 0000 0000 0000 0001 1100</td></tr><tr><td align="center">9</td><td align="center">0000 0000 0000 0000 0000 0000 0000 1001</td></tr><tr><td align="center">最后结果</td><td align="center">0000 0000 0000 0000 0000 0000 0001 1101</td></tr></tbody></table></li><li><p>按位异或</p><p>按位异或用脱字符（^）表示，同样有两个操作数 有且只有一个为1 才是1</p><table><thead><tr><th align="center">第一个数值位</th><th align="center">第二个数值位</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">28</span> ^ <span class="number">9</span>; <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">二进制</th></tr></thead><tbody><tr><td align="center">28</td><td align="center">0000 0000 0000 0000 0000 0000 0001 1100</td></tr><tr><td align="center">9</td><td align="center">0000 0000 0000 0000 0000 0000 0000 1001</td></tr><tr><td align="center">最后结果</td><td align="center">0000 0000 0000 0000 0000 0000 0001 0101</td></tr></tbody></table></li><li><p>左移</p><p>左移操作符用两个小于号（&lt;&lt;）表示，会按照指定的位数将数值的所有位向左移动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ov = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> nv = <span class="number">3</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">二进制</th></tr></thead><tbody><tr><td align="center">3</td><td align="center">0000 0000 0000 0000 0000 0000 0000 0011</td></tr><tr><td align="center">&lt;&lt; 2</td><td align="center">0000 0000 0000 0000 0000 0000 0000 1100</td></tr></tbody></table><p>左移是会保留符号的</p></li><li><p>有符号右移</p><p>有符号右移由两个大于号（&gt;&gt;）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）有符号右移实际上是左移的逆运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ov = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> nv = <span class="number">12</span> &gt;&gt; <span class="number">2</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">二进制</th></tr></thead><tbody><tr><td align="center">12</td><td align="center">0000 0000 0000 0000 0000 0000 0000 1100</td></tr><tr><td align="center">&gt;&gt; 2</td><td align="center">0000 0000 0000 0000 0000 0000 0000 0011</td></tr></tbody></table></li><li><p>无符号右移</p><p>无符号右移用 3 个大于号表示（&gt;&gt;&gt;），会将数值的所有 32 位都向右移。</p><p>对于正数，无符号右移与有符号右移结果相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ov = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> nv = ov &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>对于负数, 无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ov = <span class="number">-12</span>; <span class="comment">// 负数在javascript中存储的是 绝对值的反码的再加一</span></span><br><span class="line"><span class="keyword">let</span> nv = ov &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// 1073741821</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">-12</th><th align="center">二进制</th></tr></thead><tbody><tr><td align="center">绝对值的二进制</td><td align="center">0000 0000 0000 0000 0000 0000 0000 1100</td></tr><tr><td align="center">反码</td><td align="center">1111 1111 1111 1111 1111 1111 1111 0011</td></tr><tr><td align="center">补码</td><td align="center">1111 1111 1111 1111 1111 1111 1111 0100</td></tr><tr><td align="center">&gt;&gt;&gt; 2</td><td align="center">0011 1111 1111 1111 1111 1111 1111 1101</td></tr><tr><td align="center">转为10进制</td><td align="center">1073741821</td></tr></tbody></table></li></ul></li></ol><ol start="3"><li><p>布尔操作符</p><ul><li><p>逻辑非</p><p>逻辑非操作符由一个叹号（!）表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反.</p><ol><li>如果操作数是对象,  返回 <code>false</code></li><li>如果操作数是空字符串, 返回 <code>true</code></li><li>如果操作数是非空字符串, 返回 <code>false</code></li><li>如果操作数是0, 返回 <code>true</code></li><li>如果操作数是非0(包括Infinity), 返回 <code>false</code></li><li>如果操作数是null, 返回 <code>true</code></li><li>如果操作数是NaN, 返回 <code>true</code></li><li>如果操作数是undefined, 返回 <code>true</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果操作数是对象,  返回false</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(!obj); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是空字符串, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">""</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是非空字符串, 返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">"1"</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是0, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是非0(包括Infinity), 返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是null, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是NaN, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是undefined, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值</p></li><li><p>逻辑与</p><p>逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值</p><table><thead><tr><th align="center">第一个操作数</th><th align="center">第二个操作数</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">true</td><td align="center">true</td><td align="center">true</td></tr><tr><td align="center">true</td><td align="center">false</td><td align="center">false</td></tr><tr><td align="center">false</td><td align="center">true</td><td align="center">false</td></tr><tr><td align="center">false</td><td align="center">false</td><td align="center">false</td></tr></tbody></table><p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值</p><ol><li>如果第一个操作数是对象, 则返回第二个操作数</li><li>如果第二个操作数是对象, 则只有在第一个操作数为t<code>true</code> 时返回对象</li><li>如果两个操作数都是对象, 则返回第二个对象</li><li>如果第一个操作符是null, 则返回null</li><li>如果第一个操作数是NaN, 则返回NaN</li><li>如果第一个操作数是undefined, 则返回undefined</li></ol><p>大概意思就是 只有在第一个操作数为真的情况下 才会返回或者执行第二个操作数</p></li><li><p>逻辑或</p><p>逻辑或操作符由两个管道符（||）表示</p><table><thead><tr><th align="center">第一个操作数</th><th align="center">第二个操作数</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">true</td><td align="center">true</td><td align="center">true</td></tr><tr><td align="center">true</td><td align="center">false</td><td align="center">true</td></tr><tr><td align="center">false</td><td align="center">true</td><td align="center">true</td></tr><tr><td align="center">false</td><td align="center">false</td><td align="center">false</td></tr></tbody></table><p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值</p><ol><li>如果第一个操作数是对象, 则返回第一个操作数</li><li>如果第一个操作数是false, 则返回第二个操作数</li><li>如果两个操作数都是对象, 则返回第一个操作数</li><li>如果两个操作数都是null, 返回null</li><li>如果两个操作数都是NaN, 返回NaN</li><li>如果两个操作数都是undefined, 返回undefined</li></ol><p>大概意思就是, 只要第一个操作数为真, 返回第一个, 否则返回第二个</p></li></ul></li><li><p>乘性操作符</p><p>ECMAScript 定义了 3 个乘性操作符：乘法、除法和取模.  在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有</p><p>不是数值的操作数，则该操作数会在后台被使用 Number()转型函数转换为数值</p><ul><li><p>乘法操作符</p><p>乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积</p><ol><li>如果操作数都是数值, 该怎么来怎么来, 结果不能表示会得到<code>Infinity</code> 或者 <code>-Infinity</code></li><li>如果有一个操作数是NaN, 则返回NaN</li><li>如果是Infinity乘以0, 返回NaN</li><li>如果是Infinity乘以非0, 则根据第二个操作数的符号返回 <code>Infinity</code> 或者 <code>-Infinity</code></li><li>如果是Infinity 乘以 Infinity, 返回 <code>Infinity</code></li><li>如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则</li></ol></li><li><p>除法操作符</p><p>除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商</p><ol><li>如果操作数都是数值, 该怎么算怎么算</li><li>如果有任一操作数是 NaN，则返回 NaN</li><li>如果是 Infinity 除以 Infinity，则返回 NaN</li><li>如果是 0 除以 0，则返回 NaN</li><li>如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或-Infinity</li><li>如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或-Infinity</li><li>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则</li></ol></li><li><p>取模操作符</p><p>取模（余数）操作符由一个百分比符号（%）表示</p><ol><li>取模（余数）操作符由一个百分比符号（%）表示</li><li>如果被除数是无限值，除数是有限值，则返回 NaN</li><li>如果被除数是有限值，除数是 0，则返回 NaN</li><li>如果是 Infinity 除以 Infinity，则返回 NaN</li><li>如果被除数是有限值，除数是无限值，则返回被除数</li><li>如果被除数是 0，除数不是 0，则返回 0</li><li>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则</li></ol></li></ul></li><li><p>指数操作符</p><p>ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 9 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> ** <span class="number">2</span>); <span class="comment">// 9 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">16</span>, <span class="number">0.5</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">16</span>** <span class="number">0.5</span>); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>; </span><br><span class="line">squared **= <span class="number">2</span>; </span><br><span class="line"><span class="built_in">console</span>.log(squared); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></li><li><p>加性操作符</p><ul><li><p>加法操作符</p><p>加法操作符（+）用于求两个数的和</p><p>如果两个都是数字:</p><ol><li>如果有任一操作数是 NaN，则返回 NaN</li><li>如果是 Infinity 加 Infinity，则返回 Infinity</li><li>如果是-Infinity 加-Infinity，则返回-Infinity</li><li>如果是 Infinity 加-Infinity，则返回 NaN</li><li>如果是+0 加+0，则返回+0</li><li>如果是-0 加+0，则返回+0</li><li>如果是-0 加-0，则返回-0</li></ol><p>如果有一个是字符串</p><ol><li>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面</li><li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起</li><li>如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则</li></ol></li><li><p>减法操作符</p><p>减法操作符（-）也是使用很频繁的一种操作符</p><ol><li>如果两个操作数都是数值，则执行数学减法运算并返回结果</li><li>如果有任一操作数是 NaN，则返回 NaN</li><li>如果是 Infinity 减 Infinity，则返回 NaN</li><li>如果是-Infinity 减-Infinity，则返回 NaN</li><li>如果是 Infinity 减-Infinity，则返回 Infinity</li><li>如果是-Infinity 减 Infinity，则返回-Infinity</li><li>如果是+0 减+0，则返回+0</li><li>如果是+0 减-0，则返回-0</li><li>如果是-0 减-0，则返回+0</li><li>如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算</li><li>如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。</li></ol></li></ul></li><li><p>关系操作符</p><p>关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）这几个操作符都返回布尔值</p><ol><li>如果操作数都是数值，则执行数值比较。</li><li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码</li><li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较</li><li>如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较</li><li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li></ol></li><li><p>相等操作符</p><ul><li><p>等于和不等于</p><p>ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等</p><ol><li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等</li><li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较</li><li>null 和 undefined 相等</li><li>null 和 undefined 不能转换为其他类型的值再进行比较</li><li>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等</li></ol><table><thead><tr><th align="center">表达式</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">null == undefined</td><td align="center">true</td></tr><tr><td align="center">“NaN” == NaN</td><td align="center">false</td></tr><tr><td align="center">5 == NaN</td><td align="center">false</td></tr><tr><td align="center">NaN == NaN</td><td align="center">false</td></tr><tr><td align="center">NaN != NaN</td><td align="center">true</td></tr><tr><td align="center">false == 0</td><td align="center">true</td></tr><tr><td align="center">true == 1</td><td align="center">true</td></tr><tr><td align="center">true == 2</td><td align="center">false</td></tr><tr><td align="center">undefined == 0</td><td align="center">false</td></tr><tr><td align="center">null == 0</td><td align="center">false</td></tr><tr><td align="center">“5” == 5</td><td align="center">true</td></tr></tbody></table></li><li><p>全等与不全等</p><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true</p><p>由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性</p></li></ul></li><li><p>条件操作符</p><p>条件操作符是 ECMAScript 中用途最为广泛的操作符之一 (三元运算)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure></li><li><p>赋值操作符</p><p>简单赋值用等于号（=）表示，将右手边的值赋给左手边的变量</p><ul><li>乘后赋值（*=）</li><li>除后赋值（/=）</li><li>取模后赋值（%=）</li><li>加后赋值（+=）</li><li>减后赋值（-=）</li><li>左移后赋值（&lt;&lt;=）</li><li>右移后赋值（&gt;&gt;=）</li><li>无符号右移后赋值（&gt;&gt;&gt;=）</li></ul></li><li><p>逗号操作符</p><p>逗号操作符可以用来在一条语句中执行多个操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMA-262 描述了一些语句（也称为流控制语句），而 ECMAScript 中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令</p><ol><li><p>if语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statement2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do-while语句</p><p>do-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line"> statement </span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure></li><li><p>while语句</p><p>while 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while 循环体内的代码有可能不会执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>for语句</p><p>for 语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; expression; post-loop-expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>for-in语句</p><p>for-in 语句是一种严格的迭代语句，用于枚举对象中的<strong>非符号</strong>键属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (property <span class="keyword">in</span> expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-in 语句不能保证返回对象属性的顺序, 如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体</p></li><li><p>for-of语句</p><p>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (property <span class="keyword">of</span> expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素</p><p>如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误。</p></li><li><p>标签语句</p><p>标签语句用于给语句加标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label: statement</span><br></pre></td></tr></table></figure></li><li><p>break 和 continuey语句</p><p>break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// i=5时 满足条件 直接退出for循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    num++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// i=5时 满足条件, 退出当前的循环, 所以不会执行num++ i=10时  也不会执行 num++</span></span><br><span class="line">    &#125;</span><br><span class="line">    num1++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>; </span><br><span class="line">outermost: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123; </span><br><span class="line"> <span class="keyword">break</span> outermost; <span class="comment">// 只是一个break不会跳出i的循环 但是加了标签 所以相当于跳出了两层for循环</span></span><br><span class="line"> &#125; </span><br><span class="line"> num++; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">0</span>; </span><br><span class="line">outermost: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123; </span><br><span class="line"> <span class="keyword">continue</span> outermost; <span class="comment">// 也是跳出两层循环 相当于从 i = 6 开始 之前也就少了 i = 5时, j = 5, 6, 7, 8, 9 num1少自增了5次</span></span><br><span class="line"> &#125; </span><br><span class="line"> num1++; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure></li><li><p>with语句</p><p>with 语句的用途是将代码作用域设置为特定的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有使用with</span></span><br><span class="line"><span class="keyword">let</span> qs = location.search.substring(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> hostName = location.hostname; </span><br><span class="line"><span class="keyword">let</span> url = location.href;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with</span></span><br><span class="line"><span class="keyword">with</span> (location) &#123; </span><br><span class="line"> <span class="keyword">let</span> qs = search.substring(<span class="number">1</span>); </span><br><span class="line"> <span class="keyword">let</span> hostName = hostname; </span><br><span class="line"> <span class="keyword">let</span> url = href; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>严格模式不允许使用 with 语句，否则会抛出错误</p><p>由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with语句。</p></li><li><p>switch 语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123; </span><br><span class="line"> <span class="keyword">case</span> value1: </span><br><span class="line"> statement </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> value2: </span><br><span class="line"> statement </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> value3: </span><br><span class="line"> statement </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">case</span> value4: </span><br><span class="line"> statement </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">default</span>: </span><br><span class="line"> statement </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为避免不必要的条件判断，最好给每个条件后面都加上 break 语句</p><p>switch 语句在比较每个条件的值时会使用全等操作符</p></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体</p>]]></content>
    
    <summary type="html">
    
      笔记
    
    </summary>
    
    
    
      <category term="读后笔记" scheme="http://blog.decade.run/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>element-ui-3-源码学习-4</title>
    <link href="http://blog.decade.run/2020/11/09/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-4/"/>
    <id>http://blog.decade.run/2020/11/09/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-4/</id>
    <published>2020-11-09T02:29:41.000Z</published>
    <updated>2020-11-09T02:58:54.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="checkboxGroup-文件路径-package-checkbox-group"><a href="#checkboxGroup-文件路径-package-checkbox-group" class="headerlink" title="checkboxGroup 文件路径 package/checkbox-group"></a><code>checkboxGroup</code> 文件路径 <code>package/checkbox-group</code></h3><p><code>2.x</code>和<code>3.0</code>没有多大的差别 有差别了 我再抽出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;el-checkbox-group&quot; role&#x3D;&quot;group&quot; aria-label&#x3D;&quot;checkbox-group&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; useEmitter &#125; from &#39;..&#x2F;..&#x2F;src&#x2F;use&#x2F;emitter&#39;</span><br><span class="line">import &#123; provide, getCurrentInstance, computed, inject &#125; from &#39;vue&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;ElCheckboxGroup&#39;,</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: Array,</span><br><span class="line">    disabled: Boolean,</span><br><span class="line">    min: Number,</span><br><span class="line">    max: Number,</span><br><span class="line">    size: String,</span><br><span class="line">    fill: String,</span><br><span class="line">    textColor: String,</span><br><span class="line">    border: Boolean</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 定义的emit</span><br><span class="line">  emits: [&#39;update:modelValue&#39;, &#39;change&#39;],</span><br><span class="line"></span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 拿到el-form注入的</span><br><span class="line">    const elForm &#x3D; inject(&#39;elForm&#39;, &#123; props: &#123;&#125;, ctx: &#123;&#125; &#125;)</span><br><span class="line">    &#x2F;&#x2F; 拿到el-form-item注入的</span><br><span class="line">    const elFormItem &#x3D; inject(&#39;elFormItem&#39;, &#123;</span><br><span class="line">      props: &#123;&#125;,</span><br><span class="line">      ctx: &#123;&#125;,</span><br><span class="line">      emit: () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 提供给checkbox的</span><br><span class="line">    provide(&#39;elCheckboxGroup&#39;, getCurrentInstance())</span><br><span class="line">    &#x2F;&#x2F; 取出dispatch 和 on 方法</span><br><span class="line">    const &#123; dispatch, on &#125; &#x3D; useEmitter()</span><br><span class="line">    &#x2F;&#x2F; 返回checkboxGroup的size 当前自己没定义 如果在el-form中就看el-form-item里面有没有定义</span><br><span class="line">    const checkboxGroupSize &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">      return props.size || elFormItem.ctx.elFormItemSize</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 返回checkboxGroup的disabled 原理同上 多了一看el-form的disabled定义没有</span><br><span class="line">    const checkboxGroupDisabled &#x3D; computed(() &#x3D;&gt; &#123;</span><br><span class="line">      return props.disabled || elFormItem.disabled || elForm.disabled</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F; 接收到事件 然后继续向上发射 和派发事件</span><br><span class="line">    on(&#39;update:modelValue&#39;, (v) &#x3D;&gt; &#123;</span><br><span class="line">      emit(&#39;update:modelValue&#39;, v)</span><br><span class="line">      dispatch(&#39;el.form.change&#39;, v)</span><br><span class="line">    &#125;)</span><br><span class="line">&#x2F;&#x2F; 接收到change, 发射change</span><br><span class="line">    on(&#39;change&#39;, (v) &#x3D;&gt; &#123;</span><br><span class="line">      emit(&#39;change&#39;, v)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      checkboxGroupSize,</span><br><span class="line">      checkboxGroupDisabled</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>checkbox-button</code> 的逻辑和 <code>checkbox</code> 的逻辑差不多.我就不怎么分析了</p>]]></content>
    
    <summary type="html">
    
      element Ui 学习笔记
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="element-ui" scheme="http://blog.decade.run/tags/element-ui/"/>
    
  </entry>
  
  <entry>
    <title>element-ui-3-源码学习-3</title>
    <link href="http://blog.decade.run/2020/11/05/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-3/"/>
    <id>http://blog.decade.run/2020/11/05/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-3/</id>
    <published>2020-11-05T01:51:48.000Z</published>
    <updated>2020-11-09T03:01:01.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="checkbox-组件"><a href="#checkbox-组件" class="headerlink" title="checkbox 组件"></a>checkbox 组件</h3><p><strong><code>文件位置</code></strong>  <code>2.x</code> 的在<code>packages/checkbox/src/checkbox.vue</code>  因为 <code>2.x</code> 与 <code>3.0</code> 在重构上存在 少许差异 我分开来分析</p><h4 id="2-x"><a href="#2-x" class="headerlink" title="2.x"></a>2.x</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;label</span><br><span class="line">    class&#x3D;&quot;el-checkbox&quot;</span><br><span class="line">    :class&#x3D;&quot;[</span><br><span class="line">      border &amp;&amp; checkboxSize ? &#39;el-checkbox--&#39; + checkboxSize : &#39;&#39;,</span><br><span class="line">      &#123; &#39;is-disabled&#39;: isDisabled &#125;,</span><br><span class="line">      &#123; &#39;is-bordered&#39;: border &#125;,</span><br><span class="line">      &#123; &#39;is-checked&#39;: isChecked &#125;</span><br><span class="line">    ]&quot;</span><br><span class="line">    :id&#x3D;&quot;id&quot;</span><br><span class="line">  &gt;&lt;!-- border存在的情况下 checkboxSize才能生效 --&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;el-checkbox__input&quot;</span><br><span class="line">      :class&#x3D;&quot;&#123;</span><br><span class="line">        &#39;is-disabled&#39;: isDisabled,</span><br><span class="line">        &#39;is-checked&#39;: isChecked,</span><br><span class="line">        &#39;is-indeterminate&#39;: indeterminate,</span><br><span class="line">        &#39;is-focus&#39;: focus</span><br><span class="line">      &#125;&quot;</span><br><span class="line">      :tabindex&#x3D;&quot;indeterminate ? 0 : false&quot;</span><br><span class="line">      :role&#x3D;&quot;indeterminate ? &#39;checkbox&#39; : false&quot;</span><br><span class="line">      :aria-checked&#x3D;&quot;indeterminate ? &#39;mixed&#39; : false&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;el-checkbox__inner&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        v-if&#x3D;&quot;trueLabel || falseLabel&quot;</span><br><span class="line">        class&#x3D;&quot;el-checkbox__original&quot;</span><br><span class="line">        type&#x3D;&quot;checkbox&quot;</span><br><span class="line">        :aria-hidden&#x3D;&quot;indeterminate ? &#39;true&#39; : &#39;false&#39;&quot;</span><br><span class="line">        :name&#x3D;&quot;name&quot;</span><br><span class="line">        :disabled&#x3D;&quot;isDisabled&quot;</span><br><span class="line">        :true-value&#x3D;&quot;trueLabel&quot;</span><br><span class="line">        :false-value&#x3D;&quot;falseLabel&quot;</span><br><span class="line">        v-model&#x3D;&quot;model&quot;</span><br><span class="line">        @change&#x3D;&quot;handleChange&quot;</span><br><span class="line">        @focus&#x3D;&quot;focus &#x3D; true&quot;</span><br><span class="line">        @blur&#x3D;&quot;focus &#x3D; false&quot;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        v-else</span><br><span class="line">        class&#x3D;&quot;el-checkbox__original&quot;</span><br><span class="line">        type&#x3D;&quot;checkbox&quot;</span><br><span class="line">        :aria-hidden&#x3D;&quot;indeterminate ? &#39;true&#39; : &#39;false&#39;&quot;</span><br><span class="line">        :disabled&#x3D;&quot;isDisabled&quot;</span><br><span class="line">        :value&#x3D;&quot;label&quot;</span><br><span class="line">        :name&#x3D;&quot;name&quot;</span><br><span class="line">        v-model&#x3D;&quot;model&quot;</span><br><span class="line">        @change&#x3D;&quot;handleChange&quot;</span><br><span class="line">        @focus&#x3D;&quot;focus &#x3D; true&quot;</span><br><span class="line">        @blur&#x3D;&quot;focus &#x3D; false&quot;&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;el-checkbox__label&quot; v-if&#x3D;&quot;$slots.default || label&quot;&gt;</span><br><span class="line">      &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">      &lt;template v-if&#x3D;&quot;!$slots.default&quot;&gt;&#123;&#123;label&#125;&#125;&lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;label&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Emitter from &#39;element-ui&#x2F;src&#x2F;mixins&#x2F;emitter&#39;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;ElCheckbox&#39;,</span><br><span class="line"></span><br><span class="line">    mixins: [Emitter], &#x2F;&#x2F; 混入emitter</span><br><span class="line"></span><br><span class="line">    inject: &#123;</span><br><span class="line">      elForm: &#123;</span><br><span class="line">        default: &#39;&#39;</span><br><span class="line">      &#125;,</span><br><span class="line">      elFormItem: &#123;</span><br><span class="line">        default: &#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    componentName: &#39;ElCheckbox&#39;,</span><br><span class="line"></span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        selfModel: false, &#x2F;&#x2F; 组件自己的model 如果没有传入 默认不checked</span><br><span class="line">        focus: false, &#x2F;&#x2F; 控制组件是否聚焦</span><br><span class="line">        isLimitExceeded: false &#x2F;&#x2F; 是否超出限制</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    computed: &#123;</span><br><span class="line">      model: &#123;</span><br><span class="line">        get() &#123;</span><br><span class="line">          return this.isGroup</span><br><span class="line">            ? this.store : this.value !&#x3D;&#x3D; undefined</span><br><span class="line">              ? this.value : this.selfModel; &#x2F;&#x2F; 如果checkboxgroup有没有指定值,有且不为undefined则用, 没有或者为undefined用checkbox指定的, 如果checkbox也没指定 则为默认的false</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        set(val) &#123;</span><br><span class="line">          if (this.isGroup) &#123; &#x2F;&#x2F; 处于checkboxgroup中 至少会有两个checkbox 所以val是数组</span><br><span class="line">            this.isLimitExceeded &#x3D; false;</span><br><span class="line">            &#x2F;&#x2F; 如果checkboxgroup组件的min属性值不为undefined 且 当前选中的checkbox个数 小于 min 就会实现限制效果</span><br><span class="line">            (this._checkboxGroup.min !&#x3D;&#x3D; undefined &amp;&amp;</span><br><span class="line">              val.length &lt; this._checkboxGroup.min &amp;&amp;</span><br><span class="line">              (this.isLimitExceeded &#x3D; true));</span><br><span class="line">   &#x2F;&#x2F; 如果checkboxgroup组件的max属性值不为undefined 且 当前选中的checkbox个数 超过 max 就会实现限制效果</span><br><span class="line">            (this._checkboxGroup.max !&#x3D;&#x3D; undefined &amp;&amp;</span><br><span class="line">              val.length &gt; this._checkboxGroup.max &amp;&amp;</span><br><span class="line">              (this.isLimitExceeded &#x3D; true));</span><br><span class="line"></span><br><span class="line">            this.isLimitExceeded &#x3D;&#x3D;&#x3D; false &amp;&amp;</span><br><span class="line">            this.dispatch(&#39;ElCheckboxGroup&#39;, &#39;input&#39;, [val]); &#x2F;&#x2F; 只有没有限制 的时候才能派发事件</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.$emit(&#39;input&#39;, val); &#x2F;&#x2F; 不处于直接触发input事件</span><br><span class="line">            this.selfModel &#x3D; val;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 控制是否checked</span><br><span class="line">      isChecked() &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果是布尔值</span><br><span class="line">        if (&#123;&#125;.toString.call(this.model) &#x3D;&#x3D;&#x3D; &#39;[object Boolean]&#39;) &#123;</span><br><span class="line">          return this.model;</span><br><span class="line">        &#x2F;&#x2F; 如果是数组</span><br><span class="line">        &#125; else if (Array.isArray(this.model)) &#123;</span><br><span class="line">          return this.model.indexOf(this.label) &gt; -1;</span><br><span class="line">        &#x2F;&#x2F; 两个都不是 则默认展示truelabel</span><br><span class="line">        &#125; else if (this.model !&#x3D;&#x3D; null &amp;&amp; this.model !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">          return this.model &#x3D;&#x3D;&#x3D; this.trueLabel;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 判断当前组件是否在 checkboxgroup 组件里面</span><br><span class="line">      isGroup() &#123;</span><br><span class="line">        let parent &#x3D; this.$parent; &#x2F;&#x2F; 获取当前组件的父组件实例</span><br><span class="line">        while (parent) &#123;</span><br><span class="line">          if (parent.$options.componentName !&#x3D;&#x3D; &#39;ElCheckboxGroup&#39;) &#123; &#x2F;&#x2F; 判断父组件的组件名字属性是否是ElCheckboxGroup</span><br><span class="line">            parent &#x3D; parent.$parent; &#x2F;&#x2F; 不是继续向上找</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this._checkboxGroup &#x3D; parent; &#x2F;&#x2F; 将值赋给 _checkboxGroup</span><br><span class="line">            return true;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;,</span><br><span class="line">  </span><br><span class="line">      &#x2F;&#x2F; 看是否存在 _checkboxGroup 返回checkboxgroup的value 或者 当前的value</span><br><span class="line">      store() &#123;</span><br><span class="line">        return this._checkboxGroup ? this._checkboxGroup.value : this.value;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 超出限制 则 不能使用</span><br><span class="line">      isLimitDisabled() &#123;</span><br><span class="line">        const &#123; max, min &#125; &#x3D; this._checkboxGroup;</span><br><span class="line">        &#x2F;&#x2F; 假设当前checkboxgroup有5个 max为3 min为1</span><br><span class="line">        &#x2F;&#x2F; !! 转成布尔值 只要max和min有一个定义了 就返回true </span><br><span class="line">        &#x2F;&#x2F; &amp;&amp; 的 优先级 大于 || </span><br><span class="line">        &#x2F;*</span><br><span class="line">        下面的代码意思就是 </span><br><span class="line">        1. 如果max和min没有给 返回false</span><br><span class="line">        2. max和min都给了, 则在选中的个数 达到3个或者1个时候 就返回true</span><br><span class="line">        3. max给了值, min没有给, 只有在选中的个数达到3的时候 返回true</span><br><span class="line">        4. min给了值, max没给, 则只有在选中的个数只有1时, 返回true</span><br><span class="line">        *&#x2F;</span><br><span class="line">        return !!(max || min) &amp;&amp;</span><br><span class="line">          (this.model.length &gt;&#x3D; max &amp;&amp; !this.isChecked) ||</span><br><span class="line">          (this.model.length &lt;&#x3D; min &amp;&amp; this.isChecked);</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x2F;&#x2F; 判断是否disabled</span><br><span class="line">      isDisabled() &#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">        1. 如果在checkboxgroup中 只要 checkboxgroup的disabled为true, 或者当前的属性的disabled设置true, 或者这个checkboxgroup处于elform里面 并且这个el-form&#x2F;el-form-item设置disabled为true, 或者触发了超出限制 返回为true 则disabled</span><br><span class="line">        2. 不在 就看自身设置没有, 没有就看 是否在el-form&#x2F;el-form-item中设置没有</span><br><span class="line">        *&#x2F;</span><br><span class="line">        return this.isGroup</span><br><span class="line">          ? this._checkboxGroup.disabled || this.disabled || (this.elForm || &#123;&#125;).disabled || this.isLimitDisabled</span><br><span class="line">          : this.disabled || (this.elForm || &#123;&#125;).disabled;</span><br><span class="line">      &#125;,</span><br><span class="line"> </span><br><span class="line">      &#x2F;&#x2F; 返回size small&#x2F;mini...</span><br><span class="line">      _elFormItemSize() &#123;</span><br><span class="line">        return (this.elFormItem || &#123;&#125;).elFormItemSize;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">      1. 如果自己没有设置 则用 el-form-item的, 如果也没有 就用 默认的</span><br><span class="line">      2. 如果处于checkboxgroup中且checkboxgroup设置 就用 没用就用temCheckboxSize</span><br><span class="line">      *&#x2F;</span><br><span class="line">      checkboxSize() &#123;</span><br><span class="line">        const temCheckboxSize &#x3D; this.size || this._elFormItemSize || (this.$ELEMENT || &#123;&#125;).size;</span><br><span class="line">        return this.isGroup</span><br><span class="line">          ? this._checkboxGroup.checkboxGroupSize || temCheckboxSize</span><br><span class="line">          : temCheckboxSize;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    props: &#123;</span><br><span class="line">      value: &#123;&#125;, &#x2F;&#x2F; 指定的值</span><br><span class="line">      label: &#123;&#125;, &#x2F;&#x2F; 选中状态的值 只有在checkboxgroup 或者绑定的值类型是array 生效</span><br><span class="line">      indeterminate: Boolean, &#x2F;&#x2F; 设置 indeterminate 状态，只负责样式控制</span><br><span class="line">      disabled: Boolean, &#x2F;&#x2F; 是否禁用</span><br><span class="line">      checked: Boolean, &#x2F;&#x2F; 是否勾选</span><br><span class="line">      name: String, &#x2F;&#x2F; 原生name</span><br><span class="line">      trueLabel: [String, Number], &#x2F;&#x2F; 选中时的值</span><br><span class="line">      falseLabel: [String, Number], &#x2F;&#x2F; 没有选中时的值</span><br><span class="line">      id: String, &#x2F;* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*&#x2F;</span><br><span class="line">      controls: String, &#x2F;* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系*&#x2F;</span><br><span class="line">      border: Boolean, &#x2F;&#x2F; 是否展示边框</span><br><span class="line">      size: String &#x2F;&#x2F; 尺寸，仅在 border 为真时有效  border &amp;&amp; checkboxSize ? &#39;el-checkbox--&#39; + checkboxSize : &#39;&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">      addToStore() &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断是否是数组 如果是数组 再看值不能存在存在</span><br><span class="line">        if (</span><br><span class="line">          Array.isArray(this.model) &amp;&amp;</span><br><span class="line">          this.model.indexOf(this.label) &#x3D;&#x3D;&#x3D; -1</span><br><span class="line">        ) &#123;</span><br><span class="line">            &#x2F;&#x2F; 不存在push进去</span><br><span class="line">          this.model.push(this.label);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 否则设置为true</span><br><span class="line">          this.model &#x3D; this.trueLabel || true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      handleChange(ev) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果已经被限制了 就直接返回</span><br><span class="line">        if (this.isLimitExceeded) return;</span><br><span class="line">        let value;</span><br><span class="line">        &#x2F;&#x2F; 判断是否选中</span><br><span class="line">        if (ev.target.checked) &#123;</span><br><span class="line">          value &#x3D; this.trueLabel &#x3D;&#x3D;&#x3D; undefined ? true : this.trueLabel;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          value &#x3D; this.falseLabel &#x3D;&#x3D;&#x3D; undefined ? false : this.falseLabel;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 触发事件</span><br><span class="line">        this.$emit(&#39;change&#39;, value, ev);</span><br><span class="line">        this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 如果在checkboxgroup中</span><br><span class="line">          if (this.isGroup) &#123;</span><br><span class="line">            &#x2F;&#x2F; 派发事件</span><br><span class="line">            this.dispatch(&#39;ElCheckboxGroup&#39;, &#39;change&#39;, [this._checkboxGroup.value]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    created() &#123;</span><br><span class="line">      this.checked &amp;&amp; this.addToStore();</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123; &#x2F;&#x2F; 为indeterminate元素 添加aria-controls 属性</span><br><span class="line">      if (this.indeterminate) &#123;</span><br><span class="line">        this.$el.setAttribute(&#39;aria-controls&#39;, this.controls);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    watch: &#123;</span><br><span class="line">     &#x2F;&#x2F; value 变化时 派发</span><br><span class="line">      value(value) &#123;</span><br><span class="line">        this.dispatch(&#39;ElFormItem&#39;, &#39;el.form.change&#39;, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="3-0版本"><a href="#3-0版本" class="headerlink" title="3.0版本"></a><code>3.0版本</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;label</span><br><span class="line">    class&#x3D;&quot;el-checkbox&quot;</span><br><span class="line">    role&#x3D;&quot;checkbox&quot;</span><br><span class="line">    :class&#x3D;&quot;[</span><br><span class="line">      isBorder &amp;&amp; checkboxSize ? &#39;el-checkbox--&#39; + checkboxSize : &#39;&#39;,</span><br><span class="line">      &#123; &#39;is-disabled&#39;: isDisabled &#125;,</span><br><span class="line">      &#123; &#39;is-bordered&#39;: isBorder &#125;,</span><br><span class="line">      &#123; &#39;is-checked&#39;: isChecked &#125;</span><br><span class="line">    ]&quot;</span><br><span class="line">    :id&#x3D;&quot;id&quot;</span><br><span class="line">    :aria-checked&#x3D;&quot;isChecked&quot;</span><br><span class="line">    :aria-disabled&#x3D;&quot;isDisabled&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;span</span><br><span class="line">      class&#x3D;&quot;el-checkbox__input&quot;</span><br><span class="line">      :class&#x3D;&quot;&#123;</span><br><span class="line">        &#39;is-disabled&#39;: isDisabled,</span><br><span class="line">        &#39;is-checked&#39;: isChecked,</span><br><span class="line">        &#39;is-indeterminate&#39;: indeterminate,</span><br><span class="line">        &#39;is-focus&#39;: focus</span><br><span class="line">      &#125;&quot;</span><br><span class="line">      :tabindex&#x3D;&quot;indeterminate ? 0 : false&quot;</span><br><span class="line">      :role&#x3D;&quot;indeterminate ? &#39;checkbox&#39; : false&quot;</span><br><span class="line">      :aria-checked&#x3D;&quot;indeterminate ? &#39;mixed&#39; : false&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;el-checkbox__inner&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        class&#x3D;&quot;el-checkbox__original&quot;</span><br><span class="line">        type&#x3D;&quot;checkbox&quot;</span><br><span class="line">        ref&#x3D;&quot;checkbox&quot;</span><br><span class="line">        :aria-hidden&#x3D;&quot;indeterminate ? &#39;true&#39; : &#39;false&#39;&quot;</span><br><span class="line">        :name&#x3D;&quot;name&quot;</span><br><span class="line">        :disabled&#x3D;&quot;isDisabled&quot;</span><br><span class="line">        :true-value&#x3D;&quot;trueLabel&quot;</span><br><span class="line">        :false-value&#x3D;&quot;falseLabel&quot;</span><br><span class="line">        :value&#x3D;&quot;label&quot;</span><br><span class="line">        @change&#x3D;&quot;handleChange&quot;</span><br><span class="line">        @input&#x3D;&quot;model &#x3D; &#123; label, checked: $event.target.checked &#125;&quot;</span><br><span class="line">        @focus&#x3D;&quot;focus &#x3D; true&quot;</span><br><span class="line">        @blur&#x3D;&quot;focus &#x3D; false&quot;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;el-checkbox__label&quot; v-if&#x3D;&quot;$slots.default || label&quot;&gt;</span><br><span class="line">      &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">      &lt;template v-if&#x3D;&quot;!$slots.default&quot;&gt;&#123;&#123; label &#125;&#125;&lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;label&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; reactive, toRefs &#125; from &#39;vue&#39;</span><br><span class="line">import &#123;</span><br><span class="line">  useModel,</span><br><span class="line">  useAria,</span><br><span class="line">  useCheckSelected,</span><br><span class="line">  useSize,</span><br><span class="line">  useLimit,</span><br><span class="line">  useDisabled,</span><br><span class="line">  useBorder</span><br><span class="line">&#125; from &#39;.&#x2F;uses.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;ElCheckbox&#39;,</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    modelValue: [String, Number, Boolean, Symbol, Array],</span><br><span class="line">    label: [String, Number, Boolean, Symbol],</span><br><span class="line">    indeterminate: Boolean,</span><br><span class="line">    disabled: Boolean,</span><br><span class="line">    checked: Boolean,</span><br><span class="line">    name: String,</span><br><span class="line">    trueLabel: &#123; type: [String, Number, Boolean], default: true &#125;,</span><br><span class="line">    falseLabel: &#123; type: [String, Number, Boolean], default: false &#125;,</span><br><span class="line">    id: String &#x2F;* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 *&#x2F;,</span><br><span class="line">    controls: String &#x2F;* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 *&#x2F;,</span><br><span class="line">    border: Boolean,</span><br><span class="line">    size: String</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  emits: [&#39;update:modelValue&#39;, &#39;change&#39;],</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">    const state &#x3D; reactive(&#123;</span><br><span class="line">      focus: false</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    useAria()</span><br><span class="line"></span><br><span class="line">    const &#123; model, handleChange &#125; &#x3D; useModel()</span><br><span class="line"></span><br><span class="line">    const isLimit &#x3D; useLimit(&#123; model &#125;)</span><br><span class="line"></span><br><span class="line">    const &#123; isChecked, checkbox &#125; &#x3D; useCheckSelected(&#123; model &#125;)</span><br><span class="line"></span><br><span class="line">    const checkboxSize &#x3D; useSize()</span><br><span class="line"></span><br><span class="line">    const isDisabled &#x3D; useDisabled(&#123; isLimit &#125;)</span><br><span class="line"></span><br><span class="line">    const isBorder &#x3D; useBorder()</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      ...toRefs(state),</span><br><span class="line">      checkbox,</span><br><span class="line">      model,</span><br><span class="line">      isDisabled,</span><br><span class="line">      checkboxSize,</span><br><span class="line">      isChecked,</span><br><span class="line">      handleChange,</span><br><span class="line">      isBorder</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>3.0</code>版本的代码可以看出, 没有像<code>2.x</code>那样的反复横跳, 更清楚的知道的逻辑的出处</p><p><code>use.js</code>  源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; isArray &#125; <span class="keyword">from</span> <span class="string">'@vue/shared'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  computed,</span><br><span class="line">  ref,</span><br><span class="line">  onMounted,</span><br><span class="line">  getCurrentInstance,</span><br><span class="line">  inject,</span><br><span class="line">  nextTick,</span><br><span class="line">  reactive,</span><br><span class="line">  watchEffect</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEmitter &#125; <span class="keyword">from</span> <span class="string">'../../src/use/emitter'</span></span><br><span class="line"><span class="keyword">import</span> &#123; usePropUtils &#125; <span class="keyword">from</span> <span class="string">'../../src/use/prop-utils'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useModel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// core</span></span><br><span class="line">  <span class="keyword">const</span> &#123; emit, props &#125; = getCurrentInstance(); <span class="comment">// 获取当前实例的 emit, prop</span></span><br><span class="line">  <span class="keyword">const</span> elCheckboxGroup = inject(<span class="string">'elCheckboxGroup'</span>, &#123; <span class="attr">props</span>: &#123;&#125; &#125;) <span class="comment">// 获取checkboxGroup注入的对象</span></span><br><span class="line">  <span class="keyword">const</span> &#123; dispatch &#125; = useEmitter() <span class="comment">// 拿出dispatch方法</span></span><br><span class="line">  <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    modelValue: <span class="literal">null</span></span><br><span class="line">  &#125;) <span class="comment">// 定义一个响应式的对象</span></span><br><span class="line"></span><br><span class="line">  watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 监听副作用 当值发生变化时 赋值</span></span><br><span class="line">    state.modelValue = elCheckboxGroup.props.modelValue || props.modelValue</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> model = computed(&#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> state.modelValue</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(&#123; label, checked &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (label &amp;&amp; isArray(model.value)) &#123;</span><br><span class="line">        <span class="comment">// label存在且 model.value是一个数组</span></span><br><span class="line">        <span class="keyword">const</span> modelValue = model.value</span><br><span class="line">        <span class="keyword">const</span> labelIndex = modelValue.indexOf(label)</span><br><span class="line">        <span class="comment">// 找不到label 且 checked为true 就 push进 数组</span></span><br><span class="line">        labelIndex === <span class="number">-1</span> &amp;&amp; checked === <span class="literal">true</span> &amp;&amp; modelValue.push(label)</span><br><span class="line">        <span class="comment">// 找得到 且 checked为false 就删除</span></span><br><span class="line">        labelIndex !== <span class="number">-1</span> &amp;&amp;</span><br><span class="line">          checked === <span class="literal">false</span> &amp;&amp;</span><br><span class="line">          modelValue.splice(labelIndex, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 重新赋值</span></span><br><span class="line">        state.modelValue = modelValue</span><br><span class="line">        <span class="comment">// 发射事件</span></span><br><span class="line">        emit(<span class="string">'update:modelValue'</span>, modelValue)</span><br><span class="line">        <span class="comment">// 派发</span></span><br><span class="line">        dispatch(<span class="string">'update:modelValue'</span>, modelValue)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 说明model.value就是单个值</span></span><br><span class="line">        <span class="keyword">const</span> modelValue = checked ? props.trueLabel : props.falseLabel</span><br><span class="line">        state.modelValue = modelValue</span><br><span class="line">        emit(<span class="string">'update:modelValue'</span>, modelValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// change事件</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> nextTick()</span><br><span class="line">    emit(<span class="string">'change'</span>, model.value)</span><br><span class="line">    dispatch(<span class="string">'change'</span>, model.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; model, handleChange &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useAria</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; props, vnode &#125; = getCurrentInstance()</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.indeterminate) &#123;</span><br><span class="line">      vnode.el.setAttribute(<span class="string">'aria-controls'</span>, props.controls)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否select</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useCheckSelected</span>(<span class="params">&#123; model &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; props &#125; = getCurrentInstance()</span><br><span class="line">  <span class="keyword">const</span> &#123; isAfferentProp &#125; = usePropUtils() <span class="comment">// 这个方法是某个属性是否是传入的属性</span></span><br><span class="line">  <span class="keyword">const</span> checkbox = ref(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂在完成后 判断 checked是否是传入的属性 是就给model.value赋值</span></span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    isAfferentProp(<span class="string">'checked'</span>) &amp;&amp;</span><br><span class="line">      (model.value = &#123; <span class="attr">label</span>: props.label, <span class="attr">checked</span>: props.checked &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isChecked = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里就是给它赋值</span></span><br><span class="line">    <span class="keyword">const</span> _isChecked = isArray(model.value)</span><br><span class="line">      ? model.value.indexOf(props.label) !== <span class="number">-1</span></span><br><span class="line">      : model.value === props.trueLabel</span><br><span class="line">    checkbox.value &amp;&amp; (checkbox.value.checked = _isChecked)</span><br><span class="line">    <span class="keyword">return</span> _isChecked</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; isChecked, checkbox &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回size</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elCheckboxGroup = inject(<span class="string">'elCheckboxGroup'</span>, &#123; <span class="attr">props</span>: &#123;&#125;, <span class="attr">ctx</span>: &#123;&#125; &#125;)</span><br><span class="line">  <span class="keyword">const</span> &#123; props, ctx &#125; = getCurrentInstance()</span><br><span class="line">  <span class="keyword">const</span> checkboxSize = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      props.size ||</span><br><span class="line">      elCheckboxGroup.ctx.checkboxGroupSize ||</span><br><span class="line">      (ctx.$ELEMENT || &#123;&#125;).size</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> checkboxSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否限制 就是checkbox使用了max min</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLimit</span>(<span class="params">&#123; model &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elCheckboxGroup = inject(<span class="string">'elCheckboxGroup'</span>, &#123; <span class="attr">props</span>: &#123;&#125;, <span class="attr">ctx</span>: &#123;&#125; &#125;)</span><br><span class="line">  <span class="keyword">const</span> &#123; props &#125; = getCurrentInstance()</span><br><span class="line">  <span class="keyword">const</span> isLimit = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (elCheckboxGroup.props.modelValue) &#123;</span><br><span class="line">      <span class="comment">// if elCheckboxGroup exist</span></span><br><span class="line">      <span class="keyword">const</span> modelValueLength = elCheckboxGroup.props.modelValue.length</span><br><span class="line">      <span class="keyword">const</span> min = elCheckboxGroup.props.min</span><br><span class="line">      <span class="keyword">const</span> max = elCheckboxGroup.props.max</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        (modelValueLength &lt;= min &amp;&amp; model.value.indexOf(props.label) !== <span class="number">-1</span>) ||</span><br><span class="line">        (modelValueLength &gt;= max &amp;&amp; model.value.indexOf(props.label) === <span class="number">-1</span>)</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> isLimit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否禁用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useDisabled</span>(<span class="params">&#123; isLimit &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elCheckboxGroup = inject(<span class="string">'elCheckboxGroup'</span>, &#123; <span class="attr">props</span>: &#123;&#125;, <span class="attr">ctx</span>: &#123;&#125; &#125;)</span><br><span class="line">  <span class="keyword">const</span> &#123; props &#125; = getCurrentInstance()</span><br><span class="line">  <span class="keyword">const</span> isDisabled = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      props.disabled ||</span><br><span class="line">      elCheckboxGroup.ctx.checkboxGroupDisabled ||</span><br><span class="line">      isLimit.value</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> isDisabled</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否展示border</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useBorder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elCheckboxGroup = inject(<span class="string">'elCheckboxGroup'</span>, &#123; <span class="attr">props</span>: &#123;&#125;, <span class="attr">ctx</span>: &#123;&#125; &#125;)</span><br><span class="line">  <span class="keyword">const</span> &#123; props &#125; = getCurrentInstance()</span><br><span class="line">  <span class="keyword">const</span> isBorder = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> props.border || elCheckboxGroup.props.border</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> isBorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活的样式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useActiveStyle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elCheckboxGroup = inject(<span class="string">'elCheckboxGroup'</span>, &#123; <span class="attr">props</span>: &#123;&#125;, <span class="attr">ctx</span>: &#123;&#125; &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    backgroundColor: elCheckboxGroup.props.fill || <span class="string">''</span>,</span><br><span class="line">    borderColor: elCheckboxGroup.props.fill || <span class="string">''</span>,</span><br><span class="line">    color: elCheckboxGroup.props.textColor || <span class="string">''</span>,</span><br><span class="line">    <span class="string">'box-shadow'</span>: <span class="string">'-1px 0 0 0 '</span> + elCheckboxGroup.props.fill</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是把相应的方法抽离出去 使得那个文件更加清爽</p>]]></content>
    
    <summary type="html">
    
      element Ui 学习笔记
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="element-ui" scheme="http://blog.decade.run/tags/element-ui/"/>
    
  </entry>
  
  <entry>
    <title>element-ui-3-源码学习-2</title>
    <link href="http://blog.decade.run/2020/10/27/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-2/"/>
    <id>http://blog.decade.run/2020/10/27/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-2/</id>
    <published>2020-10-27T06:52:12.000Z</published>
    <updated>2020-10-27T08:12:20.641Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Button-组件-源码"><a href="#Button-组件-源码" class="headerlink" title="Button 组件 源码"></a><code>Button</code> 组件 源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button</span><br><span class="line">    class&#x3D;&quot;el-button&quot;</span><br><span class="line">    @click&#x3D;&quot;handleClick&quot;</span><br><span class="line">    :disabled&#x3D;&quot;buttonDisabled || loading&quot;</span><br><span class="line">    :autofocus&#x3D;&quot;autofocus&quot;</span><br><span class="line">    :type&#x3D;&quot;nativeType&quot;</span><br><span class="line">    :class&#x3D;&quot;[</span><br><span class="line">      type ? &#39;el-button--&#39; + type : &#39;&#39;,</span><br><span class="line">      buttonSize ? &#39;el-button--&#39; + buttonSize : &#39;&#39;,</span><br><span class="line">      &#123;</span><br><span class="line">        &#39;is-disabled&#39;: buttonDisabled,</span><br><span class="line">        &#39;is-loading&#39;: loading,</span><br><span class="line">        &#39;is-plain&#39;: plain,</span><br><span class="line">        &#39;is-round&#39;: round,</span><br><span class="line">        &#39;is-circle&#39;: circle</span><br><span class="line">      &#125;</span><br><span class="line">    ]&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;i class&#x3D;&quot;el-icon-loading&quot; v-if&#x3D;&quot;loading&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;i :class&#x3D;&quot;icon&quot; v-if&#x3D;&quot;icon &amp;&amp; !loading&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">    &lt;span v-if&#x3D;&quot;$slots.default&quot;&gt;</span><br><span class="line">      &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p><strong><code>vue2.x</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'ElButton'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vue2.x使用的注入 在button组件中拿到注入的elForm 和 elFormItem</span></span><br><span class="line">    inject: &#123;</span><br><span class="line">      elForm: &#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">      &#125;,</span><br><span class="line">      elFormItem: &#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父组件传个子组件的props</span></span><br><span class="line">    props: &#123;</span><br><span class="line">      <span class="comment">// 这个控制 bottom的展示样式 primary/text...</span></span><br><span class="line">      type: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'default'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//  控制大小 small/mini...</span></span><br><span class="line">      size: <span class="built_in">String</span>,</span><br><span class="line">      <span class="comment">// bottom的图标</span></span><br><span class="line">      icon: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 原生类型 submit/reset</span></span><br><span class="line">      nativeType: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'button'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 是否加载</span></span><br><span class="line">      loading: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="comment">// 是否禁用</span></span><br><span class="line">      disabled: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="comment">// 是否朴素</span></span><br><span class="line">      plain: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="comment">// 是否聚焦</span></span><br><span class="line">      autofocus: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="comment">// 是否圆角</span></span><br><span class="line">      round: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="comment">// 是否圆形</span></span><br><span class="line">      circle: <span class="built_in">Boolean</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.x的计算属性</span></span><br><span class="line">    computed: &#123;</span><br><span class="line">      <span class="comment">// 方便控制像 el-form 设置了size 然后 el-form里面有el-form-item / 这是el-form的size 就会是el-form-item的size</span></span><br><span class="line">      _elFormItemSize() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.elFormItem || &#123;&#125;).elFormItemSize;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 如果父组件没有给el-button设置size, 然后看是否在el-form-item里面 最后看 Vue.$ELEMENT的默认的 </span></span><br><span class="line">      buttonSize() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size || <span class="keyword">this</span>._elFormItemSize || (<span class="keyword">this</span>.$ELEMENT || &#123;&#125;).size;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 同理父组件没有设置disabled 看所在form 有没有设置</span></span><br><span class="line">      buttonDisabled() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.disabled || (<span class="keyword">this</span>.elForm || &#123;&#125;).disabled;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    methods: &#123;</span><br><span class="line">      <span class="comment">// 触发点击事件</span></span><br><span class="line">      handleClick(evt) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$emit(<span class="string">'click'</span>, evt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong><code>vue3.0</code></strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; computed, inject, toRefs, unref, getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    </span><br><span class="line">  name: <span class="string">'ElButton'</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.0的props声明 与 2.x的一样 </span></span><br><span class="line">  props: &#123;</span><br><span class="line">    type: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'default'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    size: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    icon: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    nativeType: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'button'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    loading: <span class="built_in">Boolean</span>,</span><br><span class="line">    disabled: <span class="built_in">Boolean</span>,</span><br><span class="line">    plain: <span class="built_in">Boolean</span>,</span><br><span class="line">    autofocus: <span class="built_in">Boolean</span>,</span><br><span class="line">    round: <span class="built_in">Boolean</span>,</span><br><span class="line">    circle: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 多一个 发射的事件 是一个什么事件 就是你 emit(type, e)的type </span></span><br><span class="line">  <span class="comment">// 这样可以避免 例如多次触发点击事件 </span></span><br><span class="line">  emits: [<span class="string">'click'</span>],</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  setup(props, ctx) &#123;</span><br><span class="line">    <span class="comment">// props是 父组件给的props</span></span><br><span class="line">    <span class="comment">// ctx 上下文对象</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 首先我们必须知道 props不能直接解构</span></span><br><span class="line">    <span class="comment">// 例如: const &#123; size, disabled &#125; = props;</span></span><br><span class="line">    <span class="comment">// 这解构出来的数据 是没有响应式的</span></span><br><span class="line">    <span class="comment">// 这是可以通过toRefs来使其响应式</span></span><br><span class="line">    <span class="keyword">const</span> &#123; size, disabled &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 命名感觉有点像react 的hook  大家都这么命名!!!</span></span><br><span class="line">    <span class="keyword">const</span> buttonSize = useButtonSize(size)</span><br><span class="line">    <span class="keyword">const</span> buttonDisabled = useButtonDisabled(disabled)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.0中的emit放在ctx上下文中 </span></span><br><span class="line">    <span class="keyword">const</span> handleClick = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">      ctx.emit(<span class="string">'click'</span>, evt)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在模板中使用必须return</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      handleClick,</span><br><span class="line">      buttonSize,</span><br><span class="line">      buttonDisabled</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个响应式的值</span></span><br><span class="line"><span class="keyword">const</span> useButtonSize = <span class="function">(<span class="params">size</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// vue3.0中使用的inject注入 注入的可以是一个响应式的数据</span></span><br><span class="line">  <span class="comment">// 3.0中inject只能在当前的实例中使用 2.x所有</span></span><br><span class="line">  <span class="keyword">const</span> elFormItem = inject(<span class="string">'elFormItem'</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.0中computed</span></span><br><span class="line">  <span class="keyword">const</span> _elFormItemSize = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将注入的elFormItem.elFormItemSize 失去响应式 </span></span><br><span class="line">    <span class="keyword">return</span> unref(elFormItem.elFormItemSize)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的思路与2.x的思路一样</span></span><br><span class="line">  <span class="comment">// getCurrentInstance返回的是当前的实例 </span></span><br><span class="line">  <span class="comment">// getCurrentInstance().proxy.$ELEMENT 就相当于2.x 的this.$ELEMENT</span></span><br><span class="line">  <span class="comment">// 3.0 中注册全局属性或者方法 app.config.globalProperties.$ELEMENT = xxxx; </span></span><br><span class="line">  <span class="keyword">const</span> buttonSize = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      size.value ||</span><br><span class="line">      _elFormItemSize.value ||</span><br><span class="line">      (getCurrentInstance().proxy.$ELEMENT || &#123;&#125;).size</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buttonSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useButtonDisabled = <span class="function">(<span class="params">disabled</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> elForm = inject(<span class="string">'elForm'</span>, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> buttonDisabled = computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> disabled.value || unref(elForm.disabled)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buttonDisabled</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      element Ui 学习笔记
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="element-ui" scheme="http://blog.decade.run/tags/element-ui/"/>
    
  </entry>
  
  <entry>
    <title>element-ui 3 源码学习 (一)</title>
    <link href="http://blog.decade.run/2020/10/26/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://blog.decade.run/2020/10/26/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2020-10-26T03:53:22.000Z</published>
    <updated>2020-10-27T07:25:52.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p><a href="https://github.com/kkbjs/element3" target="_blank" rel="noopener">element3</a></p><h4 id="src-use-emitter-js"><a href="#src-use-emitter-js" class="headerlink" title="src/use/emitter.js"></a>src/use/emitter.js</h4><p>说起这个我得先把  <code>mitt</code> <a href="https://github.com/developit/mitt" target="_blank" rel="noopener">地址</a>  因为vue3中已经把 <code>$on</code>  给去除了 如果想要像  <code>vue2.x</code> 那样 使用 必须引入这个库, 我使用的cdn引入的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/mitt/dist/mitt.umd.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /* </span><br><span class="line">    这样引入的mitt是一个方法 返回的是一个emitter对象</span><br><span class="line">    这个一个emitter对象上面有四个属性</span><br><span class="line"><span class="javascript">    all 是一个<span class="built_in">Map</span>对象, </span></span><br><span class="line">    on 监听注册的事件,  on(type, handle)</span><br><span class="line">    emit 发射注册的事件, emit(type, handle)</span><br><span class="line">    off 移除 off(type, handle)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    type: string | <span class="built_in">Symbol</span></span></span><br><span class="line"><span class="javascript">    handle: <span class="built_in">Function</span></span></span><br><span class="line">    */</span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> emiiter = mitt();</span></span><br><span class="line"><span class="actionscript">    emiiter.on(<span class="string">'foo'</span>, e =&gt; &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e) <span class="comment">// &#123;name: decade&#125;</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    emiiter.on(<span class="string">'*'</span>, (type, e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(type, e); <span class="comment">// 'foo', &#123;name: decade&#125;</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    emiiter.emit(<span class="string">'foo'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">      name: <span class="string">'decade'</span></span></span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是<code>emitter</code> 源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">'mitt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DISPATCH = <span class="string">'dispatch'</span></span><br><span class="line"><span class="keyword">const</span> BROADCAST = <span class="string">'broadcast'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = <span class="built_in">Symbol</span>(<span class="string">'wrapper'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> emitter = mitt()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到当前vue组件的实例</span></span><br><span class="line">  <span class="keyword">const</span> currentComponentInstance = getCurrentInstance(); </span><br><span class="line">  <span class="comment">// 定义on方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">on</span>(<span class="params">type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// type 监听的string | Symbol</span></span><br><span class="line">    <span class="keyword">const</span> handleWrapper = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 定义的方法</span></span><br><span class="line">      <span class="keyword">const</span> &#123; value, type, emitComponentInstance &#125; = e</span><br><span class="line">      <span class="comment">// e 就是 发射事件 传入的参数</span></span><br><span class="line">      <span class="keyword">if</span> (type === BROADCAST) &#123;</span><br><span class="line">        <span class="comment">// 广播 由子往父</span></span><br><span class="line">        <span class="keyword">if</span> (isChildComponent(currentComponentInstance, emitComponentInstance)) &#123;</span><br><span class="line">          handler &amp;&amp; handler(...value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === DISPATCH) &#123;</span><br><span class="line">        <span class="comment">// 派发 由父往子</span></span><br><span class="line">        <span class="keyword">if</span> (isChildComponent(emitComponentInstance, currentComponentInstance)) &#123;</span><br><span class="line">          handler &amp;&amp; handler(...value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 就找监听的</span></span><br><span class="line">        handler &amp;&amp; handler(...value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the real handler because the need to call off</span></span><br><span class="line">    handler[wrapper] = handleWrapper</span><br><span class="line">    emitter.on(type, handleWrapper)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 广播</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">type, ...args</span>) </span>&#123; </span><br><span class="line">    emitter.emit(type, &#123;</span><br><span class="line">      type: BROADCAST,</span><br><span class="line">      emitComponentInstance: currentComponentInstance,</span><br><span class="line">      value: args</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 派发</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">    emitter.emit(type, &#123;</span><br><span class="line">      type: DISPATCH,</span><br><span class="line">      emitComponentInstance: currentComponentInstance,</span><br><span class="line">      value: args</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">off</span>(<span class="params">type, handler</span>) </span>&#123;</span><br><span class="line">    emitter.off(type, handler[wrapper])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只触发一次</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handleOn = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      handler &amp;&amp; handler(...args)</span><br><span class="line">      off(type, handleOn)</span><br><span class="line">    &#125;</span><br><span class="line">    on(type, handleOn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    on,</span><br><span class="line">    broadcast,</span><br><span class="line">    dispatch,</span><br><span class="line">    off,</span><br><span class="line">    once</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check componentChild is componentParent child components</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">componentChild</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">componentParent</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是子组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isChildComponent</span>(<span class="params">componentChild, componentParent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parentUId = componentParent.uid</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (componentChild &amp;&amp; componentChild?.parent?.uid !== parentUId) &#123;</span><br><span class="line">    componentChild = componentChild.parent</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Boolean</span>(componentChild)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>附带vue2.x emitter.js</code> 源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">componentName, eventName, params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = child.$options.componentName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name === componentName) &#123;</span><br><span class="line">      child.$emit.apply(child, [eventName].concat(params));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      broadcast.apply(child, [componentName, eventName].concat([params]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dispatch(componentName, eventName, params) &#123;</span><br><span class="line">      <span class="keyword">var</span> parent = <span class="keyword">this</span>.$parent || <span class="keyword">this</span>.$root;</span><br><span class="line">      <span class="keyword">var</span> name = parent.$options.componentName;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">        parent = parent.$parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">          name = parent.$options.componentName;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        parent.$emit.apply(parent, [eventName].concat(params));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    broadcast(componentName, eventName, params) &#123;</span><br><span class="line">      broadcast.call(<span class="keyword">this</span>, componentName, eventName, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      element Ui 学习笔记
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="element-ui" scheme="http://blog.decade.run/tags/element-ui/"/>
    
  </entry>
  
  <entry>
    <title>初识 jest (二)</title>
    <link href="http://blog.decade.run/2020/10/10/learn-jest-2/"/>
    <id>http://blog.decade.run/2020/10/10/learn-jest-2/</id>
    <published>2020-10-10T02:17:44.000Z</published>
    <updated>2020-10-10T03:29:07.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Jest-中的匹配器"><a href="#Jest-中的匹配器" class="headerlink" title="Jest 中的匹配器"></a><code>Jest</code> 中的匹配器</h3><ul><li><p><code>toBe</code>  相当于  <code>===</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'two plus two is four'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">2</span> + <span class="number">2</span>).toBe(<span class="number">4</span>);</span><br><span class="line">  <span class="comment">// const a = &#123;</span></span><br><span class="line">  <span class="comment">//   name: 'decade'</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// expect(a).toBe(&#123;name: 'decade'&#125;); // 使用toBe来比较对象 会失败</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toEqual</code> 用于比较值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'object a '</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = &#123;</span><br><span class="line">    name: <span class="string">'decade'</span></span><br><span class="line">  &#125;;</span><br><span class="line">  expect(a).toEqual(&#123;<span class="attr">name</span>: <span class="string">'decade'</span>&#125;); <span class="comment">// 这样就能通过了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>not</code>  去相反的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'not'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// expect(5).not.toBe(5);</span></span><br><span class="line">  expect(<span class="number">5</span>).not.toBe(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeNull</code>  只匹配 <code>Null</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'null'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="literal">null</span>).toBeNull();</span><br><span class="line">  <span class="comment">// expect(0).toBeNull();</span></span><br><span class="line">  <span class="comment">// expect(undefined).toBeNull();</span></span><br><span class="line">  <span class="comment">// expect(false).toBeNull();</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeUndefined</code>   只匹配  <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'undefined '</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="literal">undefined</span>).toBeUndefined();</span><br><span class="line">  <span class="comment">// expect(null).toBeUndefined();</span></span><br><span class="line">  <span class="comment">// expect(0).toBeUndefined();</span></span><br><span class="line">  <span class="comment">// expect(false).toBeUndefined();</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeDefined</code>  只匹配非 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeDefined '</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// expect(undefined).toBeDefined(); 希望得到的值不是undefined</span></span><br><span class="line">  expect(<span class="literal">null</span>).toBeDefined();</span><br><span class="line">  expect(<span class="number">0</span>).toBeDefined();</span><br><span class="line">  expect(<span class="literal">false</span>).toBeDefined();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeTruthy</code>  只匹配能使 <code>if</code>  语句为真的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeTruthy'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// expect(undefined).toBeTruthy();</span></span><br><span class="line">  <span class="comment">// expect(null).toBeTruthy();</span></span><br><span class="line">  <span class="comment">// expect(0).toBeTruthy();</span></span><br><span class="line">  <span class="comment">// expect(false).toBeTruthy();</span></span><br><span class="line">  <span class="comment">// expect().toBeTruthy(); 这样的相当于undefined</span></span><br><span class="line">  expect([]).toBeTruthy();</span><br><span class="line">  expect(&#123;&#125;).toBeTruthy();</span><br><span class="line">  expect(<span class="number">1</span>).toBeTruthy();</span><br><span class="line">  expect(<span class="literal">true</span>).toBeTruthy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeFalsy</code>  只匹配 使 <code>if</code> 语句为假的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeFalsy'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="literal">undefined</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">null</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="number">0</span>).toBeFalsy();</span><br><span class="line">  expect(<span class="literal">false</span>).toBeFalsy();</span><br><span class="line">  expect().toBeFalsy();</span><br><span class="line">  <span class="comment">// expect([]).toBeFalsy();</span></span><br><span class="line">  <span class="comment">// expect(&#123;&#125;).toBeFalsy();</span></span><br><span class="line">  <span class="comment">// expect(1).toBeFalsy();</span></span><br><span class="line">  <span class="comment">// expect(true).toBeFalsy();</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeGreaterThan</code> 期望值 大于  得到值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeGreaterThan'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">5</span>).toBeGreaterThan(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeGreaterThanOrEqual</code>  期望值 大于等于  得到值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeGreaterThanOrEqual'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">5</span>).toBeGreaterThanOrEqual(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeLessThan</code>  期望值 小于  得到值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeLessThan'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">5</span>).toBeLessThan(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeLessThanOrEqual</code> 期望值 小于等于  得到值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeLessThanOrEqual'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">5</span>).toBeLessThanOrEqual(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toBeCloseTo</code> 期望值 接近 得到值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'toBeCloseTo'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">0.1</span> + <span class="number">0.2</span>).toBeCloseTo(<span class="number">0.3</span>);</span><br><span class="line">  <span class="comment">// expect(1).toBeCloseTo(1.1); // Expected difference: &lt; 0.005</span></span><br><span class="line">  expect(<span class="number">1</span>).toBeCloseTo(<span class="number">1.00001</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个误差 在小于0.005</span></span><br></pre></td></tr></table></figure></li><li><p><code>toMatch</code>  期望值匹配正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'there is no I in team'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="string">'team'</span>).not.toMatch(<span class="regexp">/I/</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'but there is a "stop" in Christoph'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="string">'Christoph'</span>).toMatch(<span class="regexp">/stop/</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toContain</code>  得到值 包含在期望的列表里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> direction = [<span class="string">'up'</span>, <span class="string">'down'</span>, <span class="string">'left'</span>, <span class="string">'right'</span>];</span><br><span class="line"></span><br><span class="line">test(<span class="string">'the direction has up on it'</span>, () =&gt; &#123;</span><br><span class="line">  expect(direction).toContain(<span class="string">'up'</span>);</span><br><span class="line">  expect(<span class="keyword">new</span> <span class="built_in">Set</span>(direction)).toContain(<span class="string">'up'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>toThrow</code>  抛出异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileAndroidCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'you are using the wrong JDK'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'compiling android goes as expected'</span>, () =&gt; &#123;</span><br><span class="line">  expect(compileAndroidCode).toThrow();</span><br><span class="line">  expect(compileAndroidCode).toThrow(<span class="built_in">Error</span>);</span><br><span class="line">  expect(compileAndroidCode).toThrow(<span class="string">'you are using the wrong JDK'</span>);</span><br><span class="line">  expect(compileAndroidCode).toThrow(<span class="regexp">/JDK/</span>); <span class="comment">// 匹配 报错中是否有JDK</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      单元测试
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="Jest" scheme="http://blog.decade.run/tags/Jest/"/>
    
  </entry>
  
  <entry>
    <title>初识 jest (一)</title>
    <link href="http://blog.decade.run/2020/10/10/learn-jest-1/"/>
    <id>http://blog.decade.run/2020/10/10/learn-jest-1/</id>
    <published>2020-10-10T00:45:08.000Z</published>
    <updated>2020-10-10T02:17:10.089Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Jest"><a href="#什么是-Jest" class="headerlink" title="什么是    Jest"></a>什么是    Jest</h3><p><a href="https://jestjs.io/docs/zh-Hans/getting-started" target="_blank" rel="noopener"><strong><code>Jest</code></strong></a> Facebook 的一套开源的 JavaScript 测试框架， 它自动集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具，是一款几乎零配置的测试框架</p><p>创建一个 <code>Jest-Test</code> 文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Jest-Test</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>使用 <u><code>yarn</code></u> </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev jest</span><br></pre></td></tr></table></figure></li><li><p>使用  <u><code>npm</code></u> </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jest</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>创建一个  <code>twoSum.js</code> 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoSum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = twoSum;</span><br></pre></td></tr></table></figure></li><li><p>创建一个 <code>twoSum.test.js</code> 文件     </p><p>jest 会默认<strong><code>.test.js</code></strong> 这样的文件为测试文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> twoSum = <span class="built_in">require</span>(<span class="string">"./twoSum"</span>);</span><br><span class="line">test(<span class="string">'add 1 + 2 equal 3'</span>, () =&gt; &#123;</span><br><span class="line">  expect(twoSum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>运行</p><p>修改 <code>package.json</code>  中的 命令 </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"test": "jest"</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn test</span><br></pre></td></tr></table></figure><p>控制台会打印出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> PASS  .&#x2F;twoSmu.test.js</span><br><span class="line">  √ add 1 + 2 equal 3 (2 ms)</span><br><span class="line"></span><br><span class="line">Test Suites: 1 passed, 1 total</span><br><span class="line">Tests:       1 passed, 1 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        3.78 s</span><br><span class="line">Ran all test suites.</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用配置文件来配置"><a href="#使用配置文件来配置" class="headerlink" title="使用配置文件来配置"></a>使用配置文件来配置</h3><ul><li><p>全局安装jest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add jest</span><br></pre></td></tr></table></figure></li><li><p>生成配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jest --init</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 选择node环境还是web浏览器环境</span><br><span class="line">? Choose the test environment that will be used for testing » - Use arrow-keys. Return to submit.</span><br><span class="line">    node</span><br><span class="line">&gt;   jsdom (browser-like)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 是否想让jest生成覆盖率报告</span><br><span class="line">? Do you want Jest to add coverage reports? » (y&#x2F;N) y</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 应该使用哪个提供程序来检测覆盖范围的代码</span><br><span class="line">? Which provider should be used to instrument code for coverage? » - Use arrow-keys. Return to submit.</span><br><span class="line">    v8</span><br><span class="line">&gt;   babel</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在每个测试之间自动清除模拟调用和实例</span><br><span class="line">? Automatically clear mock calls and instances between every test? » (y&#x2F;N) y</span><br></pre></td></tr></table></figure></li><li><p>生成的 <code>jest.config.js</code> 文件 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  clearMocks: <span class="literal">true</span>, <span class="comment">// 这个就是 自动清除模拟调用和实例</span></span><br><span class="line">  coverageDirectory: <span class="string">"coverage"</span>, <span class="comment">// 这个是生成 覆盖率文件的文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释的内容被我清除了</span></span><br></pre></td></tr></table></figure></li><li><p>由于 <code>jest</code> 不认识   <code>export/import</code> 所以我们需要使用 <code>babel</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev babel-jest @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure></li><li><p>创建 <code>babel.config.js</code> 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          node: <span class="string">'current'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>我们尝试下babel安装成功没有</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// twoSum.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> twoSum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// twoSum.test.js</span></span><br><span class="line"><span class="keyword">import</span> twoSum <span class="keyword">from</span> <span class="string">'./twoSum'</span>;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>package.json</code>  中添加一条命令 生成覆盖率</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"coverage": "jest --coverage"</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">yarn test</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 成功</span><br><span class="line"> PASS  .&#x2F;twoSmu.test.js</span><br><span class="line">  √ add 1 + 2 equal 3 (2 ms)</span><br><span class="line"></span><br><span class="line">Test Suites: 1 passed, 1 total</span><br><span class="line">Tests:       1 passed, 1 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        3.687 s</span><br><span class="line">Ran all test suites.</span><br><span class="line">Done in 5.32s.</span><br><span class="line"></span><br><span class="line">yarn coverage</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 生成的覆盖率 并且多了个coverage文件</span><br><span class="line">-----------|---------|----------|---------|---------|-------------------</span><br><span class="line">File       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s</span><br><span class="line">-----------|---------|----------|---------|---------|-------------------</span><br><span class="line">All files  |     100 |      100 |     100 |     100 |</span><br><span class="line"> twoSum.js |     100 |      100 |     100 |     100 |</span><br><span class="line">-----------|---------|----------|---------|---------|-------------------</span><br><span class="line">Test Suites: 1 passed, 1 total</span><br><span class="line">Tests:       1 passed, 1 total</span><br><span class="line">Snapshots:   0 total</span><br><span class="line">Time:        2.992 s, estimated 3 s</span><br><span class="line">Ran all test suites.</span><br><span class="line">Done in 4.35s.</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      单元测试
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="Jest" scheme="http://blog.decade.run/tags/Jest/"/>
    
  </entry>
  
  <entry>
    <title>learn-ts-5</title>
    <link href="http://blog.decade.run/2020/09/25/learn-ts-5/"/>
    <id>http://blog.decade.run/2020/09/25/learn-ts-5/</id>
    <published>2020-09-25T02:05:02.000Z</published>
    <updated>2020-10-01T01:13:28.008Z</updated>
    
    <summary type="html">
    
      学习使我快乐
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="TypeScript" scheme="http://blog.decade.run/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 重学 (四)</title>
    <link href="http://blog.decade.run/2020/09/25/learn-ts-4/"/>
    <id>http://blog.decade.run/2020/09/25/learn-ts-4/</id>
    <published>2020-09-25T02:04:19.000Z</published>
    <updated>2020-10-01T01:13:35.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TypeScript-泛型"><a href="#TypeScript-泛型" class="headerlink" title="TypeScript 泛型"></a>TypeScript 泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p><strong>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</strong></p><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p><p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><ol><li><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Author&lt;T&gt; &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  (params: T): T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Temp&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp = <span class="keyword">new</span> Temp&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>);</span><br><span class="line">temp.add = <span class="function"><span class="keyword">function</span>(<span class="params">x: nember, y: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h4><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p><ul><li>T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul></li><li><h4 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h4><ol><li><p><strong>typeof</strong></p><p>在 TypeScript 中，<code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bookData = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'JavaScript入门到入土'</span>,</span><br><span class="line">    author: <span class="string">'aaa'</span>,</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    publicDate: <span class="string">'xxxx-xx-xx'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">'你不知道的JavaScript'</span>,</span><br><span class="line">    author: <span class="string">'bbb'</span>,</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    publicDate: <span class="string">'xxxx-xx-xx'</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BookType = <span class="keyword">typeof</span> bookData:</span><br><span class="line"><span class="comment">// TypeScript会自动的推断出BookType类型 &#123;name: string; author: string, id: number, publicDate: string &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddFuncType = <span class="keyword">typeof</span> add; <span class="comment">// =&gt; (x: number, y: number) =&gt; number</span></span><br></pre></td></tr></table></figure></li><li><p><strong>keyof</strong></p><p><code>keyof</code> 该操作符可以用于获取某种类型的所有键，其返回类型是联合类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> k1 = keyof Person; <span class="comment">// "name" | "age" </span></span><br><span class="line"><span class="keyword">let</span> a: k1 <span class="comment">// 这个时候a的取值 只能是"name" 或者 "age"</span></span><br><span class="line">a = <span class="string">"name"</span></span><br><span class="line">a = <span class="string">"age"</span></span><br><span class="line">a = <span class="string">"nihao"</span> <span class="comment">// Type '"nihao"' is not assignable to type '"name" | "age"'.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> k2 = keyof Person[]; </span><br><span class="line"><span class="comment">// type k2 = number | "length" | "toString" | "toLocaleString" | "pop" | "push" | "concat" | "join" | "reverse" | "shift" | "slice" | "sort" | "splice" | "unshift" | "indexOf" | "lastIndexOf" | ... 14 more ... | "includes"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b: k2;</span><br><span class="line"><span class="comment">// 通过上面的可以看出 b可以是数字 也可以是"length", "toString", "toLocaleString",  "pop", "push", "concat" ,"join" ,"reverse" ,"shift" ,"slice" ,"sort" ,"splice" ,"unshift" ,"indexOf" ,"lastIndexOf" ,"includes"  这些字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> k3 = keyof <span class="built_in">boolean</span>; <span class="comment">// type k3 = "valueOf"</span></span><br><span class="line"><span class="keyword">type</span> k4 = keyof <span class="built_in">number</span> <span class="comment">// type k4 = "toString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf" | "toLocaleString"</span></span><br><span class="line"><span class="keyword">type</span> k5 = keyof <span class="built_in">string</span> <span class="comment">// type k5 = number | "toString" | "charAt" | "charCodeAt" | "concat" | "indexOf" | "lastIndexOf" | "localeCompare" | "match" | "replace" | "search" | "slice" | "split" | "substring" | "toLowerCase" | ... 27 more ... | "padEnd"</span></span><br><span class="line"><span class="keyword">type</span> k6 = keyof symbol <span class="comment">// type k6 = "toString" | "valueOf"</span></span><br><span class="line"><span class="keyword">type</span> k7 = keyof <span class="literal">undefined</span> <span class="comment">// type k7 = never</span></span><br><span class="line"><span class="keyword">type</span> k8 = keyof <span class="literal">null</span> <span class="comment">// type k8 = never</span></span><br><span class="line"><span class="keyword">type</span> k9 = keyof <span class="built_in">any</span> <span class="comment">// type k1 = string | number | symbol</span></span><br></pre></td></tr></table></figure><p><code>keyof</code> 也称为输入索引类型查询，与之相对应的是索引访问类型，也称为查找类型。在语法上，它们看起来像属性或元素访问，但最终会被转换为类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> k1 = Person[<span class="string">"name"</span>];  <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> k2 = Person[<span class="string">"name"</span> | <span class="string">"age"</span>];  <span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> k3 = <span class="built_in">string</span>[<span class="string">"charAt"</span>];  <span class="comment">// (pos: number) =&gt; string</span></span><br><span class="line"><span class="keyword">type</span> k4 = <span class="built_in">string</span>[][<span class="string">"push"</span>];  <span class="comment">// (...items: string[]) =&gt; number</span></span><br></pre></td></tr></table></figure></li><li><p><strong>in</strong></p><p><code>in</code> 用来遍历枚举类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> obj = &#123;</span><br><span class="line">  [p <span class="keyword">in</span> Keys]: <span class="built_in">any</span></span><br><span class="line">&#125;<span class="comment">// =&gt; &#123; a: any, b: any, c: any &#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>infer</strong></p><p>在 TypeScript 中我们能够很方便地从复合类型中提取出单个类型，以数组、元组或对象为例，我们可以通过成员访问的语法来提取数组、元组或对象中元素或属性的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonName = Person[<span class="string">"name"</span>]; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> StrNumTuple = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> StrNumTuple0 = StrNumTuple[<span class="number">0</span>]; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> NumArr = <span class="built_in">number</span>[];</span><br><span class="line"><span class="keyword">type</span> NumArrMember = NumArr[<span class="number">0</span>]; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> PersonName = Person[<span class="string">"name"</span>]; <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dictionary&lt;T = any&gt; &#123;</span><br><span class="line">  [key: <span class="built_in">string</span>]: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StrDict = Dictionary&lt;<span class="built_in">number</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StrDictMember = StrDict[<span class="string">""</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p>除了上面的方式外, 我们还可以在条件类型语句中，可以用 <code>infer</code> 声明一个类型变量并且对它进行使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> func = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> variable = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> funcReturnType = ReturnType&lt;func&gt;; <span class="comment">// funcReturnType 类型为 number</span></span><br><span class="line"><span class="keyword">type</span> varReturnType = ReturnType&lt;variable&gt;; <span class="comment">// varReturnType 类型为 string</span></span><br></pre></td></tr></table></figure><p>  <code>infer</code> 可以用来解包</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没用infer</span></span><br><span class="line"><span class="keyword">type</span> Ids = <span class="built_in">number</span>[];</span><br><span class="line"><span class="keyword">type</span> Names = <span class="built_in">string</span>[];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> Unpacked&lt;T&gt; = T <span class="keyword">extends</span> Names ? <span class="built_in">string</span> : T <span class="keyword">extends</span> Ids ? <span class="built_in">number</span> : T;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> idType = Unpacked&lt;Ids&gt;; <span class="comment">// idType 类型为 number</span></span><br><span class="line"><span class="keyword">type</span> nameType = Unpacked&lt;Names&gt;; <span class="comment">// nameType 类型为string</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用infer</span></span><br><span class="line"><span class="keyword">type</span> Unpacked&lt;T&gt; = T <span class="keyword">extends</span> (infer R)[] ? R : T;</span><br><span class="line"><span class="comment">// 如果T是某个待推断类型的数组，则返回推断的类型，否则返回T</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> idType = Unpacked&lt;Ids&gt;; <span class="comment">// idType 类型为 number</span></span><br><span class="line"><span class="keyword">type</span> nameType = Unpacked&lt;Names&gt;; <span class="comment">// nameType 类型为string</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// promise 中使用infer</span></span><br><span class="line">asyncfunction stringPromise() &#123;</span><br><span class="line">  <span class="keyword">return</span><span class="string">"Hello, Semlinker!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncfunction personPromise() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name: <span class="string">"Semlinker"</span>, age: <span class="number">30</span> &#125; <span class="keyword">as</span> Person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PromiseType&lt;T&gt; = <span class="function">(<span class="params">args: <span class="built_in">any</span>[]</span>) =&gt;</span><span class="built_in">Promise</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">type</span> UnPromisify&lt;T&gt; = T <span class="keyword">extends</span> PromiseType&lt;infer U&gt; ? U : never;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> extractStringPromise = UnPromisify&lt;<span class="keyword">typeof</span> stringPromise&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> extractPersonPromise = UnPromisify&lt;<span class="keyword">typeof</span> personPromise&gt;; <span class="comment">// Person</span></span><br></pre></td></tr></table></figure><p>  <code>infer</code> 推断联合类型</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo&lt;T&gt; = T <span class="keyword">extends</span> &#123; a: infer U; b: infer U &#125; ? U : never;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T10 = Foo&lt;&#123; a: <span class="built_in">string</span>; b: <span class="built_in">string</span> &#125;&gt;; <span class="comment">// T10类型为 string</span></span><br><span class="line"><span class="keyword">type</span> T11 = Foo&lt;&#123; a: <span class="built_in">string</span>; b: <span class="built_in">number</span> &#125;&gt;; <span class="comment">// T11类型为 string | number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一个类型变量在推断的值有多种情况的时候会推断为联合类型，针对这个特性，很方便的可以将元组转为联合类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElementOf&lt;T&gt; = T <span class="keyword">extends</span> (infer R)[] ? R : never;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TTuple = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> Union = ElementOf&lt;TTuple&gt;; <span class="comment">// Union 类型为 string | number</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> extractArrayType&lt;T&gt; = T <span class="keyword">extends</span> (infer U)[] ? U : never; <span class="comment">//传的必须是一个泛型数组</span></span><br><span class="line"><span class="keyword">let</span> stringType : extractArrayType&lt;[<span class="string">"test"</span>]&gt; = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stringTypeNoArray : extractArrayType&lt;<span class="string">"test"</span>&gt; = <span class="string">"test"</span>;</span><br><span class="line"><span class="comment">// Type '"test"' is not assignable to type 'never'.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> InferredAb&lt;T&gt; = T <span class="keyword">extends</span> &#123; a: infer U, b: infer U &#125; ? U : T; <span class="comment">// 就是能满足 返回 a | b 类型的联合类型</span></span><br><span class="line"><span class="keyword">type</span> abInferredNumber = InferredAb&lt; &#123; a :<span class="built_in">number</span>, b: <span class="built_in">number</span>&#125;&gt;; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> abinf : abInferredNumber = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> abInferredNumberString = InferredAb&lt; &#123; a :<span class="built_in">number</span>, b: <span class="built_in">string</span>&#125;&gt;; <span class="comment">// number | string </span></span><br><span class="line"><span class="keyword">let</span> abinfstr : abInferredNumberString = <span class="number">1</span>;</span><br><span class="line">abinfstr = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>extends</strong></p><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ILengthwise &#123;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, number doesn't have a .length property</span></span><br><span class="line"></span><br><span class="line">loggingIdentity(&#123;length: <span class="number">10</span>, value: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li><p><strong>Partial</strong></p><p><code>Partial&lt;T&gt;</code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * node_modules/typescript/lib/lib.es5.d.ts</span></span><br><span class="line"><span class="comment"> * Make all properties in T optional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将T类型中的所有的属性 全部变成可选属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Author &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  hobby: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Author1 = Partial&lt;Author&gt;;</span><br><span class="line"><span class="comment">// type Author1 = &#123; name?: string; age?: number; hobby?: string; &#125;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>TypeScript 装饰器</p><ol><li><h4 id="装饰器是什么"><a href="#装饰器是什么" class="headerlink" title="装饰器是什么"></a>装饰器是什么</h4><ul><li>它是一个表达式</li><li>该表达式被执行后，返回一个函数</li><li>函数的入参分别为 target、name 和 descriptor</li><li>执行该函数后，可能返回 descriptor 对象，用于配置 target 对象</li></ul></li><li><h4 id="装饰器的分类"><a href="#装饰器的分类" class="headerlink" title="装饰器的分类"></a>装饰器的分类</h4><ul><li><p>类装饰器（Class decorators）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类装饰器的声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ClassDecorator = &lt;TFunction <span class="keyword">extends</span> <span class="built_in">Function</span>&gt;(</span><br><span class="line">  target: TFunction</span><br><span class="line">) =&gt; TFunction | <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// 参数target 就是被装饰的类</span></span><br></pre></td></tr></table></figure></li><li><p>属性装饰器（Property decorators）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性装饰器声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> PropertyDecorator = (target:<span class="built_in">Object</span>, </span><br><span class="line">  propertyKey: <span class="built_in">string</span> | symbol ) =&gt; <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// target 被装饰的类 propertyKey: 被装饰的键名</span></span><br></pre></td></tr></table></figure></li><li><p>方法装饰器（Method decorators）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法装饰器声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> MethodDecorator = &lt;T&gt;(target:<span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | symbol,    </span><br><span class="line">  descriptor: TypePropertyDescript&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// target 被装饰的类  propertyKey: 方法名 descriptor: 属性描述符</span></span><br></pre></td></tr></table></figure></li><li><p>参数装饰器（Parameter decorators）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数装饰器声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> ParameterDecorator = (target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span> | symbol, </span><br><span class="line">  parameterIndex: <span class="built_in">number</span> ) =&gt; <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// target: 被装饰的类 propertyKey: 方法名 parameterIndex: 方法中参数的索引值</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><h3 id="编译上下文"><a href="#编译上下文" class="headerlink" title="编译上下文"></a>编译上下文</h3><ol><li><h4 id="tsconfig-json-的作用"><a href="#tsconfig-json-的作用" class="headerlink" title="tsconfig.json 的作用"></a>tsconfig.json 的作用</h4><ul><li>用于标识 TypeScript 项目的根路径；</li><li>用于配置 TypeScript 编译器；</li><li>用于指定编译的文件。</li></ul></li><li><h4 id="tsconfig-json-重要字段"><a href="#tsconfig-json-重要字段" class="headerlink" title="tsconfig.json 重要字段"></a>tsconfig.json 重要字段</h4><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项</li></ul></li><li><h4 id="compilerOptions-选项"><a href="#compilerOptions-选项" class="headerlink" title="compilerOptions 选项"></a>compilerOptions 选项</h4><p>compilerOptions 支持很多选项，常见的有 <code>baseUrl</code>、 <code>target</code>、<code>baseUrl</code>、 <code>moduleResolution</code> 和 <code>lib</code> 等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 基本选项 */</span></span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"es5"</span>,                       <span class="comment">// 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'</span></span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"commonjs"</span>,                  <span class="comment">// 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'</span></span><br><span class="line">    <span class="string">"lib"</span>: [],                             <span class="comment">// 指定要包含在编译中的库文件</span></span><br><span class="line">    <span class="string">"allowJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 允许编译 javascript 文件</span></span><br><span class="line">    <span class="string">"checkJs"</span>: <span class="literal">true</span>,                       <span class="comment">// 报告 javascript 文件中的错误</span></span><br><span class="line">    <span class="string">"jsx"</span>: <span class="string">"preserve"</span>,                     <span class="comment">// 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'</span></span><br><span class="line">    <span class="string">"declaration"</span>: <span class="literal">true</span>,                   <span class="comment">// 生成相应的 '.d.ts' 文件</span></span><br><span class="line">    <span class="string">"sourceMap"</span>: <span class="literal">true</span>,                     <span class="comment">// 生成相应的 '.map' 文件</span></span><br><span class="line">    <span class="string">"outFile"</span>: <span class="string">"./"</span>,                       <span class="comment">// 将输出文件合并为一个文件</span></span><br><span class="line">    <span class="string">"outDir"</span>: <span class="string">"./"</span>,                        <span class="comment">// 指定输出目录</span></span><br><span class="line">    <span class="string">"rootDir"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用来控制输出目录结构 --outDir.</span></span><br><span class="line">    <span class="string">"removeComments"</span>: <span class="literal">true</span>,                <span class="comment">// 删除编译后的所有的注释</span></span><br><span class="line">    <span class="string">"noEmit"</span>: <span class="literal">true</span>,                        <span class="comment">// 不生成输出文件</span></span><br><span class="line">    <span class="string">"importHelpers"</span>: <span class="literal">true</span>,                 <span class="comment">// 从 tslib 导入辅助工具函数</span></span><br><span class="line">    <span class="string">"isolatedModules"</span>: <span class="literal">true</span>,               <span class="comment">// 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 严格的类型检查选项 */</span></span><br><span class="line">    <span class="string">"strict"</span>: <span class="literal">true</span>,                        <span class="comment">// 启用所有严格类型检查选项</span></span><br><span class="line">    <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,                 <span class="comment">// 在表达式和声明上有隐含的 any类型时报错</span></span><br><span class="line">    <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>,              <span class="comment">// 启用严格的 null 检查</span></span><br><span class="line">    <span class="string">"noImplicitThis"</span>: <span class="literal">true</span>,                <span class="comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span></span><br><span class="line">    <span class="string">"alwaysStrict"</span>: <span class="literal">true</span>,                  <span class="comment">// 以严格模式检查每个模块，并在每个文件里加入 'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 额外的检查 */</span></span><br><span class="line">    <span class="string">"noUnusedLocals"</span>: <span class="literal">true</span>,                <span class="comment">// 有未使用的变量时，抛出错误</span></span><br><span class="line">    <span class="string">"noUnusedParameters"</span>: <span class="literal">true</span>,            <span class="comment">// 有未使用的参数时，抛出错误</span></span><br><span class="line">    <span class="string">"noImplicitReturns"</span>: <span class="literal">true</span>,             <span class="comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span></span><br><span class="line">    <span class="string">"noFallthroughCasesInSwitch"</span>: <span class="literal">true</span>,    <span class="comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模块解析选项 */</span></span><br><span class="line">    <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,            <span class="comment">// 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)</span></span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"./"</span>,                       <span class="comment">// 用于解析非相对模块名称的基目录</span></span><br><span class="line">    <span class="string">"paths"</span>: &#123;&#125;,                           <span class="comment">// 模块名到基于 baseUrl 的路径映射的列表</span></span><br><span class="line">    <span class="string">"rootDirs"</span>: [],                        <span class="comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span></span><br><span class="line">    <span class="string">"typeRoots"</span>: [],                       <span class="comment">// 包含类型声明的文件列表</span></span><br><span class="line">    <span class="string">"types"</span>: [],                           <span class="comment">// 需要包含的类型声明文件名列表</span></span><br><span class="line">    <span class="string">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,  <span class="comment">// 允许从没有设置默认导出的模块中默认导入。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="string">"sourceRoot"</span>: <span class="string">"./"</span>,                    <span class="comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span></span><br><span class="line">    <span class="string">"mapRoot"</span>: <span class="string">"./"</span>,                       <span class="comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span></span><br><span class="line">    <span class="string">"inlineSourceMap"</span>: <span class="literal">true</span>,               <span class="comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span></span><br><span class="line">    <span class="string">"inlineSources"</span>: <span class="literal">true</span>,                 <span class="comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他选项 */</span></span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,        <span class="comment">// 启用装饰器</span></span><br><span class="line">    <span class="string">"emitDecoratorMetadata"</span>: <span class="literal">true</span>          <span class="comment">// 为装饰器提供元数据的支持</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      学习使我快乐
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="TypeScript" scheme="http://blog.decade.run/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 重学 (三)</title>
    <link href="http://blog.decade.run/2020/09/24/learn-ts-3/"/>
    <id>http://blog.decade.run/2020/09/24/learn-ts-3/</id>
    <published>2020-09-24T03:39:00.000Z</published>
    <updated>2020-10-01T01:13:43.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TypeScript-数组"><a href="#TypeScript-数组" class="headerlink" title="TypeScript 数组"></a>TypeScript 数组</h3><ol><li><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span>; </span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">number</span> ;</span><br><span class="line"><span class="keyword">let</span> z: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">[x,y,z] = arr;</span><br></pre></td></tr></table></figure></li><li><h4 id="数组展开运算符"><a href="#数组展开运算符" class="headerlink" title="数组展开运算符"></a>数组展开运算符</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [...arr <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure></li><li><h4 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors: <span class="built_in">string</span>[] = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i of colors) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="TypeScript-对象"><a href="#TypeScript-对象" class="headerlink" title="TypeScript 对象"></a>TypeScript 对象</h3><ol><li><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> author = &#123;</span><br><span class="line">  name: <span class="string">"Decade"</span>,</span><br><span class="line">  gender: <span class="string">"Male"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, gender &#125; = author;</span><br></pre></td></tr></table></figure></li><li><h4 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> author = &#123;</span><br><span class="line">  name: <span class="string">"Decade"</span>,</span><br><span class="line">  gender: <span class="string">"Male"</span>,</span><br><span class="line">  address: <span class="string">"ChongQing"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装对象</span></span><br><span class="line"><span class="keyword">let</span> authorWithAge = &#123; ...author, age: <span class="number">33</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取除了某些项外的其它项</span></span><br><span class="line"><span class="keyword">let</span> &#123; name, ...rest &#125; = author;</span><br></pre></td></tr></table></figure></li></ol><h3 id="TypeScript-接口"><a href="#TypeScript-接口" class="headerlink" title="TypeScript 接口"></a>TypeScript 接口</h3><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p><ol><li><h4 id="对象的形状"><a href="#对象的形状" class="headerlink" title="对象的形状"></a>对象的形状</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Author &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> author: Author = &#123;</span><br><span class="line">  name: <span class="string">"Decade"</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><h4 id="可选-只读属性"><a href="#可选-只读属性" class="headerlink" title="可选 | 只读属性"></a>可选 | 只读属性</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Author &#123;</span><br><span class="line">  readonly name: <span class="built_in">string</span>; <span class="comment">// 只读</span></span><br><span class="line">  age?: <span class="built_in">number</span>; <span class="comment">// 可选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray&lt;T&gt; 类型，它与 Array&lt;T&gt; 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="TypeScript-类"><a href="#TypeScript-类" class="headerlink" title="TypeScript 类"></a>TypeScript 类</h3><ol><li><h4 id="类的属性与方法"><a href="#类的属性与方法" class="headerlink" title="类的属性与方法"></a>类的属性与方法</h4><p>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Author &#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> name: <span class="built_in">string</span> = <span class="string">"Decade"</span>;</span><br><span class="line">  <span class="comment">// 成员属性</span></span><br><span class="line">  msg: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.msg = message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Class name is Author"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  info() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> author = <span class="keyword">new</span> Author(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>那么成员属性与静态属性，成员方法与静态方法有什么区别呢？我们直接看一下以下编译生成的 ES5 代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> Author = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数 - 执行初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Author</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    Author.getClassName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Class name is Author"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    Author.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, "</span> + <span class="keyword">this</span>.msg;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    Author.cname = <span class="string">"Decade"</span>;</span><br><span class="line">    <span class="keyword">return</span> Author;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> author = <span class="keyword">new</span> Author(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure></li><li><h4 id="访问器"><a href="#访问器" class="headerlink" title="访问器"></a>访问器</h4><p>在 TypeScript 中，我们可以通过 <code>getter</code> 和 <code>setter</code> 方法来实现数据的封装和有效性校验，防止出现异常数据。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">"Hello TypeScript"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">  <span class="keyword">private</span> _fullName: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">"Hello TypeScript"</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._fullName = newName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Error: Unauthorized update of employee!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.fullName = <span class="string">"Semlinker"</span>;</span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = theName;</span><br><span class="line">  &#125;</span><br><span class="line">  move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Snake <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  move(distanceInMeters = <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Slithering..."</span>);</span><br><span class="line">    <span class="keyword">super</span>.move(distanceInMeters);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">"Sammy the Python"</span>);</span><br><span class="line">sam.move();</span><br></pre></td></tr></table></figure></li><li><h4 id="ECMAScript-私有字段"><a href="#ECMAScript-私有字段" class="headerlink" title="ECMAScript 私有字段"></a>ECMAScript 私有字段</h4><p>在 TypeScript 3.8 版本就开始支持<strong>ECMAScript 私有字段</strong>，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  #name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.#name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> semlinker = <span class="keyword">new</span> Person(<span class="string">"Semlinker"</span>);</span><br><span class="line"></span><br><span class="line">semlinker.#name;</span><br><span class="line"><span class="comment">//     ~~~~~</span></span><br><span class="line"><span class="comment">// Property '#name' is not accessible outside class 'Person'</span></span><br><span class="line"><span class="comment">// because it has a private identifier.</span></span><br></pre></td></tr></table></figure><p>与常规属性（甚至使用 <code>private</code> 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      学习使我快乐
    
    </summary>
    
    
    
      <category term="learn" scheme="http://blog.decade.run/tags/learn/"/>
    
      <category term="TypeScript" scheme="http://blog.decade.run/tags/TypeScript/"/>
    
  </entry>
  
</feed>
