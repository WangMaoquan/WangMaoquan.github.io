<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王小明</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://myblog.loveli.top/"/>
  <updated>2020-04-20T08:56:20.461Z</updated>
  <id>http://myblog.loveli.top/</id>
  
  <author>
    <name>Decade W</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>learn-ts 进阶</title>
    <link href="http://myblog.loveli.top/2020/04/20/learn-ts5/"/>
    <id>http://myblog.loveli.top/2020/04/20/learn-ts5/</id>
    <published>2020-04-20T07:20:02.000Z</published>
    <updated>2020-04-20T08:56:20.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h2><p><font color="red">keyof</font>与<font color="red">Object.keys</font>相似, 只不过<font color="red">keyof</font>是取得<font color="red">interface</font>的键值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPoint &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> keys = <span class="keyword">typeof</span> IPoint; <span class="comment">// "x" | "y"</span></span><br></pre></td></tr></table></figure><p>假设有一个 <font color="red">object</font>如下所示，我们需要使用 <font color="red">typescript </font>实现一个 <font color="red">get</font>函数来获取它的属性值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  hello: <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">o: object, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会有以下的缺点</p><ol><li>无法确认返回类型</li><li>无法对key做约束</li></ol><p>typescript keyof加强版</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">object</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Required-Partial-Pick"><a href="#Required-Partial-Pick" class="headerlink" title="Required Partial Pick"></a>Required Partial Pick</h2><ol><li>required 将接口中的所有属性变成必选属性</li><li>Partial 将接口中所有属性变成可选属性</li><li>Pick 挑选出自己需要的属性<br>源码及例子如下: <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  age: ?<span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> RequiredUser = Required&lt;User&gt;</span><br><span class="line"><span class="comment">// 相当于: type RequiredUser = &#123; id: number; age: number; name: string; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialUser = Partial&lt;User&gt;</span><br><span class="line"><span class="comment">// 相当于: type PartialUser = &#123; id?: number; age?: number; name?: string; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PickUser = Pick&lt;User, <span class="string">"id"</span> | <span class="string">"age"</span>&gt;</span><br><span class="line"><span class="comment">// 相当于: type PickUser = &#123; id: number; age: number; &#125;</span></span><br></pre></td></tr></table></figure><h2 id="Condition-Type-条件泛型"><a href="#Condition-Type-条件泛型" class="headerlink" title="Condition Type 条件泛型"></a>Condition Type 条件泛型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U ? X : Y <span class="comment">// 判断一个类型 T 是否是类型 U 的子类型，是则返回 X，不是返回 Y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Condition&lt;T&gt; = T <span class="keyword">extends</span> &#123; name: <span class="built_in">string</span> &#125; ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> Test1 = Condition&lt;&#123; name: <span class="built_in">string</span>; value: <span class="built_in">number</span> &#125;&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> Test2 = Condition&lt;&#123; value: <span class="built_in">number</span> &#125;&gt;; <span class="comment">// number;</span></span><br></pre></td></tr></table></figure><h2 id="never-Exclude-Omit"><a href="#never-Exclude-Omit" class="headerlink" title="never Exclude Omit"></a>never Exclude Omit</h2></li><li>never是永远不会出现的值的类型</li><li>T Exclude U T类型是否是U的子类型</li><li>Omit除了输入的那个不要, 别的全部都要<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never 踩坑</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  arr: [] <span class="comment">// never类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为什么这里会是never类型的呢? never类型是一个永远不会出现的值, 而这里初始化就是一个空数组, 根据ts推断 这个数组永远都会是空的</span></span><br><span class="line">obj.arr.push(<span class="string">"123"</span>); <span class="comment">// 类型“"123"”的参数不能赋给类型“never”的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Omit源码</span></span><br><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于: type PickUser = &#123; age: number; name: string; &#125;</span></span><br><span class="line"><span class="keyword">type</span> OmitUser = Omit&lt;User, <span class="string">"id"</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><div class="note info">            <p>补充一下, 下面代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  obj: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj1.obj = &#123;a: <span class="number">123</span>&#125;</span><br><span class="line">obj1.obj = <span class="number">1</span></span><br></pre></td></tr></table></figure>在这里的obj1.obj 并没有被推导成{[key: string]: never}相反是被推导成了any官方的解释是这样的<font color="red" size="6">Types with no members can be substituted by any type.In general, you should never find yourself declaring an interface with no properties.</font><font color="yellow" size="6">没有成员的类型可以被任何类型替换。通常，您永远不会发现自己在声明一个没有属性的接口。</font><p>动态语言鸭子类型<br><font color="blue" size="6">If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</font><br><font color="pink">如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。在动态语言中，我们会更关注对象的行为，而非对象本身的类型。所以，这里也是有这种鸭子类型的含义在里面：一个空接口没有任何行为，相当于所有类型都实现了它；它变成了所有类型的父类。</font></p>          </div><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> = <span class="number">3</span></span><br><span class="line"><span class="comment">// 相当于: const b: number = 4</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="keyword">typeof</span> a = <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      typescript 技巧
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/categories/TypeScript/"/>
    
    
      <category term="learn" scheme="http://myblog.loveli.top/tags/learn/"/>
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>初识vue3.0 中的proxy</title>
    <link href="http://myblog.loveli.top/2020/04/20/learn-vue2/"/>
    <id>http://myblog.loveli.top/2020/04/20/learn-vue2/</id>
    <published>2020-04-20T05:58:39.000Z</published>
    <updated>2020-04-20T06:39:05.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p>什么是<font color="red">proxy</font>, 可以理解为在对象之前设置一个“拦截”，当该对象被访问的时候，都必须经过这层拦截。意味着你可以在这层拦截中进行各种操作(比如你可以在这层拦截中对原对象进行处理，返回你想返回的数据结构)<br>ES6提供了原生的Proxy构造函数, 让我们先来看看怎么使用: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><ul><li>target: 所要拦截的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li><li>handler：一个对象，定义要拦截的行为<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, propKey) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'哈哈，你被我拦截了'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p.name);</span><br><span class="line"><span class="comment">// 哈哈，你被我拦截了</span></span><br></pre></td></tr></table></figure>上面的代码可以这么理解, 当你访问p这个对象时, 你需要先到代理的那个空对象, 因为这里是读取name属性的值, 即get操作, 所以会进入到handle的get里面 这里面就是我们的返回我们需要的数据的操作了<div class="note info">            <p>注意Proxy是用来操作对象的。代理的目的是为了拓展对象的能力。</p>          </div>再看一个例子 我们可以实现一个功能：不允许外部修改对象的name属性。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="keyword">set</span>(target, propKey, value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (propKey === <span class="string">'name'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'name属性不允许修改'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是 name 属性，直接保存</span></span><br><span class="line">        target[propKey] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.name = <span class="string">'proxy'</span>;</span><br><span class="line"><span class="comment">// TypeError: name属性不允许修改</span></span><br><span class="line">p.a = <span class="number">111</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.a); <span class="comment">// 111</span></span><br></pre></td></tr></table></figure>Proxy支持的拦截操作一共有13种,  如果没有写的就表示默认</li></ul><ol><li>handle.getPrototypeOf() 在读取代理对象的原型时触发该操作</li><li>handle.setPrototypeOf() 在设置代理对象的原型时触发该操作</li><li>handler.isExtensible() 在判断一个代理对象是否是可扩展时触发该操作</li><li>handler.preventExtensions() 在让一个代理对象不可扩展时触发该操作</li><li>handler.getOwnPropertyDescriptor() 在获取代理对象某个属性的属性描述时触发该操作</li><li>handler.defineProperty() 在定义代理对象某个属性时的属性描述时触发该操作</li><li>handler.has() 在判断代理对象是否拥有某个属性时触发该操作</li><li>handler.get() 在读取代理对象的某个属性时触发该操作</li><li>handler.set() 在给代理对象的某个属性赋值时触发该操作</li><li>handler.deleteProperty() 在删除代理对象的某个属性时触发该操作</li><li>handler.ownKeys() Object.getOwnPropertyNames 和Object.getOwnPropertySymbols </li><li>handler.apply() 函数调用操作</li><li>handler.construct() new 运算符的陷阱</li></ol><h2 id="vue2-x是怎么实现数据的响应呢"><a href="#vue2-x是怎么实现数据的响应呢" class="headerlink" title="vue2.x是怎么实现数据的响应呢?"></a>vue2.x是怎么实现数据的响应呢?</h2><p>递归遍历data中的数据，使用 Object.defineProperty()劫持 getter和setter，在getter中做数据依赖收集处理，在setter中 监听数据的变化，并通知订阅当前数据的地方。部分源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line"> <span class="comment">// 对 data中的数据进行深度遍历，给对象的每个属性添加响应式</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">         <span class="comment">// 进行依赖收集</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">// 是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。</span></span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新的值需要重新进行observe，保证数据响应式</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      <span class="comment">// 将数据变化通知所有的观察者</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>这样的会有这么几个问题: </p><ol><li>检测不到对象属性的添加和删除：当你在对象上新加了一个属性newProperty，当前新加的这个属性并没有加入vue检测数据更新的机制(因为是在初始化之后添加的)。<br>解决措施:  vue.$set是能让vue知道你添加了属性, 它会给你做处理，$set内部也是通过调用Object.defineProperty()去处理的</li><li>无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。</li><li>当data中数据比较多且层级很深的时候，会有性能问题，因为要遍历data中所有的数据并给其设置成响应式的</li></ol><p>举个栗子, 代码如下: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"example"</span>&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">"item in items"</span>&gt;</span><br><span class="line">        &#123;&#123; item &#125;&#125;</span><br><span class="line">    &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">const vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el: '#example',</span></span><br><span class="line"><span class="regexp">    data: &#123;</span></span><br><span class="line"><span class="regexp">        items: ['a', 'b', 'c']</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 直接使用下标修改数据不是实时响应</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    vm.items[1] = 'x';</span></span><br><span class="line"><span class="regexp">    vm.items[3] = 'd';</span></span><br><span class="line"><span class="regexp">    console.log(vm.items);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 此时打印结果为 ['a', 'x', 'c', 'd']，但页面内容没有更新</span></span><br><span class="line"><span class="regexp">&#125;, 500);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 使用 $set 修改数据是实时响应</span></span><br><span class="line"><span class="regexp">setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    vm.$set(vm.items, 1, 'x1')</span></span><br><span class="line"><span class="regexp">    vm.$set(vm.items, 3, 'd1')</span></span><br><span class="line"><span class="regexp">    console.log(vm.items);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 此时打印结果为 ['a', 'x1', 'c', 'd1']，页面内容更新</span></span><br><span class="line"><span class="regexp">&#125;, 1000);</span></span><br></pre></td></tr></table></figure><h2 id="vue3-0使用了Proxy"><a href="#vue3-0使用了Proxy" class="headerlink" title="vue3.0使用了Proxy"></a>vue3.0使用了Proxy</h2><p>为什么使用 Proxy 可以解决上面的问题呢？主要是因为Proxy是拦截对象，对对象进行一个”拦截”，外界对该对象的访问，都必须先通过这层拦截。无论访问对象的什么属性，之前定义的还是新增的，它都会走到拦截中</p><h2 id="举个简单的例子"><a href="#举个简单的例子" class="headerlink" title="举个简单的例子"></a>举个简单的例子</h2><p>下面分别用Object.defineProperty()和 Proxy实现一个简单的数据响应<br>使用Object.defineProperty() 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data) &#123;</span><br><span class="line">        <span class="comment">// 遍历参数data的属性,给添加到this上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(data)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> data[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">                data[key] = <span class="keyword">new</span> Observer(data[key]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                enumerable: <span class="literal">true</span>,</span><br><span class="line">                configurable: <span class="literal">true</span>,</span><br><span class="line">                <span class="keyword">get</span>() &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'你访问了'</span> + key);</span><br><span class="line">                    <span class="keyword">return</span> data[key]; <span class="comment">// 中括号法可以用变量作为属性名,而点方法不可以;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'你设置了'</span> + key);</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'新的'</span> + key + <span class="string">'='</span> + newVal);</span><br><span class="line">                    <span class="keyword">if</span>(newVal === data[key]) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    data[key] = newVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decade = &#123;</span><br><span class="line">    name: <span class="string">'decade'</span>,</span><br><span class="line">    age: <span class="string">'18'</span>,</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: <span class="number">1</span>,</span><br><span class="line">        c: <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> decade = <span class="keyword">new</span> Observer(decade);</span><br><span class="line">app.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(decade.age);</span><br><span class="line">decade.newPropKey = <span class="string">'新属性'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(decade.newPropKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 obj原有的属性 age的输出</span></span><br><span class="line">你设置了age</span><br><span class="line">新的age=<span class="number">20</span></span><br><span class="line">你访问了age</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="comment">// 设置新属性的输出</span></span><br><span class="line">新属性</span><br></pre></td></tr></table></figure><div class="note info">            <p>可以看到，给对象新增一个属性，内部并没有监听到，新增的属性需要手动再次使用Object.defineProperty()进行监听。<br>这就是为什么 vue 2.x中 检测不到对象属性的添加和删除的原因，内部提供的$set就是通过调用Object.defineProperty()去处理的。</p>          </div><p>下面我们使用Proxy实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'app'</span>,</span><br><span class="line">    age: <span class="string">'18'</span>,</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: <span class="number">1</span>,</span><br><span class="line">        c: <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'你访问了'</span> + propKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, propKey, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'你设置了'</span> + propKey);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'新的'</span> + propKey + <span class="string">'='</span> + value);</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.age = <span class="string">'20'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.age);</span><br><span class="line">p.newPropKey = <span class="string">'新属性'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.newPropKey);</span><br><span class="line">p.a.d = <span class="string">'这是obj中a的属性'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.a.d);</span><br><span class="line"><span class="comment">// 修改原对象的age属性</span></span><br><span class="line">你设置了age</span><br><span class="line">新的age=<span class="number">20</span></span><br><span class="line">你访问了age</span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新的属性</span></span><br><span class="line">你设置了newPropKey</span><br><span class="line">新的newPropKey=新属性</span><br><span class="line">你访问了newPropKey</span><br><span class="line">新属性</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给obj的a属性(是个对象)设置属性d</span></span><br><span class="line">你访问了a</span><br><span class="line">你访问了a</span><br><span class="line">这是obj中a的属性</span><br><span class="line"><span class="comment">// 备注：如果对象的属性是对象，需要返回一个新的Proxy</span></span><br><span class="line"><span class="comment">// 稍后会补充一下, 大家也可以先自己考虑一下, 欢迎讨论</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Proxy是用来操作对象的，Object.defineProperty() 是用来操作对象的属性的。</li><li>vue2.x使用 Object.defineProperty()实现数据的响应式，但是由于 Object.defineProperty()是对对象属性的操作，所以需要对对象进行深度遍历去对属性进行操作。</li><li>vue3.0 用 Proxy 是对对象进行拦截操作，无论是对对象做什么样的操作都会走到 Proxy 的处理逻辑中</li></ol>]]></content>
    
    <summary type="html">
    
      vue3.0开始啦
    
    </summary>
    
    
      <category term="vue" scheme="http://myblog.loveli.top/categories/vue/"/>
    
    
      <category term="learn" scheme="http://myblog.loveli.top/tags/learn/"/>
    
      <category term="vue" scheme="http://myblog.loveli.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>learn-vue-ts</title>
    <link href="http://myblog.loveli.top/2020/04/17/learn-vue/"/>
    <id>http://myblog.loveli.top/2020/04/17/learn-vue/</id>
    <published>2020-04-17T07:11:00.000Z</published>
    <updated>2020-04-20T02:46:24.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用vue-cli脚手架安装ts版的vue模板"><a href="#使用vue-cli脚手架安装ts版的vue模板" class="headerlink" title="使用vue-cli脚手架安装ts版的vue模板"></a>使用vue-cli脚手架安装ts版的vue模板</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create ts-vue</span><br></pre></td></tr></table></figure><p>等一会 会有下面的界面出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v4.3.1</span><br><span class="line">? Please pick a preset: </span><br><span class="line">  default (babel, eslint) </span><br><span class="line">❯ Manually select features</span><br></pre></td></tr></table></figure><p>随后我们勾选：Router、Vuex、CSS Pre-processors 和 Linter / Formatter，这些都是开发商业级项目必须的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue CLI v4.3.1</span><br><span class="line">? Please pick a preset: Manually select features</span><br><span class="line">? Check the features needed for your project: </span><br><span class="line"> ◉ Babel</span><br><span class="line"> ◉ TypeScript</span><br><span class="line"> ◯ Progressive Web App (PWA) Support</span><br><span class="line"> ◉ Router</span><br><span class="line"> ◉ Vuex</span><br><span class="line"> ◯ CSS Pre-processors</span><br><span class="line">❯◉ Linter &#x2F; Formatter</span><br><span class="line"> ◯ Unit Testing</span><br><span class="line"> ◯ E2E Testing</span><br></pre></td></tr></table></figure><!-- ![选择Manually select features](/img/tsvue/1.png) --><!-- ![必选ts+babel](/img/tsvue/2.png) --><div class="note info">            <p><em>会提示你是否使用Class风格装饰器</em>  Use class-style component syntax? (Y/n) 这里我们先写Y<br><em>会提示使用Babel与TypeScript一起用于自动检测的填充</em> Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)? (Y/n) Y<br><em>是否使用histroy路由模式</em> Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) Y<br><em>选择代码格式化检测 tslint</em>  TSLint (deprecated)  TSLint (deprecated)<br><em>代码检查方式 保存检查</em> Pick additional lint features: Lint on save<br><em>文件配置 我选择单独文件</em> Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys) In dedicated config files<br><em>保存上述配置</em> Save this as a preset for future projects? (y/N) N</p>          </div><p>然后回车, 等待它下包, 项目的解构目录是下面:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── tslint.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   └── index.html</span><br><span class="line">└── src</span><br><span class="line">    ├── App.vue</span><br><span class="line">    ├── assets</span><br><span class="line">    │   └── logo.png</span><br><span class="line">    ├── components</span><br><span class="line">    │   └── HelloWorld.vue</span><br><span class="line">    ├── main.ts</span><br><span class="line">    ├── router</span><br><span class="line">    │   └── index.ts</span><br><span class="line">    ├── store</span><br><span class="line">    │   └── index.ts</span><br><span class="line">    └── views</span><br><span class="line">    │   ├── About.vue</span><br><span class="line">    │   └── Home.vue</span><br><span class="line">    ├── shims-tsx.d.ts</span><br><span class="line">    ├── shims-vue.d.ts</span><br></pre></td></tr></table></figure><p>运行的话执行下面的命令即可</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ts-vue</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>我们需要关注的是一下两个文件<font color="red">shims-tsx.d.ts</font> <font color="red">shims-vue.d.ts</font></p><ul><li><font color="red">shims-tsx.d.ts</font>，允许你以.tsx结尾的文件，在Vue项目中编写jsx代码</li><li><font color="red">shims-vue.d.ts</font> 主要用于 <font color="red">TypeScript</font> 识别<font color="red">.vue </font>文件，Ts默认并不支持导入 vue 文件，这个文件告诉ts 导入<font color="red">.vue </font>文件都按<font color="red">VueConstructor<Vue></Vue></font>处理。</li></ul><p>我们打开<font color="red">src/components/HelloWorld.vue</font>, 写法与我们之前的也大有不同了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;!-- 省略 --&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Prop, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">export default class HelloWorld extends Vue &#123;</span><br><span class="line">  @Prop() private msg!: string;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><div class="note info">            <p>需要看看ts的小伙伴, 可以去瞅瞅我写(c)的ts 笔记!!!</p>          </div><h2 id="vue组件ts写法"><a href="#vue组件ts写法" class="headerlink" title="vue组件ts写法"></a>vue组件ts写法</h2><ol><li>Vue.extend<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">const Component &#x3D; Vue.extend(&#123;</span><br><span class="line">&#x2F;&#x2F; type inference enabled</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>vue-class-component<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Vue, Prop &#125; from &#39;vue-property-decorator&#39;</span><br><span class="line">@Component</span><br><span class="line">export default class Test extends Vue &#123;</span><br><span class="line">  @Prop(&#123; type: Object &#125;)</span><br><span class="line">  private test: &#123; value: string &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>其中@ 这个叫装饰器, 这里的@Component 申明只是一个组件, @Prop这是一个prop<br>这个private 声明这是一个私有的变量</p>          </div></li></ol><h2 id="介绍一下-装饰器"><a href="#介绍一下-装饰器" class="headerlink" title="介绍一下@ 装饰器"></a>介绍一下@ 装饰器</h2><ul><li><font color="red">@</font>，与其说是修饰函数倒不如说是引用、调用它修饰的函数。</li><li>或者说是描述：@: “下面的被我包围了。”<br>举个栗子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(f)&#123;</span><br><span class="line">    console.log(&quot;before ...&quot;);</span><br><span class="line">    f()</span><br><span class="line">console.log(&quot;after ...&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@test</span><br><span class="line">func()&#123;</span><br><span class="line">console.log(&quot;func was called&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>执行结果为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before ...</span><br><span class="line">func was called</span><br><span class="line">after ...</span><br></pre></td></tr></table></figure></li></ul><div class="note info">            <ul><li>只定义了两个函数：test和func，没有调用它们。</li><li>如果没有<font color="red">@test</font>，运行应该是没有任何输出的。</li></ul>          </div><ol><li>vue-property-decorator的装饰器：<ul><li>@Prop</li><li>@PropSync</li><li>@Provide</li><li>@Model</li><li>@Watch</li><li>@Inject</li><li>@Provide</li><li>@Emit</li><li>@Component (provided by vue-class-component)</li><li>Mixins (the helper function named mixins provided by vue-class-component)</li></ul></li><li>vuex-class的装饰器：<ul><li>@State</li><li>@Getter</li><li>@Action</li><li>@Mutation</li></ul></li></ol><ol><li>拿原始Vue组件模版来看:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import &#123;componentA,componentB&#125; from &#39;@&#x2F;components&#39;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">components: &#123; componentA, componentB&#125;,</span><br><span class="line">props: &#123;</span><br><span class="line">    propA: &#123; type: Number &#125;,</span><br><span class="line">    propB: &#123; default: &#39;default value&#39; &#125;,</span><br><span class="line">    propC: &#123; type: [String, Boolean] &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 组件数据</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Hello&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 计算属性</span><br><span class="line">  computed: &#123;</span><br><span class="line">    reversedMessage () &#123;</span><br><span class="line">      return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Vuex数据</span><br><span class="line">    step() &#123;</span><br><span class="line">    return this.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeMessage () &#123;</span><br><span class="line">      this.message &#x3D; &quot;Good bye&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    getName() &#123;</span><br><span class="line">    let name &#x3D; this.$store.getters[&#39;person&#x2F;name&#39;]</span><br><span class="line">    return name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 生命周期</span><br><span class="line">  created () &#123; &#125;,</span><br><span class="line">  mounted () &#123; &#125;,</span><br><span class="line">  updated () &#123; &#125;,</span><br><span class="line">  destroyed () &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>以上模版替换成修饰符写法则是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Vue, Prop &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">import &#123; State, Getter &#125; from &#39;vuex-class&#39;;</span><br><span class="line">import &#123; count, name &#125; from &#39;@&#x2F;person&#39;</span><br><span class="line">import &#123; componentA, componentB &#125; from &#39;@&#x2F;components&#39;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  components:&#123; componentA, componentB&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">export default class HelloWorld extends Vue&#123;</span><br><span class="line">@Prop(Number) readonly propA!: number | undefined</span><br><span class="line">  @Prop(&#123; default: &#39;default value&#39; &#125;) readonly propB!: string</span><br><span class="line">  @Prop([String, Boolean]) readonly propC!: string | boolean | undefined</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 原data</span><br><span class="line">  message:string &#x3D; &#39;Hello&#39;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 计算属性</span><br><span class="line">private get reversedMessage (): string[] &#123;</span><br><span class="line">  return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Vuex 数据</span><br><span class="line">  @State((state: IRootState) &#x3D;&gt; state . booking. currentStep) step!: number</span><br><span class="line">@Getter( &#39;person&#x2F;name&#39;) name!: name</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; method</span><br><span class="line">  public changeMessage (): void &#123;</span><br><span class="line">    this.message &#x3D; &#39;Good bye&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  public getName(): string &#123;</span><br><span class="line">    let storeName &#x3D; name</span><br><span class="line">    return storeName</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; 生命周期</span><br><span class="line">  private created ()：void &#123; &#125;,</span><br><span class="line">  private mounted ()：void &#123; &#125;,</span><br><span class="line">  private updated ()：void &#123; &#125;,</span><br><span class="line">  private destroyed ()：void &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="注册全局工具"><a href="#注册全局工具" class="headerlink" title="注册全局工具"></a>注册全局工具</h2><p>之前是main.js 现在就在main.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i moduleName</span><br></pre></td></tr></table></figure><p>打开main.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;;</span><br><span class="line">&#x2F;&#x2F; 新模块</span><br><span class="line">import moduleName from &#39;.&#x2F;moduleName&#39;;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    router, </span><br><span class="line">    store, </span><br><span class="line">    moduleName, &#x2F;&#x2F; 新模块</span><br><span class="line">    render: (h) &#x3D;&gt; h(App),</span><br><span class="line">&#125;).$mount(&#39;#app&#39;);</span><br></pre></td></tr></table></figure><p>另外还需要你在<font color="red">vue-shim.d.ts</font>这个文件中声明<br>// 声明全局方法<br>declare module ‘vue/types/vue’ {<br>  interface Vue {<br>        readonly $moduleName: moduleName;<br>        $t: TranslationFunction;<br>    }<br>}</p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios vue-axios</span><br></pre></td></tr></table></figure><p>main.ts中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">import VueAxios from &#39;vue-axios&#39;</span><br><span class="line">Vue.use(VueAxios, axios)</span><br></pre></td></tr></table></figure><p>组件中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.axios.get(api).then((response) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.axios.get(api).then((response) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.$http.get(api).then((response) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-api</span><br><span class="line">  - main.ts   &#x2F;&#x2F; 实际调用</span><br><span class="line">-utils</span><br><span class="line">  - service.ts  &#x2F;&#x2F; 接口封装</span><br></pre></td></tr></table></figure><p>封装的service.ts</p><h2 id="axios-1"><a href="#axios-1" class="headerlink" title="axios"></a>axios</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i axios vue-axios</span><br></pre></td></tr></table></figure><p>main.ts 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">import VueAxios from &#39;vue-axios&#39;</span><br><span class="line">Vue.use(VueAxios, axios)</span><br></pre></td></tr></table></figure><p>组件中使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.axios.get(api).then((response) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.axios.get(api).then((response) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.$http.get(api).then((response) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(response.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="封装-axios"><a href="#封装-axios" class="headerlink" title="封装 axios"></a>封装 axios</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-api</span><br><span class="line">  - main.ts   &#x2F;&#x2F; 实际调用</span><br><span class="line">-utils</span><br><span class="line">  - request.ts  &#x2F;&#x2F; 接口封装</span><br></pre></td></tr></table></figure><p>封装的 request.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import * as axios from &#39;axios&#39;;</span><br><span class="line">import store from &#39;@&#x2F;store&#39;;</span><br><span class="line">import Qs from &quot;qs&quot;;</span><br><span class="line">&#x2F;&#x2F; 这里可根据具体使用的UI组件库进行替换</span><br><span class="line">import axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosResponse &#125; from &quot;axios&quot;;</span><br><span class="line">import &#123; Message &#125; from &quot;element-ui&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建 axios 实例</span><br><span class="line">let service: AxiosInstance | any;</span><br><span class="line">if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &quot;development&quot;) &#123;</span><br><span class="line">  service &#x3D; axios.create(&#123;</span><br><span class="line">    baseURL: &quot;&#x2F;api&quot;, &#x2F;&#x2F; api 的 base_url</span><br><span class="line">    timeout: 50000 &#x2F;&#x2F; 请求超时时间</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 生产环境下</span><br><span class="line">  service &#x3D; axios.create(&#123;</span><br><span class="line">    baseURL: &quot;&#x2F;api&quot;,</span><br><span class="line">    timeout: 50000</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; request 拦截器 axios 的一些配置</span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">  (config: AxiosRequestConfig) &#x3D;&gt; &#123;</span><br><span class="line">    return config;</span><br><span class="line">  &#125;,</span><br><span class="line">  (error: any) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; Do something with request error</span><br><span class="line">    console.error(&quot;error:&quot;, error); &#x2F;&#x2F; for debug</span><br><span class="line">    Promise.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; respone 拦截器 axios 的一些配置</span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">  (res: AxiosResponse) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; Some example codes here:</span><br><span class="line">    &#x2F;&#x2F; code &#x3D;&#x3D; 0: success</span><br><span class="line">    if (res.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">      const data: ResponseData &#x3D; res.data</span><br><span class="line">      if (data.code &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return data.data;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        Message(&#123;</span><br><span class="line">          message: data.message,</span><br><span class="line">          type: &quot;error&quot;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Message(&#123;</span><br><span class="line">        message: &quot;网络错误!&quot;,</span><br><span class="line">        type: &quot;error&quot;</span><br><span class="line">      &#125;);</span><br><span class="line">      return Promise.reject(new Error(res.data.message || &quot;Error&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  (error: any) &#x3D;&gt; Promise.reject(error)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; get，post请求方法</span><br><span class="line">export default &#123;</span><br><span class="line">  post(url: string, data: any) &#123;</span><br><span class="line">    return service(&#123;</span><br><span class="line">      method: &quot;post&quot;,</span><br><span class="line">      url,</span><br><span class="line">      data: Qs.stringify(data),</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  get(url: string, params: any) &#123;</span><br><span class="line">    return service(&#123;</span><br><span class="line">      method: &quot;get&quot;,</span><br><span class="line">      url,</span><br><span class="line">      params</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info">            <p>类型什么的, 可以自己创建一个文件, 专门放自己根据后台返回数据弄得类型<br>例如: ajax.interface.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export interface IAjaxResponse &#123;</span><br><span class="line">    code: number;</span><br><span class="line">    data: any;</span><br><span class="line">    message: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>好嘞, 到此over          </div>]]></content>
    
    <summary type="html">
    
      typescript挺香的, 然后我决定在vue中试试看
    
    </summary>
    
    
      <category term="vue" scheme="http://myblog.loveli.top/categories/vue/"/>
    
    
      <category term="learn" scheme="http://myblog.loveli.top/tags/learn/"/>
    
      <category term="vue" scheme="http://myblog.loveli.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>learn-ts 基础(四)</title>
    <link href="http://myblog.loveli.top/2020/04/17/learn-ts4/"/>
    <id>http://myblog.loveli.top/2020/04/17/learn-ts4/</id>
    <published>2020-04-17T07:09:36.000Z</published>
    <updated>2020-04-20T08:56:24.396Z</updated>
    
    <content type="html"><![CDATA[<p>待开工<br>[=&gt;                           ]</p>]]></content>
    
    <summary type="html">
    
      这是第四部分, 待....
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/categories/TypeScript/"/>
    
    
      <category term="learn" scheme="http://myblog.loveli.top/tags/learn/"/>
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>learn-ts 基础篇(三)</title>
    <link href="http://myblog.loveli.top/2020/04/16/learn-ts3/"/>
    <id>http://myblog.loveli.top/2020/04/16/learn-ts3/</id>
    <published>2020-04-16T08:20:20.000Z</published>
    <updated>2020-04-17T02:56:16.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="联合类型-union-type"><a href="#联合类型-union-type" class="headerlink" title="联合类型(union type)"></a>联合类型(union type)</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">"seven"</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>联合类型使用 <strong>|</strong> 来分割多种类型 上述的例子就是允许myFavoriteNumber既可以是字符串类型也可以是数值类型</p>          </div><h3 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="headerlink" title="访问联合类型的属性或方法"></a>访问联合类型的属性或方法</h3><p>当typescript不确定一个联合类型变量具体是指哪个类型的时候, 我们只能访问联合类型中共有的属性或方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">some: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> some.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.</span></span><br><span class="line"><span class="comment">//  Property 'length' does not exist on type 'number'.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeString</span>(<span class="params">some: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> some.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// string 和 number 用共有的方法toString, 所以不报错</span></span><br></pre></td></tr></table></figure><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 (interface)"></a>接口 (interface)</h2><p>它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p><ol><li>下面的例子主要是为了说明jock 被约束成了Person这个接口一样的形状, 换句话就是Person里面有的属性, jock里面也必须有, 而且是不许多, 也不许少<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sex: <span class="built_in">string</span></span><br><span class="line">  hasJob: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jock: IPerson = &#123;</span><br><span class="line">  name: <span class="string">'jock'</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  sex: <span class="string">'male'</span>,</span><br><span class="line">  hasJob: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果jock中少了 age,name,sex, hasJob这几个属性都是会报错的</span></span><br><span class="line"><span class="keyword">let</span> alice: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"alice"</span>,</span><br><span class="line">  age: <span class="number">16</span>,</span><br><span class="line">  sex: <span class="string">"female"</span>,</span><br><span class="line">  hasJob: <span class="literal">false</span>,</span><br><span class="line">  like: <span class="string">"code"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// alice中多了 Person中没有的属性like 会报错</span></span><br></pre></td></tr></table></figure></li><li>当我们需要接口中某些属性可选, 即不完全是接口的形状的时候, 可以在需要的属性前面加个 <strong>?</strong> 表示<font color="red">可选属性</font>, 当然不存在接口中的属性, 也是会报错<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sex: <span class="built_in">string</span></span><br><span class="line">  hasJob?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tom: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  sex: <span class="string">"male"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里不用hasJob这个属性, 当然别的非可选属性少了, 也是会报错的</span></span><br><span class="line"><span class="keyword">let</span> jack: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"jack"</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  sex: <span class="string">"male"</span>,</span><br><span class="line">  like: <span class="string">"code"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// like 不存在于Person 会报错</span></span><br></pre></td></tr></table></figure></li><li>有时候, 我们需要的是一个接口有任意属性<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>  <span class="comment">// 键名必须是字符串, 值可以是任何类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tom: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  sex: <span class="string">"male"</span>, <span class="comment">// 满足键名是字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</p>          </div><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tom: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  sex: <span class="string">"male"</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.</span></span><br><span class="line"> <span class="comment">// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'IPerson'.</span></span><br><span class="line"> <span class="comment">// Index signatures are incompatible.</span></span><br><span class="line"> <span class="comment">// Type 'string | number' is not assignable to type 'string'.</span></span><br><span class="line"> <span class="comment">// Type 'number' is not assignable to type 'string'.</span></span><br><span class="line"> <span class="comment">// 任意值允许的属性值为string 而age的值为number, number不是string的子集</span></span><br></pre></td></tr></table></figure></li><li>一个接口中只能定义一个任意属性, 怎么要让这个任意属性有多重类型呢? 用前面的联合类型即可<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age?: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tom: IPerson = &#123;</span><br><span class="line">  name: <span class="string">"tom"</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  sex: <span class="string">"male"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>我们可能需要有一些属性只能够在赋值的时候赋值, 也就是后面操作不能修改这个属性的值, 称之为只读属性<font size="5">readonly</font><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  readonly id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125; <span class="comment">// 一个人的身份证号是唯一的</span></span><br><span class="line"><span class="keyword">let</span> tom: IPerson = &#123;</span><br><span class="line">  id: <span class="number">89757</span>,</span><br><span class="line">  name: <span class="string">'Tom'</span>,</span><br><span class="line">  gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line">tom.id = <span class="number">111111</span>; <span class="comment">// 会报错</span></span><br><span class="line"><span class="comment">// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>需要注意的是，只读属性的赋值 只是在第一次给对象赋值的时候</p>          </div></li></ol><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><ol><li>最简单就是 <strong>类型+[]</strong> 来表示<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberArr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 数组中全是number类型 不会报错</span></span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'4'</span>, <span class="number">5</span>]; <span class="comment">// 报错 出现不是number类型的成员</span></span><br><span class="line"><span class="comment">// 因为你这个数组的类型被限制了, 相应的数组的方法也会被限制</span></span><br><span class="line">numberArr.push(<span class="string">"1"</span>); <span class="comment">// 报错 你只能push进number类型的</span></span><br></pre></td></tr></table></figure></li><li>数组泛型<br>泛型这个概念, 第一次接触是在java<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;T&gt;; <span class="comment">// 这里的这个T就是没有指明的数组类型 泛型</span></span><br></pre></td></tr></table></figure></li><li>用接口表示数组, 还记得那个自定义属性嘛, 就是这么来表示的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPesron &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">number</span>; <span class="comment">// 如果把属性值类型这个number改成&lt;T&gt; 就是泛型了, 也就可以不只是number, 还可以是boolean, string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr: IPerson = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure></li><li>类数组<br>都知道arguments就是一个类数组<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IArguments &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;</span><br><span class="line">  callee: <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args: IArguments = <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>当你想一个数组中什么类型都能放, 我们可以想到any<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="literal">true</span>, &#123;a: <span class="number">1</span>&#125;];</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">泛型的使用一般是在函数, 接口, 类中使用的多</span><br><span class="line">接口表示数组, 也不推荐, 用来表示类数组的</span><br><span class="line">还是推荐使用第一种</span><br><span class="line">还是那句话, 少用<span class="built_in">any</span>!!!</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">## 函数类型</span><br><span class="line">定义函数的方式, 常见有两种一种是函数表达式, 一种是函数申明</span><br><span class="line">   <span class="string">``</span><span class="string">`typescript</span></span><br><span class="line"><span class="string">   function add(a: number, b: number): number &#123;</span></span><br><span class="line"><span class="string">     return a + b;</span></span><br><span class="line"><span class="string">   &#125; // 函数申明</span></span><br><span class="line"><span class="string">   let addNumber: (a: number, b: number) =&gt; number = function(a: number, b: number): number &#123;</span></span><br><span class="line"><span class="string">     return a + b;</span></span><br><span class="line"><span class="string">   &#125; // 函数表达式</span></span><br></pre></td></tr></table></figure>当你多加参数或者少参数或者参数类型不对时, 都会报错<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 多参数</span></span><br><span class="line">add(<span class="number">1</span>);</span><br><span class="line">add(<span class="number">1</span>, <span class="string">"1"</span>); <span class="comment">// 类型不对</span></span><br></pre></td></tr></table></figure>用接口定义函数的形状<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IAddFunction &#123;</span><br><span class="line">  (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add: IAddFunction = <span class="function"><span class="keyword">function</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>函数的可选参数, 与接口里面的可选属性一样用的是 <strong>?</strong><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + lastName;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">"tom"</span>, <span class="string">"cat"</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">"tom"</span>);</span><br></pre></td></tr></table></figure><div class="note info">            <p>可选参数一定要放在必需参数后面, 放最后面就对了</p>          </div>ES6中有默认参数, 在ts中会把默认参数识别为可选参数<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">str1: <span class="built_in">string</span>, str2: <span class="built_in">string</span> = "world"</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str1 + str2</span><br><span class="line">&#125;</span><br><span class="line">say(<span class="string">"hello"</span>);</span><br><span class="line">say(<span class="string">"hello"</span>, <span class="string">"typescript"</span>);</span><br></pre></td></tr></table></figure>剩余参数 使用的 <font color="yellow">…</font>来操作的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>&lt;<span class="title">T</span>&gt;(<span class="params">array: <span class="built_in">Array</span>&lt;T&gt;, ...items: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item: T</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span>[] = [];</span><br><span class="line">push(str, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br></pre></td></tr></table></figure>重载 第一次接触这玩意 是在学c# 方法名一样, 参数类型, 数量不同<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>又成功水了一篇!!!!</p>          </div></li></ol>]]></content>
    
    <summary type="html">
    
      这是第三部分, 复习typescipt中的联合类型, 接口, 数组类型, 函数类型
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/categories/TypeScript/"/>
    
    
      <category term="learn" scheme="http://myblog.loveli.top/tags/learn/"/>
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>learn-ts 基础篇(二)</title>
    <link href="http://myblog.loveli.top/2020/04/16/learn-ts2/"/>
    <id>http://myblog.loveli.top/2020/04/16/learn-ts2/</id>
    <published>2020-04-16T03:40:24.000Z</published>
    <updated>2020-04-16T08:25:54.222Z</updated>
    
    <content type="html"><![CDATA[<div class="note info">            <p><font size="4"><strong>复习一下</strong></font><br>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。<br>typescript中 主要讲boolean, number, string, null, undefined, 以及ts中的新的(后面会提及)</p>          </div><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><ol><li>布尔值是最基础的数据类型, 在TypeScript中, 使用的boolean来定义的 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isActive: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li><li>值得注意的是, 使用Boolean构造函数创建的对象<font color="red">不是</font>布尔值, 它是一个实例, 是对象 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isActive: <span class="built_in">boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// Type 'Boolean' is not assignable to type 'boolean'.</span></span><br><span class="line"><span class="comment">// 'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.</span></span><br></pre></td></tr></table></figure></li><li>直接调用Boolean(1), 返回的也是一个布尔值 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isActive: <span class="built_in">boolean</span> = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><div class="note info">            <p>当然我更推荐是用第一种, 直接赋予true/false</p>          </div><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>使用的number来定义数值类型, 下面有几个文档上的例子</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>; <span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>; <span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> notANumber: <span class="built_in">number</span> = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> infinityNumber: <span class="built_in">number</span> = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure><p> 终端打开编译<br> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc xx.ts</span><br></pre></td></tr></table></figure><br> 编译结果<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decLiteral = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> hexLiteral = <span class="number">0xf00d</span>; <span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">var</span> binaryLiteral = <span class="number">10</span>; <span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">var</span> octalLiteral = <span class="number">484</span>;</span><br><span class="line"><span class="keyword">var</span> notANumber = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> infinityNumber = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>使用的是string, 当然也支持ES6中的字符串模板</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">"decade"</span>,</span><br><span class="line">    age: <span class="built_in">number</span> = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`hello my name is <span class="subst">$&#123;name&#125;</span>, i am <span class="subst">$&#123;age&#125;</span> years old`</span></span><br></pre></td></tr></table></figure><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>javascript中没有空值这个概念(我最早接触是学c的时候 void main()), 在typescript中, void用来表示没有任何返回值得函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alertName</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  alert(<span class="string">`name is <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明一个变量为空值类型 是没有用的 你只能给它赋值为undefined或者null</span></span><br><span class="line"><span class="keyword">let</span> voidVal: <span class="built_in">void</span> = <span class="literal">null</span>; <span class="comment">// let voidVal: void = undefined</span></span><br></pre></td></tr></table></figure><h2 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h2><p>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><div class="note info">            <p>值得一提的是undefined/null两个都是其他类型的子类型, 所以可以给一个number类型的值赋值一个undefined/null</p>          </div><h2 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h2><p>使用的是any, 记得之前不是提过嘛能把js直接改为ts 就靠的是这个any, 下面来详细说明</p><ol><li>一个普通类型在被赋值的时候, 是不允许被赋值为别的类型的(undefined, null除外)<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">"abc"</span></span><br><span class="line">str = <span class="number">123</span>; <span class="comment">// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'</span></span><br></pre></td></tr></table></figure></li><li>但是如果是any类的话是可以的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">any</span> = <span class="string">"abc"</span></span><br><span class="line">str = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></li><li>在任意值上访问任何属性都是允许的, 同理访问任何方法也是被允许的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意属性</span></span><br><span class="line"><span class="keyword">let</span> anyThing: <span class="built_in">any</span> = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName);</span><br><span class="line"><span class="built_in">console</span>.log(anyThing.myName.firstName);</span><br><span class="line"><span class="comment">// 任意方法</span></span><br><span class="line"><span class="keyword">let</span> anyThing: <span class="built_in">any</span> = <span class="string">'Tom'</span>;</span><br><span class="line">anyThing.setName(<span class="string">'Jerry'</span>);</span><br><span class="line">anyThing.setName(<span class="string">'Jerry'</span>).sayHello();</span><br><span class="line">anyThing.myName.setFirstName(<span class="string">'Cat'</span>);</span><br></pre></td></tr></table></figure></li><li>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> something; <span class="comment">// let something: any</span></span><br><span class="line">something = <span class="string">'seven'</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></li></ol><p>something.setName(‘Tom’);</p><div class="note info">            <p>值得一提的是, any类型要慎用, 如果你常用any 写的不就个js没区别了嘛 any是会让ts的忽略严格的类型检查</p>          </div>]]></content>
    
    <summary type="html">
    
      这是第二部分, 复习typescipt中的数据类型
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/categories/TypeScript/"/>
    
    
      <category term="learn" scheme="http://myblog.loveli.top/tags/learn/"/>
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>learn-ts 基础篇(一)</title>
    <link href="http://myblog.loveli.top/2020/04/16/learn-ts/"/>
    <id>http://myblog.loveli.top/2020/04/16/learn-ts/</id>
    <published>2020-04-16T02:41:29.000Z</published>
    <updated>2020-04-16T08:25:48.224Z</updated>
    
    <content type="html"><![CDATA[<p>现在开始从基础的重新来一遍吧(我主要都是看文档,自己动手敲例子,完了之后结合的angular8写的实战),下面是我看的<a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">文档</a>,接下来我们正式开始吧</p><h2 id="什么是TypeScript"><a href="#什么是TypeScript" class="headerlink" title="什么是TypeScript"></a>什么是TypeScript</h2><blockquote><p>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。<br>这是我找的官网的一句话, 我自己的理解主要是在type上, 总所周知, js是弱类型语言, 弱类型语言和强类型语言我认为的区别 是否存在隐式类型转换, 写过js的都知道</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"abc"</span> <span class="comment">// 这是定义一个变量str </span></span><br><span class="line"><span class="keyword">typeof</span> str <span class="comment">// 打印的"string" 这里只是为了举个例子 别打我</span></span><br><span class="line">str = <span class="number">123</span></span><br><span class="line"><span class="keyword">typeof</span> str <span class="comment">// "number</span></span><br></pre></td></tr></table></figure><p>就是因为js可以这样的隐式转换, 所以有时候会出现很多明明写的没有问题, 但是就是找不到错误的报错, 举个栗子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeStrLength</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125; <span class="comment">// 这是一个做减法的函数</span></span><br><span class="line">computeStrLength(<span class="string">"abcdecahfka"</span>) <span class="comment">// 这样是没问题的</span></span><br><span class="line">computeStrLength(<span class="number">123445</span>) <span class="comment">// 打印undefined</span></span><br></pre></td></tr></table></figure><p>感觉写的例子不够深….QAQ</p><h3 id="TypeScript有以下几个好处"><a href="#TypeScript有以下几个好处" class="headerlink" title="TypeScript有以下几个好处"></a>TypeScript有以下几个好处</h3><ol><li>TypeScript 增加了代码的可读性和可维护性<ul><li>知道这个函数需要什么类型的参数一眼就知道怎么用</li><li>编译的时候类型出错 会报错</li><li>增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</li></ul></li><li>TypeScript 非常包容<ul><li>可以直接将js文件命名为ts文件</li><li>有自己的类型推断</li><li>可以定义自己需要的类型</li><li>编译报错也能生成js文件</li></ul></li><li>TypeScript 用户多,社区活跃<ul><li>大部分第三方库都有提供给 TypeScript 的类型定义文件</li></ul></li></ol><h2 id="安装TypeScript"><a href="#安装TypeScript" class="headerlink" title="安装TypeScript"></a>安装TypeScript</h2><p>安装TypeScript</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc xxx.ts</span><br></pre></td></tr></table></figure><p>我用的编辑器是vscode 推荐的插件 </p><ol><li>markdown-all-in-one </li><li>Markdown Preview Enhanced</li></ol><h2 id="Hello-TypeScript"><a href="#Hello-TypeScript" class="headerlink" title="Hello TypeScript"></a>Hello TypeScript</h2><p>新建文件夹取名 ts-learn, 用vscode打开该文件, 打开终端输入</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>文件夹里面会多出一个tsconfig.json文件 这里面都有基本的配置 我不一一说了详细看这个<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">文档</a><br>然后自己再新建一个hello.ts文件, 在里面输入一下内容</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countStrLength</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span>;</span><br><span class="line">strLength = countStriLength(str);</span><br><span class="line"><span class="built_in">console</span>.log(strLength);</span><br></pre></td></tr></table></figure><p>打开终端, 执行以下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure><p>你会发现文件中多了一个hello.js文件</p><p>先把基础的写好了, emmmmm, 又水完一篇</p>]]></content>
    
    <summary type="html">
    
      许久之前把typescript过完,今天又慢慢再来复习第三遍(第二遍敲代码的时候过了一次了)
    
    </summary>
    
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/categories/TypeScript/"/>
    
    
      <category term="learn" scheme="http://myblog.loveli.top/tags/learn/"/>
    
      <category term="TypeScript" scheme="http://myblog.loveli.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello myBlog</title>
    <link href="http://myblog.loveli.top/2020/04/13/Hello-myBlog/"/>
    <id>http://myblog.loveli.top/2020/04/13/Hello-myBlog/</id>
    <published>2020-04-13T07:55:49.000Z</published>
    <updated>2020-04-15T03:52:17.728Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于是我的第一篇博客,我把我怎么搭建的复习复习吧! 前期的准备<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">node</a>,<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>,下载好了之后,我顺便把怎么配置node环境(water)写一下吧.</p><h2 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h2><div class="note info">            <p>安装node,傻瓜式安装一直按next即可,中间有个选择盘符,不推荐放在c盘</p>          </div><h2 id="检查node是否安装成功"><a href="#检查node是否安装成功" class="headerlink" title="检查node是否安装成功"></a>检查node是否安装成功</h2><p>先进入cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="/img/hellomyblog/nodev.png"  alt="如果如图有版本提示说明安装成功"></p><div class="note info">            <p>安装完成后目录如下, 另外需要自己手动创建两个文件夹,一个叫node_cache(存放缓存的),node_global(全局安装插件的放这个文件夹)</p>          </div><p><img src="/" class="lazyload" data-src="/img/hellomyblog/nodecomplete.png"  alt="安装完成图片"></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><div class="note info">            <p>说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\Users\用户名\AppData\Roaming\npm】路径中，占C盘空间。</p>          </div><p>创建完两个文件夹后,打开cmd,执行下面的命令,因为我是安装在H盘下的nodejs目录下的,所以你需要自己修改一下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix "H:\nodejs\node_global"</span><br><span class="line">npm config <span class="built_in">set</span> cache "H:\nodejs\node_cache"</span><br></pre></td></tr></table></figure><div class="note info">            <p>由于npm安装插件是从国外下载的,受网络影响大,建议更换成国内淘宝镜像,指令如下</p>          </div><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config <span class="built_in">set</span> disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure><p>上述工作完成后,我们开始配置环境<br>右键单击我的电脑,找到属性,然后找到高级系统设置,找到环境变量<br><img src="/" class="lazyload" data-src="/img/hellomyblog/1.png"  alt="属性,高级系统设置"><br><img src="/" class="lazyload" data-src="/img/hellomyblog/environment.png"  alt="环境变量"></p><p>node_path环境变量:<br>进入环境变量对话框，在系统变量下新建NODE_PATH，输入H:\nodejs\node_global\node_modules，将用户变量下的Path修改为H:\nodejs\node_global<br><img src="/" class="lazyload" data-src="/img/hellomyblog/2.png"  alt="path1"><br><img src="/" class="lazyload" data-src="/img/hellomyblog/3.png"  alt="path2"></p><p><img src="/" class="lazyload" data-src="/img/hellomyblog/4.png"  alt="NODE_PATH"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开cmd 全局安装一个express</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure><p>安装完之后 去你的node_global目录下的node_module找express<br><img src="/" class="lazyload" data-src="/img/hellomyblog/5.png"  alt="express"></p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>一样的傻瓜式安装,看是否安装成功只需要在桌面单击右键,看是否有Git Bush Here, Git GUI Here 就行了<br><img src="/" class="lazyload" data-src="/img/hellomyblog/6.png"  alt="git安装"></p><div class="note default">            <p>因为hexo 推送到github仓库不需要是用git 推送送的 以后再补上吧!!!</p>          </div><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>打开git bush / cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>检查版本</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>第一步初始化hexo</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init yourBlogName</span><br></pre></td></tr></table></figure><p>进入到你yourBlogNameogName这个文件夹,然后执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> yourBlogName</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>然后一个基本的博客模板就完成了,分析一下文件目录</p><div class="note default">            <p>由于我也是入门小白, 基本的可以去<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a>查看<br>总的用到的以下的几条指令</p>          </div><ol><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li><li>hexo clean 清除之前生成的json文件, public目录下的东西</li><li>hexo g 生成json文件 以及public 目录下的东西</li><li>hexo server 开启服务 访问4000端口即可</li><li>hexo d 这个是你绑定了github仓库 后推代码到仓库的 你需要安装插件</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这是我的第一篇博客,并且我取了个中二的名字
    
    </summary>
    
    
    
      <category term="learn" scheme="http://myblog.loveli.top/tags/learn/"/>
    
      <category term="hexo" scheme="http://myblog.loveli.top/tags/hexo/"/>
    
  </entry>
  
</feed>
