<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王小明</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://myblog.decade.run/"/>
  <updated>2020-05-20T08:55:11.741Z</updated>
  <id>http://myblog.decade.run/</id>
  
  <author>
    <name>Decade W</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记</title>
    <link href="http://myblog.decade.run/2020/05/20/note1/"/>
    <id>http://myblog.decade.run/2020/05/20/note1/</id>
    <published>2020-05-20T08:48:03.000Z</published>
    <updated>2020-05-20T08:55:11.741Z</updated>
    
    <content type="html"><![CDATA[<p>先上自己成功的步骤!!!</p><ol><li>安装好下面两个插件<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i lib-flexible -S</span><br><span class="line">npm i postcss-plugin-px2rem  -S</span><br></pre></td></tr></table></figure></li><li>打开vue.config.js<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">css: &#123;</span><br><span class="line">  loaderOptions: &#123;</span><br><span class="line">    postcss: &#123;</span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'postcss-plugin-px2rem'</span>)(&#123;</span><br><span class="line">          rootValue: <span class="number">192</span>,</span><br><span class="line">          exclude: <span class="regexp">/(node_module)/i</span></span><br><span class="line">        &#125;)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>修改lib-flexible下的flexible.js文件 72行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshRem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> width = docEl.getBoundingClientRect().width;</span><br><span class="line">  <span class="keyword">if</span> (width / dpr &gt; <span class="number">540</span>) &#123;</span><br><span class="line">      width = width * dpr; <span class="comment">// 原来是width = 540 * dpr</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> rem = width / <span class="number">10</span>;</span><br><span class="line">  docEl.style.fontSize = rem + <span class="string">'px'</span>;</span><br><span class="line">  flexible.rem = win.rem = rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>over</li></ol>]]></content>
    
    <summary type="html">
    
      要求根据分辨率进行自适应
    
    </summary>
    
    
    
      <category term="learn" scheme="http://myblog.decade.run/tags/learn/"/>
    
      <category term="笔记" scheme="http://myblog.decade.run/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>javascript执行上下文与执行栈</title>
    <link href="http://myblog.decade.run/2020/05/19/ds2/"/>
    <id>http://myblog.decade.run/2020/05/19/ds2/</id>
    <published>2020-05-18T22:34:48.000Z</published>
    <updated>2020-05-20T03:25:46.418Z</updated>
    
    <content type="html"><![CDATA[<p>前几天逛掘金的时候突然看见一篇文章<a href="https://juejin.im/post/5ebced85e51d454dc1467664#heading-13" target="_blank" rel="noopener">面试官：说说执行上下文吧</a>, 执行上下文, 有点懵逼, 然后就开始搬砖!!</p><h3 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h3><p>当 JS 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 “准备工作”，就叫做 “执行上下文(execution context 简称 EC)” 或者也可以叫做执行环境。<br>下面准备一串代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a= <span class="number">1</span>; </span><br><span class="line">foo(<span class="number">1</span>) </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">5</span>) &#123; <span class="keyword">return</span> &#125; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'before'</span>,a) </span><br><span class="line">  foo(a + <span class="number">1</span>) </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">'after'</span>,a) </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>, a)</span><br></pre></td></tr></table></figure><p>看见这串代码, 我们会分析this指向(这里没有没有提及this), 这里打印的a的值是多少, 这里打印出来的顺序是什么. 然后大概这个执行前的准备工作也就是做这些吧</p><p>js中的执行上下文一共有三种</p><ol><li>全局执行的上下文 一个程序只会存在一个全局执行上下文</li><li>函数的执行上下文 函数被调用的时候, 就会创建一个函数执行上下文</li><li>Eval函数的执行上下文</li></ol><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>执行栈，在其他编程语言中也被叫做调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。<br>当 JavaScript 引擎首次读取你的脚本时，它会创建一个全局执行上下文并将其推入当前的执行栈。每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端。<br>引擎会运行执行上下文在执行栈顶端的函数，当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出，上下文控制权将移到当前执行栈的下一个执行上下文</p><p>这种进栈弹栈的操作 有点像之前学进程的时候, 我画了这么一个图<br><img src="/" class="lazyload" data-src="/img/dsalg/3.png"  alt="进程运行"><br>而之前的那段代码 执行的操作其实是和这个图的操作 相差无疑的, 我也只是省略了入栈的操作</p><h3 id="执行上下文是如何被创建的"><a href="#执行上下文是如何被创建的" class="headerlink" title="执行上下文是如何被创建的"></a>执行上下文是如何被创建的</h3><p>执行上下文分两个阶段创建：</p><ol><li>创建阶段</li><li>执行阶段</li></ol><h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><ol><li>确定 this 的值，也被称为 This Binding。</li><li>LexicalEnvironment（词法环境） 组件被创建。</li><li>VariableEnvironment（变量环境） 组件被创建.</li></ol><p>伪代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;  </span><br><span class="line">  ThisBinding = <span class="xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>,  </span></span><br><span class="line"><span class="xml">  LexicalEnvironment = &#123; ... &#125;,  </span></span><br><span class="line"><span class="xml">  VariableEnvironment = &#123; ... &#125;,  </span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><ol><li>This Binding<ol><li>在全局执行上下文中，this 的值指向全局对象，在浏览器中，this 的值指向 window 对象。</li><li>在函数执行上下文中，this 的值取决于函数的调用方式。如果它被一个对象引用调用，那么 this 的值被设置为该对象，否则 this 的值被设置为全局对象或 undefined（严格模式下）。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;  </span><br><span class="line">name: <span class="string">'peter'</span>,  </span><br><span class="line">birthYear: <span class="number">1994</span>,  </span><br><span class="line">calcAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2018</span> - <span class="keyword">this</span>.birthYear);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">person.calcAge();   </span><br><span class="line"><span class="comment">// 'this' 指向 'person', 因为 'calcAge' 是被 'person' 对象引用调用的。</span></span><br><span class="line"><span class="keyword">let</span> calculateAge = person.calcAge;  </span><br><span class="line">calculateAge();  </span><br><span class="line"><span class="comment">// 'this' 指向全局 window 对象,因为没有给出任何对象引用</span></span><br></pre></td></tr></table></figure></li></ol></li><li>词法环境（Lexical Environment）<br>组成<ol><li>对外部环境的引用 对外部环境的引用意味着它可以访问其外部词法环境。</li><li>环境记录（environment record） 环境记录是存储变量和函数声明的实际位置。<ol><li>声明性环境记录 存储变量、函数和参数。一个函数环境包含声明性环境记录。</li><li>对象环境记录 用于定义在全局执行上下文中出现的变量和函数的关联。全局环境包含对象环境记录。<br>类型</li></ol></li><li>全局环境（在全局执行上下文中）是一个没有外部环境的词法环境, 全局环境的外部环境引用为 null。它拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</li><li>函数环境，用户在函数中定义的变量被存储在环境记录中。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。还包括一个arguments对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> c = a + b;  </span><br><span class="line">&#125;  </span><br><span class="line">foo(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// arguments 对象  </span></span><br><span class="line">Arguments: &#123;<span class="number">0</span>: <span class="number">2</span>, <span class="number">1</span>: <span class="number">3</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;,</span><br></pre></td></tr></table></figure></li></ol></li><li>变量环境 它也是一个词法环境，其 EnvironmentRecord 包含了由 VariableStatements 在此执行上下文创建的绑定。<br>在 ES6 中，LexicalEnvironment 组件和 VariableEnvironment 组件的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;  </span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;  </span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> g = <span class="number">20</span>;  </span><br><span class="line">  <span class="keyword">return</span> e * f * g;  </span><br><span class="line">&#125;</span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">// 执行上下文如下</span></span><br><span class="line"><span class="comment">//全局</span></span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  ThisBinding: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  LexicalEnvironment: &#123;   // 只有let const 的变量</span></span><br><span class="line"><span class="xml">    EnvironmentRecord: &#123;  </span></span><br><span class="line"><span class="xml">      Type: "Object",  </span></span><br><span class="line"><span class="xml">      // 标识符绑定在这里  </span></span><br><span class="line"><span class="xml">      a: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,  </span></span><br><span class="line"><span class="xml">      b: <span class="tag">&lt; <span class="attr">uninitialized</span> &gt;</span>,  </span></span><br><span class="line"><span class="xml">      multiply: <span class="tag">&lt; <span class="attr">func</span> &gt;</span>  </span></span><br><span class="line"><span class="xml">    &#125;  </span></span><br><span class="line">    outer: &lt;null&gt;  </span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;   // var</span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: "Object",  </span><br><span class="line">      // 标识符绑定在这里  </span><br><span class="line">      c: undefined,  </span><br><span class="line">    &#125;  </span><br><span class="line">    outer: &lt;null&gt;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">// 函数</span><br><span class="line">FunctionExectionContext = &#123;   </span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line">  LexicalEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: "Declarative",  </span><br><span class="line">      // 标识符绑定在这里  </span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,  // 多的arguments对象</span><br><span class="line">    &#125;,  </span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;  </span><br><span class="line">  &#125;,</span><br><span class="line">  VariableEnvironment: &#123;  </span><br><span class="line">    EnvironmentRecord: &#123;  </span><br><span class="line">      Type: "Declarative",  </span><br><span class="line">      // 标识符绑定在这里  </span><br><span class="line">      g: undefined  </span><br><span class="line">    &#125;,  </span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="red">需要注意的时候 函数只有在执行的时候才有函数执行上下文</font></li></ol><p><font size="16">over</font>, 另外今天把我的<a href="http://120.24.215.228/newClock/" target="_blank" rel="noopener">时钟</a>也就是我的封面图那个钟把日期加了进去</p>]]></content>
    
    <summary type="html">
    
      大清早的学习
    
    </summary>
    
    
    
      <category term="learn" scheme="http://myblog.decade.run/tags/learn/"/>
    
      <category term="javascript" scheme="http://myblog.decade.run/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://myblog.decade.run/2020/05/19/data-structure/"/>
    <id>http://myblog.decade.run/2020/05/19/data-structure/</id>
    <published>2020-05-18T22:34:48.000Z</published>
    <updated>2020-05-19T21:58:58.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单的阐述下数据结构和算法"><a href="#简单的阐述下数据结构和算法" class="headerlink" title="简单的阐述下数据结构和算法"></a>简单的阐述下数据结构和算法</h3><ol><li>数据结构是计算机的基础, 算法是计算机科学</li><li>程序设计 = 数据结构 + 算法</li><li>“数据结构(data structure)是计算机中存储, 组织数据的方式. 通常情况下, 精心选择的数据结构可以带来最秀效率的算法” —–  维基百科</li><li>解决问题的的方法和步骤</li><li>数据结构是离不开算法的</li></ol><div class="note info">            <p>作为正在成长的前端小菜鸟, 自己还是希望在以后面试的时候, 问起这一块的时候自己还是能对答如流. </p>          </div><p>数据结构分为逻辑结构和物理结构</p><ol><li>逻辑结构: 是指数据对象中数据元素之间的相关关系<ol><li>集合结构: 集合中的元素除了同属于一个相同的集合以外, 没有任何关系</li><li>线性结构: 线性结构中数据元素之间是一对一的关系</li><li>树形结构: 数据元素之间存在一种一对多的层次关系</li><li>图形结构: 多对多的关系</li></ol></li><li>物理结构: 是指数据在计算机中的存储形式</li></ol><p>存储方式分为顺序存储和链式存储</p><ol><li>顺序存储: 是把数据元素存放在地址连续的存储单元里, 其数据间的逻辑关系和物理关系是一致的<br><img src="/" class="lazyload" data-src="/img/dsalg/1.png"  alt="顺序存储"></li><li>链式存储: 是把数据元素存放在任意的存储单元里<br><img src="/" class="lazyload" data-src="/img/dsalg/2.png"  alt="链式存储"></li></ol><p>线性结构和非线性结构</p><ol><li>线性结构: 一个有序数据元素的集合，其特点是数据元素之间存在一对一的线性关系</li><li>非线性结构: 各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系</li></ol><h3 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h3><ol><li>数组(array)</li><li>链表(linked list)</li><li>栈(stack)</li><li>队列(queue)</li><li>散列表/哈希表(hash)</li><li>堆(heap)</li><li>图(graph)</li><li>数(tree)</li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>首先我们得明确, javascript中的数组不是真正意义上的数组</p><p>常见语言的数组有以下两个特点: </p><ol><li>不能存放不同类型的数据</li><li>数组的容量不会自动改变</li></ol><div class="note info">            <p>首先数组的存储方式是顺序存储, 所以满足我上面解释的 数据的逻辑关系和物理关系是一致的. 所谓的逻辑关系我的理解就是: 假设当前元素的内存地址存放在0x0000 而且当前元素的大小是8bit, 所以它的下一个元素的内存地址就是0x0001 物理关系就是所有元素的大小都是一致的. </p>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 动态方式生成数组 这里的动态指的是数组长度 */</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// 这里的3可以改成4</span></span><br><span class="line"><span class="comment">/* 静态方式生成数组  这里指的是数组元素*/</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  静态方式生成数组, 系统会根据后面元素的个数自动计算数组长度 </span></span><br><span class="line"><span class="comment">  静态方式生成数组右边的中括号里面不能放数字</span></span><br><span class="line"><span class="comment">  静态方式省略格式创建数组, 不能先声明后赋值, 只能声明的同时赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>因为数组的长度固定, 所以我们会在对数组进行删除和插入操作的时候会很麻烦:</p><ol><li>插入数据: 我们需要把插入位置后面的数据往后移</li><li>删除数据: 我们需要把被删除数据后面的数据往前移</li></ol>]]></content>
    
    <summary type="html">
    
      大清早的学习
    
    </summary>
    
    
    
      <category term="learn" scheme="http://myblog.decade.run/tags/learn/"/>
    
      <category term="数据结构" scheme="http://myblog.decade.run/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>return back</title>
    <link href="http://myblog.decade.run/2020/04/13/return-back/"/>
    <id>http://myblog.decade.run/2020/04/13/return-back/</id>
    <published>2020-04-13T07:55:49.000Z</published>
    <updated>2020-05-18T06:54:09.090Z</updated>
    
    <content type="html"><![CDATA[<p>论文答辩结束, 等待毕业ing<br>为了更好的照顾好自己, 以及自己女朋友, 我先立下几个flag<br>1 更加的爱女朋友(ahhh)<br>2 早上6点起床敲代码<br>3 晚上尽量早点睡!(时间有点难搞, 就怕事情多起来)<br>4 每天尽量更新自己学到的<br>5 算法,数据结构,http等一系列的东西自己找个时间补了吧<br>6 撸源码<br>7 从头开始 我还是个前端小白!!!<br>8 待补充…</p>]]></content>
    
    <summary type="html">
    
      毕业设计答辩论文都over了
    
    </summary>
    
    
    
      <category term="结束啦" scheme="http://myblog.decade.run/tags/%E7%BB%93%E6%9D%9F%E5%95%A6/"/>
    
  </entry>
  
  <entry>
    <title>Hello myBlog</title>
    <link href="http://myblog.decade.run/2020/04/13/Hello-myBlog/"/>
    <id>http://myblog.decade.run/2020/04/13/Hello-myBlog/</id>
    <published>2020-04-13T07:55:49.000Z</published>
    <updated>2020-04-15T03:52:17.728Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于是我的第一篇博客,我把我怎么搭建的复习复习吧! 前期的准备<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">node</a>,<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>,下载好了之后,我顺便把怎么配置node环境(water)写一下吧.</p><h2 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h2><div class="note info">            <p>安装node,傻瓜式安装一直按next即可,中间有个选择盘符,不推荐放在c盘</p>          </div><h2 id="检查node是否安装成功"><a href="#检查node是否安装成功" class="headerlink" title="检查node是否安装成功"></a>检查node是否安装成功</h2><p>先进入cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="/img/hellomyblog/nodev.png"  alt="如果如图有版本提示说明安装成功"></p><div class="note info">            <p>安装完成后目录如下, 另外需要自己手动创建两个文件夹,一个叫node_cache(存放缓存的),node_global(全局安装插件的放这个文件夹)</p>          </div><p><img src="/" class="lazyload" data-src="/img/hellomyblog/nodecomplete.png"  alt="安装完成图片"></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><div class="note info">            <p>说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\Users\用户名\AppData\Roaming\npm】路径中，占C盘空间。</p>          </div><p>创建完两个文件夹后,打开cmd,执行下面的命令,因为我是安装在H盘下的nodejs目录下的,所以你需要自己修改一下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix "H:\nodejs\node_global"</span><br><span class="line">npm config <span class="built_in">set</span> cache "H:\nodejs\node_cache"</span><br></pre></td></tr></table></figure><div class="note info">            <p>由于npm安装插件是从国外下载的,受网络影响大,建议更换成国内淘宝镜像,指令如下</p>          </div><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config <span class="built_in">set</span> disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure><p>上述工作完成后,我们开始配置环境<br>右键单击我的电脑,找到属性,然后找到高级系统设置,找到环境变量<br><img src="/" class="lazyload" data-src="/img/hellomyblog/1.png"  alt="属性,高级系统设置"><br><img src="/" class="lazyload" data-src="/img/hellomyblog/environment.png"  alt="环境变量"></p><p>node_path环境变量:<br>进入环境变量对话框，在系统变量下新建NODE_PATH，输入H:\nodejs\node_global\node_modules，将用户变量下的Path修改为H:\nodejs\node_global<br><img src="/" class="lazyload" data-src="/img/hellomyblog/2.png"  alt="path1"><br><img src="/" class="lazyload" data-src="/img/hellomyblog/3.png"  alt="path2"></p><p><img src="/" class="lazyload" data-src="/img/hellomyblog/4.png"  alt="NODE_PATH"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开cmd 全局安装一个express</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure><p>安装完之后 去你的node_global目录下的node_module找express<br><img src="/" class="lazyload" data-src="/img/hellomyblog/5.png"  alt="express"></p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>一样的傻瓜式安装,看是否安装成功只需要在桌面单击右键,看是否有Git Bush Here, Git GUI Here 就行了<br><img src="/" class="lazyload" data-src="/img/hellomyblog/6.png"  alt="git安装"></p><div class="note default">            <p>因为hexo 推送到github仓库不需要是用git 推送送的 以后再补上吧!!!</p>          </div><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>打开git bush / cmd</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>检查版本</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>第一步初始化hexo</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init yourBlogName</span><br></pre></td></tr></table></figure><p>进入到你yourBlogNameogName这个文件夹,然后执行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> yourBlogName</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>然后一个基本的博客模板就完成了,分析一下文件目录</p><div class="note default">            <p>由于我也是入门小白, 基本的可以去<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a>查看<br>总的用到的以下的几条指令</p>          </div><ol><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li><li>hexo clean 清除之前生成的json文件, public目录下的东西</li><li>hexo g 生成json文件 以及public 目录下的东西</li><li>hexo server 开启服务 访问4000端口即可</li><li>hexo d 这个是你绑定了github仓库 后推代码到仓库的 你需要安装插件</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      这是我的第一篇博客,并且我取了个中二的名字
    
    </summary>
    
    
    
      <category term="learn" scheme="http://myblog.decade.run/tags/learn/"/>
    
      <category term="hexo" scheme="http://myblog.decade.run/tags/hexo/"/>
    
  </entry>
  
</feed>
