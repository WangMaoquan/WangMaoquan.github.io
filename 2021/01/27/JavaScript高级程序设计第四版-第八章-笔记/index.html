<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaScript高级程序设计第四版-第八章-笔记 | 王小明</title><meta name="keywords" content="JavaScript"><meta name="author" content="Decade W"><meta name="copyright" content="Decade W"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript高级程序设计第四版-第八章-笔记">
<meta property="og:url" content="http://blog.decade.run/2021/01/27/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="王小明">
<meta property="og:description" content="笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.decade.run/img/post.jpg">
<meta property="article:published_time" content="2021-01-27T08:21:53.000Z">
<meta property="article:modified_time" content="2021-05-17T17:34:23.665Z">
<meta property="article:author" content="Decade W">
<meta property="article:tag" content="读后笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.decade.run/img/post.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://blog.decade.run/2021/01/27/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript高级程序设计第四版-第八章-笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-18 01:34:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="王小明" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tag</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/post.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">王小明</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tag</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript高级程序设计第四版-第八章-笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-27T08:21:53.000Z" title="发表于 2021-01-27 16:21:53">2021-01-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-17T17:34:23.665Z" title="更新于 2021-05-18 01:34:23">2021-05-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88/">JavaScript高级程序设计第四版</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript高级程序设计第四版-第八章-笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&quot;decade&quot;</span>;</span><br><span class="line">obj.age = <span class="number">20</span>;</span><br><span class="line">obj.job = <span class="string">&quot;coder&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: &quot;decade&quot;, age: 20, job: &quot;coder&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">job</span>: <span class="string">&quot;coder&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;name: &quot;decade&quot;, age: 20, job: &quot;coder&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h4><ol>
<li><p>数据属性</p>
<ul>
<li>[[Configurable]]: 表示属性是否可以通过 delete 删除并重新定义, 是否可以修改它的特性, 以及是否可以把它改为访问器属性,  直接定义在对象里面的属性默认为<code>true</code> </li>
<li>[[Enumerable]]: 表示属性是否可以通过 for-in 循环返回, 直接定义在对象里面的属性默认为 <code>true</code> </li>
<li>[[Writable]]: 表示属性的值是否可以被修改, 直接定义在对象里面的属性默认为 <code>true</code> </li>
<li>[[Value]]: 包含属性实际的值, 默认为 <code>undefined</code> </li>
</ul>
<p>修改属性的默认值, 需要用<code>Object.defineProperty(target, key, propertyObj)</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;dddd decade&quot;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;; <span class="comment">// &#123;name: &quot;dddd decade&quot;,  age: 20&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;DDDD DECADE&quot;</span> <span class="comment">// 修改原来的值</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: &quot;DDDD DECADE&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span> <span class="comment">// 不允许修改 name对应的值</span></span><br><span class="line">&#125;);</span><br><span class="line">obj.name = <span class="string">&quot;dddd decade&quot;</span>; </span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: &quot;DDDD DECADE&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// name age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span> <span class="comment">// 不允许 name  使用for-in</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// age</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name; <span class="comment">// true</span></span><br><span class="line">obj = &#123; ...obj, <span class="attr">name</span>: <span class="string">&#x27;decade&#x27;</span> &#125;; <span class="comment">// &#123;age: 20, name: &quot;decade&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="number">1</span>; <span class="comment">// &#123;age: 20, name: 1&#125;</span></span><br><span class="line"><span class="comment">// 说明新添加的这个name [[Writable]] 为 true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// name age</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明新添加的这个name [[Enumerable]] 为 true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">// 不允许删除</span></span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 不允许修改 name对应的值</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">// 不允许 name  使用for-in</span></span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;decade&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">delete</span> obj.name; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们只给 age属性的 configurable 设置为false</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">// 不允许删除</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值得一提的是 这里的不可修改别的配置 是在你配置过一次配置 后 就不能修改了 如下 (下面的情况仅仅是 之前只配置了configurable: false)</span></span><br><span class="line"><span class="comment">// 第一次配置 只配置了writable 为false 别的enumerable为默认配置为true value为当前的值 是不会报错的</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	Uncaught TypeError: Cannot redefine property: age</span></span><br><span class="line"><span class="comment"> 		at Function.defineProperty (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">		at &lt;anonymous&gt;:1:8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	Uncaught TypeError: Cannot redefine property: age</span></span><br><span class="line"><span class="comment"> 		at Function.defineProperty (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">		at &lt;anonymous&gt;:1:8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">   	<span class="attr">value</span>: <span class="number">22</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问器属性</p>
<ul>
<li>[[Configurable]]: 表示属性是否可以通过 delete 删除并重新定义, 是否可以修改它的特性, 以及是否可以把它改为数据属性, 直接定义在对象里面的属性默认为 <code>true</code></li>
<li>[[Enumerable]]: 表示属性是否可以通过 for-in 循环返回, 直接定义在对象里面的属性默认为 <code>true</code></li>
<li>[[Get]]: 获取函数, 在读取属性的时候调用, 默认 <code>undefined</code></li>
<li>[[Set]]: 设置函数, 在写入属性的时候调用, 默认 <code>undefined</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">_name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">nv</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;name changed&quot;</span>)</span><br><span class="line">        <span class="built_in">this</span>._name = nv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.name; <span class="comment">// decade</span></span><br><span class="line">obj.name = <span class="string">&quot;ddd decade&quot;</span>; <span class="comment">// name changed</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h4><p><code>Object.defineProperties(target, propertiesObj)</code> 方法可以为一个对象定义多个属性,  该方法同时定义的所有的数据属性, <code>configurable, enumerable, writable</code> 默认都是 <code>false</code> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="attr">_name</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&quot;decade&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">nv</span>)</span> &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&quot;name changed&quot;</span>)</span><br><span class="line">        	<span class="built_in">this</span>._name = nv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;_name: &quot;decade&quot;, age: 20&#125;</span></span><br><span class="line">obj.name; <span class="comment">// decade</span></span><br><span class="line">obj.name = <span class="string">&quot;dddd decade&quot;</span>; <span class="comment">// name changed</span></span><br><span class="line">obj.age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改不了</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;_name: &quot;decade&quot;, age: 20&#125;</span></span><br><span class="line"><span class="comment">// 打印不出来</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能修改</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;_name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Uncaught TypeError: Cannot redefine property: _name</span></span><br><span class="line"><span class="comment">    	at Function.defineProperty (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">    	at &lt;anonymous&gt;:1:8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h4><p><code>Object.getOwnPropertyDescriptor(target, key)</code> 获取指定属性的属性描述符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="attr">_name</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&quot;decade&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">nv</span>)</span> &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&quot;name changed&quot;</span>)</span><br><span class="line">        	<span class="built_in">this</span>._name = nv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dataDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;_name&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dataDescriptor); <span class="comment">// &#123;value: &quot;decade&quot;, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"><span class="keyword">const</span> propertyDescriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(propertyDescriptor); <span class="comment">// &#123;enumerable: false, configurable: false, get: ƒ, set: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyDescriptors(target)</code> 获取 <code>target</code> 上每个自有属性的 属性描述符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">like</span>: <span class="string">&quot;coding&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="attr">_name</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&quot;decade&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">nv</span>)</span> &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(<span class="string">&quot;name changed&quot;</span>)</span><br><span class="line">        	<span class="built_in">this</span>._name = nv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> descriptors = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"><span class="built_in">console</span>.log(descriptors);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	&#123;like: &#123;…&#125;, _name: &#123;…&#125;, age: &#123;…&#125;, name: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">		age: &#123;value: 20, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"><span class="comment">		like: &#123;value: &quot;coding&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="comment">		name: &#123;enumerable: false, configurable: false, get: ƒ, set: ƒ&#125;</span></span><br><span class="line"><span class="comment">		_name: &#123;value: &quot;decade&quot;, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h4><p><code>Object.assign()</code> 用于两个对象或者多个对象的合并(混入)  返回修改后的 <code>target</code> 对象</p>
<ul>
<li>源对象的可枚举(Object.propertyIsEnumerable()返回 true)属性</li>
<li>源对象的自有(Object.hasOwnProperty()返回 true)属性</li>
<li>以字符串和符号为键的属性</li>
</ul>
<p>使用源对象上的<code>[[Get]]</code>取得属性的值, 然后使用目标对象上的<code>[[Set]]</code>设置属性的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj === <span class="built_in">Object</span>.assign(obj, &#123;<span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: &quot;decade&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;decade&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型上的 parentName属性</span></span><br><span class="line">CreateObj.prototype.parentName = <span class="string">&quot;father&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> sourceObj = <span class="keyword">new</span> CreateObj();</span><br><span class="line"><span class="keyword">let</span> sourceObj1 = &#123;&#125;;</span><br><span class="line"><span class="comment">// enumerable 为false</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(sourceObj1, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    enumerable 为<span class="literal">false</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;unEnumerable&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(sourceObj1, <span class="string">&quot;like&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;coding&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(sourceObj1, <span class="string">&quot;age&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">22</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面的source 中属性名相同 以最后出现的为主</span></span><br><span class="line"><span class="keyword">let</span> targetObj = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.assign(targetObj, sourceObj, sourceObj1); <span class="comment">// &#123;name: &quot;decade&quot;, age: 22, like: &quot;coding&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果source中里面也有对象, 合并也是浅复制</span></span><br><span class="line"><span class="keyword">let</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> source2 = &#123; <span class="attr">a</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;dddd&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target1, source2);</span><br><span class="line">target1.a === source2.a; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="对象标识及相等判定"><a href="#对象标识及相等判定" class="headerlink" title="对象标识及相等判定"></a>对象标识及相等判定</h4><p>在 ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符合预期的</span></span><br><span class="line"><span class="literal">true</span> === <span class="number">1</span>; <span class="comment">// false</span></span><br><span class="line">(&#123;&#125; === &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;2&quot;</span> === <span class="number">2</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些情况在不同 JavaScript 引擎中表现不同，但仍被认为相等</span></span><br><span class="line">+<span class="number">0</span> === -<span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line">+<span class="number">0</span> === <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line">-<span class="number">0</span> === <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要确定 NaN 的相等性，必须使用极为讨厌的 isNaN()</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>为改善这类情况, ECMAScript 6 规范新增了<code>Object.is()</code> 这个方法与 <code>===</code> 很像, 但同时也考虑到了上述边界情形</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">true</span>, <span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(-<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h4><h5 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h5><p>属性名只要使用变量名(不用再写冒号)就会自动被解释为同名的属性键, 如果没有找到同名变量, 则会抛出 ReferenceError</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;decade&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: &quot;decade&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h5><p>可计算属性表达式中抛出任何错误都会中断对象创建, 如果计算属性的表达式有副作用, 那就要小心了, 因为如果表达式抛出错误,那么之前完成的计算是不能回滚的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">&quot;dddd&quot;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="number">123</span> + <span class="string">&quot;name&quot;</span>]: <span class="string">&quot;key为123name&quot;</span>,</span><br><span class="line">    [key + <span class="string">&quot;decade&quot;</span>]: <span class="string">&quot;key为dddddecade&quot;</span></span><br><span class="line">&#125;; <span class="comment">// &#123;123name: &quot;key为123name&quot;, dddddecade: &quot;key为dddddecade&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="简写方法名"><a href="#简写方法名" class="headerlink" title="简写方法名"></a>简写方法名</h5><p>在给对象定义方法时, 通常都要写一个方法名、冒号, 然后再引用一个匿名函数表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写前</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写后</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算属性简写</span></span><br><span class="line"><span class="keyword">const</span> funcKey = <span class="string">&quot;Name&quot;</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    [say + funcKey](name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用</span></span><br><span class="line"><span class="keyword">const</span> name = obj.name,</span><br><span class="line">      age = obj.age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = obj;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: objName, <span class="attr">age</span>: objAge &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, objName); <span class="comment">// &quot;decade&quot; ,&quot;decade&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(age, objAge); <span class="comment">// 20, 20</span></span><br></pre></td></tr></table></figure>

<p>解构在内部使用函数 <code>ToObject()(不能在运行时环境中直接访问)</code>把源数据结构转换为对象, 这意味着在对象解构的上下文中, 原始值会被当成对象, 这也意味着(根据 ToObject()的定义), <code>null</code>和 <code>undefined</code> 不能被解构</p>
<h5 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">job</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&quot;Front-end development engineer&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> name, age, title;</span><br><span class="line">(&#123; name, age,  <span class="attr">job</span>: &#123; title &#125; &#125; = obj);</span><br><span class="line"><span class="built_in">console</span>.log(name, age, title); <span class="comment">// &quot;decade&quot;, 20, &quot;Front-end development engineer&quot; </span></span><br></pre></td></tr></table></figure>

<h5 id="部分解构"><a href="#部分解构" class="headerlink" title="部分解构"></a>部分解构</h5><p>需要注意的是, 涉及多个属性的解构赋值是一个输出无关的顺序化操作, 如果一个解构表达式涉及多个赋值, 开始的赋值成功而后面的赋值出错, 则整个解构赋值只会完成一部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name, title, age;</span><br><span class="line">(&#123; name, <span class="attr">job</span>: &#123; title &#125;, age &#125; = obj);</span><br><span class="line"><span class="comment">// VM163:7 Uncaught TypeError: Cannot read property &#x27;title&#x27; of undefined at &lt;anonymous&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, title, age); <span class="comment">// &quot;decade&quot; undefined undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="参数上下文匹配"><a href="#参数上下文匹配" class="headerlink" title="参数上下文匹配"></a>参数上下文匹配</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">&#123; name, age &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, i am <span class="subst">$&#123;age&#125;</span> years old`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">print(obj); <span class="comment">// my name is decade, i am 20 years old</span></span><br></pre></td></tr></table></figure>

<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>虽然使用 Object 构造函数或对象字面量可以方便地创建对象, 但这些方式也有明显不足: 创建具有同样接口的多个对象需要重复编写很多代码</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>ECMAScript 5.1 并没有正式支持面向对象的结构, 比如类或继承, 但是巧妙地运用原型式继承也可以成功地模拟同样的行为</p>
<p>ECMAScript 6 开始正式支持类和继承, ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模式, 不过, 无论从哪方面看, ES6 的类都仅仅是封装了 ES5.1 构造函数加原型继承的语法糖而已</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式是一种众所周知的设计模式, 广泛应用于软件工程领域, 用于抽象创建特定对象的过程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = createPerson(<span class="string">&quot;decade&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;Front-end development engineer&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = createPerson(<span class="string">&quot;zio&quot;</span>, <span class="number">21</span>, <span class="string">&quot;Front-end development engineer&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这种工厂模式虽然可以解决创建多个类似对象的问题, 但没有解决对象标识问题(即新创建的对象是什么类型)</p>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.job = job;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;decade&quot;</span>, <span class="number">20</span>, <span class="string">&#x27;Front-end development engineer&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;zio&quot;</span>, <span class="number">21</span>, <span class="string">&#x27;Front-end development engineer&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>没有显式地创建对象</li>
<li>属性和方法直接赋值给了 this</li>
<li>没有 return</li>
</ul>
<p>使用 new 操作符, 调用构造函数会执行如下操作</p>
<ol>
<li>在内存中创建一个新对象</li>
<li>这个新对象内部的<code>[[Prototype]]</code>特性被赋值为构造函数的 <code>prototype</code> 属性</li>
<li>构造函数内部的 this 被赋值为这个新对象</li>
<li>执行构造函数内部的代码 (给新对象添加属性)</li>
<li>如果构造函数返回非空对象, 则返回该对象, 否则, 返回刚创建的新对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor === person2.constructor; <span class="comment">// true</span></span><br><span class="line">person1.constructor === Person; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">person1 <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h5><p>构造函数与普通函数唯一的区别就是调用方式不同, 除此之外, 构造函数也是函数, 并没有把某个函数定义为构造函数的特殊语法, 任何函数只要使用 <code>new</code>操作符调用就是构造函数 , 而不使用 <code>new</code> 操作符调用的函数就是普通函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;decade&quot;</span>, <span class="number">20</span>); </span><br><span class="line">Person(<span class="string">&quot;zio&quot;</span>, <span class="number">21</span>); <span class="comment">// 里面this指向window</span></span><br></pre></td></tr></table></figure>

<p>在调用一个函数而没有明确设置 this 值的情况下<code>(即没有作为对象的方法调用, 或者没有使用 call()/apply()调用)</code>, <code>this</code> 始终指向 <code>Global</code>对象<code>(在浏览器中就是 window 对象)</code></p>
<h5 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h5><p>构造函数虽然有用, 但也不是没有问题, 构造函数的主要问题在于, 其定义的方法会在每个实例上都创建一遍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;decade&quot;</span>, <span class="number">20</span>); </span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;zio&quot;</span>, <span class="number">21</span>); </span><br><span class="line">person1.sayName === person2.sayName; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>所以完全可以单独提出来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sayName = sayName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;decade&quot;</span>, <span class="number">20</span>); </span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;zio&quot;</span>, <span class="number">21</span>); </span><br><span class="line">person1.sayName === person2.sayName; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>不过这样解决也导致了 <code>sayName</code>方法 挂在全局作用域上, 导致可能会有命名冲突</p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>每个函数都会创建一个 <code>prototype</code> 属性, 这个属性是一个对象, 包含应该由特定引用类型的实例共享的属性和方法, 在它上面定义的属性和方法可以被对象实例共享</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;decade&quot;</span>, <span class="number">20</span>); </span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;zio&quot;</span>, <span class="number">21</span>); </span><br><span class="line">person1.sayName === person2.sayName; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h5><p>无论何时, 只要创建一个函数, 就会按照特定的规则为这个函数创建一个 <code>prototype</code> 属性(指向原型对象), 默认情况下, 所有原型对象自动获得一个名为 <code>constructor</code>  的属性, 指回与之关联的构造函数</p>
<ol>
<li>构造函数的实例上的<code>__propt__</code>上的<code>constructor</code> 指向的是该构造函数</li>
<li>构造函数上面的 <code>prototype</code> 上也有个自己生成的 <code>constructor</code>,  该函数也指向该构造函数</li>
<li>构造函数上面的 <code>prototype</code> 上也有个自己生成的 <code>constructor</code>也还有个 <code>prototype</code>, 同理上面也有个<code>constructor</code>, 也指向的是该构造函数</li>
<li>实例上的<code>__proto__</code>就相当于构造函数上的<code>prototype</code> </li>
<li>构造函数Person 上面也有个<code>__proto__</code>属性, 并指向的是 <code>Object</code> , 我们可以理解为 Person构造函数相当于Object的一个实例</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Person &#123;&#125;</span></span><br><span class="line"><span class="comment">		__proto__:</span></span><br><span class="line"><span class="comment">			constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">				arguments: null</span></span><br><span class="line"><span class="comment">				caller: null</span></span><br><span class="line"><span class="comment">				length: 0</span></span><br><span class="line"><span class="comment">				name: &quot;Person&quot;</span></span><br><span class="line"><span class="comment">				prototype:</span></span><br><span class="line"><span class="comment">					constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">					__proto__: Object</span></span><br><span class="line"><span class="comment">				__proto__: ƒ ()</span></span><br><span class="line"><span class="comment">				[[FunctionLocation]]: VM20:1</span></span><br><span class="line"><span class="comment">				[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">			__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person.__proto__.constructor === Person; <span class="comment">// true</span></span><br><span class="line">person.__proto__.constructor === person.__proto__.constructor.prototype.constructor; <span class="comment">// true</span></span><br><span class="line">person.__proto__.constructor === person.__proto__.constructor.prototype.constructor.prototype.constructor; <span class="comment">// true</span></span><br><span class="line">person.__proto__.__proto__.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">Person.__proto__.constructor.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>instanceof</code> 检查实例的原型链中是否包含指定构造函数的原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>isPrototypeOf()</code> 方法会在传入参数的<code>[[Prototype]]</code>指向调用它的对象时返回 <code>true</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.isPrototypeOf(person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Object.getPrototypeOf()</code> 返回参数的内部特性<code>[[Prototype]]</code>的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	&#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">		constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Object.setPrototypeOf()</code> 可以向实例的私有特性<code>[[Prototype]]</code>写入一个新值, <strong>能别用就别用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> changeObj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(person, changeObj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Person &#123;&#125;</span></span><br><span class="line"><span class="comment">		__proto__: </span></span><br><span class="line"><span class="comment">			name: 123</span></span><br><span class="line"><span class="comment">			__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person.__proto__ === changeObj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Object.create()</code> 创建一个对象并为其指明原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	&#123;&#125;</span></span><br><span class="line"><span class="comment">		__proto__: </span></span><br><span class="line"><span class="comment">			name: &quot;decade&quot;</span></span><br><span class="line"><span class="comment">			__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj1) === obj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="原型层级"><a href="#原型层级" class="headerlink" title="原型层级"></a>原型层级</h5><p>在通过对象访问属性时, 会按照这个属性的名称开始搜索, 搜索开始于对象实例本身, 如果在这个实例上发现了给定的名称, 则返回该名称对应的值, 如果没有找到这个属性, 则搜索会沿着指针进入原型对象, 然后在原型对象上找到属性后, 再返回对应的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;zio&quot;</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">&quot;decade&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// person1上有 停止找 </span></span><br><span class="line">person1.name; <span class="comment">// &quot;decade&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person2 上没有 会往上找</span></span><br><span class="line">person2.name; <span class="comment">// &quot;zio&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>hasOwnProperty()</code> 判断属性是否在实例属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.hasOwnProperty(<span class="string">&quot;name&quot;</span>); <span class="comment">// true</span></span><br><span class="line">person2.hasOwnProperty(<span class="string">&quot;name&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="原型和in操作符"><a href="#原型和in操作符" class="headerlink" title="原型和in操作符"></a>原型和in操作符</h5><p>有两种方式使用 <code>in</code>操作符: 单独使用和在 for-in 循环中使用,</p>
<p>在单独使用时，in 操作符会在可以通过对象访问指定属性时返回 <code>true</code>, 无论该属性是在实例上还是在原型上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1; <span class="comment">// true 实例上</span></span><br><span class="line"><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person2; <span class="comment">// true 原型上</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototyProperty</span>(<span class="params">obj, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !obj.hasOwnProperty(property) &amp;&amp; (property <span class="keyword">in</span> obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 <code>for-in</code>中使用</p>
<p>可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person1) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Object.keys()</code> 传入一个对象, 返回该对象所有可枚举属性名称的字符串数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">&quot;decade&quot;</span>; </span><br><span class="line">Person.prototype.age = <span class="number">20</span>; </span><br><span class="line">Person.prototype.job = <span class="string">&quot;Front-end development engineer&quot;</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"> 	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(Person.prototype); <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">&quot;zio&quot;</span>;</span><br><span class="line">person.age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys1 = <span class="built_in">Object</span>.keys(person); <span class="comment">// [&quot;name&quot;, &quot;age&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyNames()</code> 返回所有自身属性, 无论是否可以枚举</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); <span class="comment">//  [&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]</span></span><br></pre></td></tr></table></figure>

<p>在 ECMAScript 6 新增符号类型之后, <code>Object.getOwnPropertySymbols()</code> 返回<code>Symbol</code>键</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k1&#x27;</span>), </span><br><span class="line">    k2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;k2&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> 	[k1]: <span class="string">&#x27;k1&#x27;</span>, </span><br><span class="line"> 	[k2]: <span class="string">&#x27;k2&#x27;</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(o); <span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure>

<h5 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h5><p><code>for-in</code> 循环和 <code>Object.keys()</code>的枚举顺序是不确定的, 取决于 JavaScript 引擎, 可能因浏览器而异</p>
<p><code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code>和 <code>Object.assign()</code>的枚举顺序是确定性的, 先以升序枚举数值键, 然后以插入顺序枚举字符串和符号键</p>
<h4 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h4><p><code>Object.values()</code> 接收一个对象, 返回 该对象值得数组, <code>Object.entries()</code> 接收一个对象, 返回该对象 所有键值对的数组, 这两个方法都不会对<code>Symbol</code>键 返回, 不可枚举的也不会被返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolKey = <span class="built_in">Symbol</span>(<span class="string">&quot;symbolKey&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">job</span>: &#123;&#125;,</span><br><span class="line">    [symbolKey]: <span class="string">&quot;symbol&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;like&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;coding&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// [&quot;decade&quot;, 20, &#123;…&#125;]</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	[Array(2), Array(2), Array(2)]</span></span><br><span class="line"><span class="comment">		0: (2) [&quot;name&quot;, &quot;decade&quot;]</span></span><br><span class="line"><span class="comment">		1: (2) [&quot;age&quot;, 20]</span></span><br><span class="line"><span class="comment">		2: (2) [&quot;job&quot;, &#123;…&#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h5><p>通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法, 这样导致我们不同通过<code>constructor</code>来识别类型, 当然我们可以专门给一个<code>constructor</code>属性 , 不过切记 这样设置的, 会让<code>constructor</code>可枚举</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype = 	&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		age: 20</span></span><br><span class="line"><span class="comment">		name: &quot;decade&quot;</span></span><br><span class="line"><span class="comment">		sayName: ƒ sayName()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">person.constructor === Person; <span class="comment">// false</span></span><br><span class="line">person.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">   	<span class="attr">value</span>: Person</span><br><span class="line">&#125;);</span><br><span class="line">person.constructor === Person; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h5><p>因为从原型上搜索值的过程是动态的, 所以即使实例在修改原型之前已经存在, 任何时候对原型对象所做的修改也会在实例上反映出来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">person;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		sayHi: ƒ ()</span></span><br><span class="line"><span class="comment">		constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person.sayHi(); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>实例只有指向原型的指针, 没有指向构造函数的指针, 下面这个例子就是重写了原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123; </span><br><span class="line"> 	<span class="attr">constructor</span>: Person, </span><br><span class="line"> 	<span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line"> 		<span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;;</span><br><span class="line">person.sayHi(); <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// 未修改之前的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(); <span class="comment">// 修改之后的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		sayHi: ƒ ()</span></span><br><span class="line"><span class="comment">		constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person1.sayHi(); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<h5 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h5><p>原型模式之所以重要, 不仅体现在自定义类型上, 而且还因为它也是实现所有原生引用类型的模式, 所有原生引用类型的构造函数(包括 Object、Array、String 等)都在原型上定义了实例方法, 当然我们也可以自己在原型上定义方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>.prototype.substring; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义一个方法</span></span><br><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123; </span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">this</span>.indexOf(text) === <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;Hello world!&quot;</span>; </span><br><span class="line">msg.startsWith(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="原型问题"><a href="#原型问题" class="headerlink" title="原型问题"></a>原型问题</h5><p>放在原型上的引用类型数据都是共享的, 所以可能会导致, 一个实例修改后, 另一个实例拿到的是修改之后的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Person.prototype.names = [<span class="string">&quot;decade&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.names.push(<span class="string">&quot;zio&quot;</span>);</span><br><span class="line">person2.names.pop(); <span class="comment">// &quot;zio&quot; 本来person2想输出的是 &quot;decade&quot;的</span></span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>很多面向对象语言都支持两种继承: <code>接口继承</code>和<code>实现继承</code>, 前者只继承方法签名, 后者继承实际的方法, 接口继承在 ECMAScript 中是不可能的，因为函数没有签名, 实现继承是 ECMAScript 唯一支持的继承方式, 而这主要是通过原型链实现的</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>每个构造函数都有一个原型对象<code>prototype</code>, 原型有一个属性<code>constructor</code>指回构造函数, 而实例有一个内部指针<code>__proto__</code>指向原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.parentName = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getParentName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.parentName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.childName = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">	constructor: ƒ Child()</span></span><br><span class="line"><span class="comment">	__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 修改 Child的prototype 为 Parnet的实例</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Parent &#123;parentName: &quot;parent&quot;&#125;</span></span><br><span class="line"><span class="comment">	parentName: &quot;parent&quot;</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		getParentName: ƒ ()</span></span><br><span class="line"><span class="comment">		constructor: ƒ Parent()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Child.prototype.getChildName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.childName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Child();</span><br><span class="line">instance.getParentName(); <span class="comment">// &quot;parent&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h5><p>所有引用类型都继承自 Object, 这也是通过原型链实现的, 任何函数的默认原型都是一个 Object 的实例, 这意味着这个实例有一个内部指针指向<code>Object.prototype</code></p>
<h5 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h5><p>原型与实例的关系可以通过两种方式来确定, 第一种方式是使用 <code>instanceof</code> 操作符, 如果一个实例的原型链中出现过相应的构造函数, 则 <code>instanceof</code> 返回 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> Parent; <span class="comment">// true</span></span><br><span class="line">instance <span class="keyword">instanceof</span> Child; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>第二种方式是使用 <code>isPrototypeOf()</code>方法, 原型链中包含这个原型, 这个方法就返回 <code>true</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(instance); <span class="comment">// true</span></span><br><span class="line">Parent.prototype.isPrototypeOf(instance); <span class="comment">// true</span></span><br><span class="line">Child.prototype.isPrototypeOf(instance); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="关于方法"><a href="#关于方法" class="headerlink" title="关于方法"></a>关于方法</h5><p>子类有时候需要覆盖父类的方法, 这样我只需要在子类的<code>prototype</code>上 命名一个和父类上的方法名一样的方法就能覆盖, 增加父类没有方法 同理也是在子类<code>prototype</code>加方法就行, 需要注意的是, 我们必须是在原型上赋值后, 再添加我们需要覆盖或者新增的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.parentName = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getParentName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.parentName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.childName = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.childFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是Parent没有的方法&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype.getParentName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是覆盖Parent上的同名方法&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.childFunc(); <span class="comment">// 这是Parent没有的方法</span></span><br><span class="line">child.getParentName(); <span class="comment">// 这是覆盖Parent上的同名方法</span></span><br></pre></td></tr></table></figure>

<h5 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h5><p>使用原型实现继承时, 原型实际上变成了另一个类型的实例, 意味着原先的实例属性变成为了原型属性, 如果<code>prototype</code>上挂载的是一个引用类型的数据, 就有可能, 出现, 子类实例化后, 还能修改到父类原型上的那个数据</p>
<p>子类型在实例化时不能给父类型的构造函数传参</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.parentName = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.getParentName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.parentName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.childName = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;childName: &quot;child&quot;&#125;</span></span><br><span class="line"><span class="comment">	childName: &quot;child&quot;</span></span><br><span class="line"><span class="comment">	__proto__: Parent</span></span><br><span class="line"><span class="comment">		parentName: &quot;parent&quot;</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h4><p>在子类构造函数中调用父类构造函数</p>
<h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>相比于使用原型链, 盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参</p>
<h5 id="盗用构造函数的问题"><a href="#盗用构造函数的问题" class="headerlink" title="盗用构造函数的问题"></a>盗用构造函数的问题</h5><p>子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式, <code>instanceof</code>不能判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;black&quot;</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.name = <span class="string">&quot;decade&quot;</span>;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.colors.push(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="comment">// 这样两个实例对不会共享 colors</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;colors: Array(3)&#125;</span></span><br><span class="line"><span class="comment">	colors: (3) [&quot;red&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		constructor: ƒ Child()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">child2 <span class="keyword">instanceof</span> Parent; <span class="comment">// false</span></span><br><span class="line">child.name; <span class="comment">// Uncaught ReferenceError: child is not defined</span></span><br><span class="line">child.sayName(); <span class="comment">// Uncaught ReferenceError: child is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>使用原型链继承原型上的属性和方法, 而通过盗用构造函数继承实例属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;black&quot;</span>];</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">&quot;Decade&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;colors: Array(3), name: &quot;Decade&quot;&#125;</span></span><br><span class="line"><span class="comment">	colors: (3) [&quot;red&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="comment">	name: &quot;Decade&quot;</span></span><br><span class="line"><span class="comment">	__proto__: Parent</span></span><br><span class="line"><span class="comment">		colors: (3) [&quot;red&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="comment">		name: undefined</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 能访问父级原型上的方法</span></span><br><span class="line">child.sayName(); <span class="comment">// Decade</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>不自定义类型也可以通过原型实现对象之间的信息共享</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">colors</span>: [<span class="string">&quot;black&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = object(obj);</span><br><span class="line"><span class="keyword">const</span> person2 = object(obj);</span><br><span class="line">person1.name = <span class="string">&quot;zio&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// decade</span></span><br><span class="line">person1.colors.push(<span class="string">&quot;red&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.colors); <span class="comment">// [&quot;black&quot;, &quot;red&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>Object.create(protoObject, [propertiesObject])</code> 第一个参数传入作为返回的参数的原型, 第二个参数可选, 与<code>Object.defineProperties()</code>的第二个参数一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> protoObject = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">colors</span>: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;black&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="built_in">Object</span>.create(protoObject, &#123;</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;age: 20&#125;</span></span><br><span class="line"><span class="comment">	age: 20</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		colors: (2) [&quot;red&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="comment">		name: &quot;decade&quot;</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>创建一个实现继承的函数, 以某种方式增强对象, 然后返回这个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhanceObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> clone = object(obj);</span><br><span class="line">    <span class="comment">// 增强</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;decade&quot;</span>,</span><br><span class="line">    <span class="attr">colors</span>: [<span class="string">&quot;black&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = enhanceObject(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">F &#123;sayHi: ƒ&#125;</span></span><br><span class="line"><span class="comment">	sayHi: ƒ ()</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		colors: [&quot;black&quot;]</span></span><br><span class="line"><span class="comment">		name: &quot;decade&quot;</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h4><p>组合继承存在父类构造函数会被调用两次, 一次是在<code>Child.prototype = new Parent()</code>, 第二次是在<code>Parent.call(this)</code></p>
<p>寄生式组合继承通过盗用构造函数继承属性, 但使用混合式原型链继承方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">Child, Parent</span>) </span>&#123; </span><br><span class="line"> 	<span class="keyword">let</span> prototype = object(Parent.prototype); <span class="comment">// prototype 的原型 是父类的原型</span></span><br><span class="line"> 	prototype.constructor = Child; <span class="comment">// 构造函数记得改回成子类的</span></span><br><span class="line"> 	Child.prototype = prototype; <span class="comment">// 修改子类的prototype</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line">inheritPrototype(Child, Parent);</span><br><span class="line">Child.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">&quot;decade&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;name: &quot;decade&quot;&#125;</span></span><br><span class="line"><span class="comment">	name: &quot;decade&quot;</span></span><br><span class="line"><span class="comment">	__proto__: Parent</span></span><br><span class="line"><span class="comment">		constructor: ƒ Child(name)</span></span><br><span class="line"><span class="comment">		sayHi: ƒ ()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>ECMAScript 6 新引入的 class 关键字具有正式定义类的能力</p>
<h4 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h4><p>与函数类型相似, 定义类也有两种主要方式: 类声明和类表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="keyword">const</span> Personal = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>与函数表达式类似, 类表达式在它们被求值前也不能引用, 不过, 与函数定义不同的是, 虽然函数声明可以提升, 但类定义不能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(funcExp); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> funcExp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(funcExp); <span class="comment">// ƒ () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(funcDec); <span class="comment">// ƒ funcDec() &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcDec</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(funcDec); <span class="comment">// ƒ funcDec() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(classExp); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> classExp = <span class="class"><span class="keyword">class</span> </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(classExp); <span class="comment">// class &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(classDec); <span class="comment">// Uncaught ReferenceError: classDec is not defined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classDec</span> </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(classDec); <span class="comment">// class classDec &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>另一个跟函数声明不同的地方是, 函数受函数作用域限制, 而类受块作用域限制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line"> 	<span class="function"><span class="keyword">function</span> <span class="title">FunctionDec</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"> 	<span class="class"><span class="keyword">class</span> <span class="title">ClassDec</span> </span>&#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(FunctionDec); <span class="comment">// ƒ FunctionDec() &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(ClassDec); <span class="comment">// Uncaught ReferenceError: ClassDec is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h4><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法, 但是这些方法都不是必需的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">myBaz</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qux</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">myQux</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类表达式的名称是可选的, 在把类表达式赋值给变量后, 可以通过 name 属性取得类表达式的名称字符串, 但不能在类表达式作用域外部访问这个标识符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Person, PersonName)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">printName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Person.name, PersonName.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.print(); </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class PersonName &#123;</span></span><br><span class="line"><span class="comment">    print() &#123;</span></span><br><span class="line"><span class="comment">        console.log(Person, PersonName)</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    printName() &#123;</span></span><br><span class="line"><span class="comment">        console.log(Person.name, PersonName.name)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">class PersonName &#123;</span></span><br><span class="line"><span class="comment">    print() &#123;</span></span><br><span class="line"><span class="comment">        console.log(Person, PersonName)</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    printName() &#123;</span></span><br><span class="line"><span class="comment">        console.log(Person.name, PersonName.name)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">person.printName(); <span class="comment">// PersonName PersonName</span></span><br><span class="line">Person; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;constructor: ƒ, print: ƒ, printName: ƒ&#125;</span></span><br><span class="line"><span class="comment">	constructor: class PersonName</span></span><br><span class="line"><span class="comment">		arguments: (...)</span></span><br><span class="line"><span class="comment">		caller: (...)</span></span><br><span class="line"><span class="comment">		length: 0</span></span><br><span class="line"><span class="comment">		name: &quot;PersonName&quot;</span></span><br><span class="line"><span class="comment">		prototype: &#123;constructor: ƒ, print: ƒ, printName: ƒ&#125;</span></span><br><span class="line"><span class="comment">		__proto__: ƒ ()</span></span><br><span class="line"><span class="comment">		[[FunctionLocation]]: VM86:1</span></span><br><span class="line"><span class="comment">		[[Scopes]]: Scopes[3]</span></span><br><span class="line"><span class="comment">	print: ƒ print()</span></span><br><span class="line"><span class="comment">	printName: ƒ printName()</span></span><br><span class="line"><span class="comment">	__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Person.name; <span class="comment">// &quot;PersonName&quot;  打印的是原型上的name属性</span></span><br><span class="line">PersonName; <span class="comment">// Uncaught ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h4><p><code>constructor</code> 关键字用于在类定义块内部创建类的构造函数</p>
<h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><ul>
<li>在内存中创建一个新的对象</li>
<li>这个新对象内部的<code>[[Prototype]]指针</code>被赋值为构造函数的 <code>prototype</code>属性</li>
<li>构造函数内部的<code>this</code> 被赋值为新对象</li>
<li>执行构造函数内部的代码</li>
<li>如果构造函数返回非空对象, 则返回该对象, 否则, 返回刚创建的新对象</li>
</ul>
<p>类实例化时传入的参数会用作构造函数的参数, </p>
<p>默认情况下, 类构造函数会在执行之后返回 this 对象, 如果认为的返回一个对象, 该对象是不会和类有任何关联</p>
<p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用 new 操作符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;decade&quot;</span>);</span><br><span class="line">person.name; <span class="comment">// decade</span></span><br><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;&#125;</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		constructor: class Person</span></span><br><span class="line"><span class="comment">			arguments: (...)</span></span><br><span class="line"><span class="comment">			caller: (...)</span></span><br><span class="line"><span class="comment">			length: 0</span></span><br><span class="line"><span class="comment">			name: &quot;Person&quot;</span></span><br><span class="line"><span class="comment">		prototype: &#123;constructor: ƒ, constructon: ƒ&#125;</span></span><br><span class="line"><span class="comment">		__proto__: ƒ ()</span></span><br><span class="line"><span class="comment">		[[FunctionLocation]]: VM20:1</span></span><br><span class="line"><span class="comment">		[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">	__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> rPerson = <span class="keyword">new</span> RPerson(<span class="string">&quot;decade&quot;</span>);</span><br><span class="line">rPerson.name; <span class="comment">// decade</span></span><br><span class="line">rPerson <span class="keyword">instanceof</span> RPerson; <span class="comment">// false </span></span><br><span class="line">rPerson; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;name: &quot;decade&quot;&#125;</span></span><br><span class="line"><span class="comment">	name: &quot;decade&quot;</span></span><br><span class="line"><span class="comment">	__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FPerson</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FP = FPerson(); <span class="comment">// this指向 window</span></span><br><span class="line"><span class="keyword">const</span> CP = CPerson(); <span class="comment">// Uncaught TypeError: Class constructor CPerson cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="把类当成特殊函数"><a href="#把类当成特殊函数" class="headerlink" title="把类当成特殊函数"></a>把类当成特殊函数</h5><p>ECMAScript 中没有正式的类这个类型, 从各方面来看, ECMAScript 类就是一种特殊函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">typeof</span> Bar; <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p>类标识符有 <code>prototype</code> 属性, 而这个原型也有一个 <code>constructor</code> 属性指向类自身, 这样就可以使用<code>instanceof</code> </p>
<p>类中定义的 <code>constructor</code> 方法不会被当成构造函数, 在对它使用<code>instanceof</code>操作符时会返回 <code>false</code></p>
<p>类是 JavaScript 的一等公民, 因此可以像其他对象或函数引用一样把类作为参数传递</p>
<p>与立即调用函数表达式相似, 类也可以立即实例化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;decade&quot;</span>);</span><br><span class="line">person <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> Person.constructor; <span class="comment">// false</span></span><br><span class="line">person.constructor === Person; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classList = [</span><br><span class="line">    <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">construtor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">classD, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classD(name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person1 = createInstance(classList[<span class="number">0</span>], <span class="string">&quot;decade&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">&quot;decade&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="实例-原型和类成员"><a href="#实例-原型和类成员" class="headerlink" title="实例, 原型和类成员"></a>实例, 原型和类成员</h4><p>类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员, 以及应该存在于类本身的成员</p>
<h5 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h5><p>每次通过new调用类标识符时, 都会执行类构造函数, 在这个函数内部, 可以为新创建的实例<code>this</code>添加””自有”属性, 在构造函数执行完毕后, 仍然可以给实例继续添加新成员</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;black&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;decade&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;zio&quot;</span>);</span><br><span class="line">person1.colors === person2.colors; <span class="comment">// false</span></span><br><span class="line">person1.sayName(); <span class="comment">// &quot;decade&quot;</span></span><br><span class="line">person2.sayName(); <span class="comment">// &quot;zio&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="原型方法与访问器"><a href="#原型方法与访问器" class="headerlink" title="原型方法与访问器"></a>原型方法与访问器</h5><p>为了在实例间共享方法, 类定义语法把在类块中定义的方法作为原型方法</p>
<p>类方法等同于对象属性, 因此可以使用字符串、符号或计算的值作为键</p>
<p>类定义也支持获取和设置访问器, 语法与行为跟普通对象一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loacte = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;prototype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person &#123;loacte: ƒ&#125;</span></span><br><span class="line"><span class="comment">	loacte: () =&gt; &#123; console.log(&quot;instance&quot;); &#125;</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		constructor: class Person</span></span><br><span class="line"><span class="comment">		locate: ƒ locate()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SymbolKey = <span class="built_in">Symbol</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">stringKey</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;stringKey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [SymbolKey]() &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;SymbolKey&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="string">&quot;computed&quot;</span> + <span class="string">&quot;Key&quot;</span>]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;computedKey&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person1();</span><br><span class="line">person1.stringKey(); <span class="comment">// stringKey</span></span><br><span class="line">person1.computedKey(); <span class="comment">// computedKey</span></span><br><span class="line">person1[SymbolKey](); <span class="comment">// SymbolKey</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>._name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person2();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person2 &#123;&#125;</span></span><br><span class="line"><span class="comment">	name: undefined</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		constructor: class Person2</span></span><br><span class="line"><span class="comment">		name: undefined</span></span><br><span class="line"><span class="comment">		get name: ƒ name()</span></span><br><span class="line"><span class="comment">		set name: ƒ name(newName)</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">p.name = <span class="string">&quot;decade&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Person2 &#123;_name: &quot;decade&quot;&#125;</span></span><br><span class="line"><span class="comment">	_name: &quot;decade&quot;</span></span><br><span class="line"><span class="comment">	name: &quot;decade&quot;</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		constructor: class Person2</span></span><br><span class="line"><span class="comment">		name: &quot;decade&quot;</span></span><br><span class="line"><span class="comment">		get name: ƒ name()</span></span><br><span class="line"><span class="comment">		set name: ƒ name(newName)</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h5><p>可以在类上定义静态方法, 这些方法通常用于执行不特定于实例的操作, 也不要求存在类的实例, 与原型成员类似，静态成员每个类上只能有一个, 静态类成员在类定义中使用 <code>static</code> 关键字作为前缀</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.locate = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;instance&quot;</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;prototype&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">locate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;class&quot;</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.locate();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">instance</span></span><br><span class="line"><span class="comment">Person &#123;locate: ƒ&#125;</span></span><br><span class="line"><span class="comment">	locate: () =&gt; console.log(&quot;instance&quot;, this)</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		constructor: class Person</span></span><br><span class="line"><span class="comment">		locate: ƒ locate()</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Person.prototype.locate();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">prototype </span></span><br><span class="line"><span class="comment">&#123;constructor: ƒ, locate: ƒ&#125;</span></span><br><span class="line"><span class="comment">	constructor: class Person</span></span><br><span class="line"><span class="comment">	locate: ƒ locate()</span></span><br><span class="line"><span class="comment">	__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Person.locate();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class </span></span><br><span class="line"><span class="comment">class Person &#123;...&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h5><p>虽然类定义并不显式支持在原型或类上添加成员数据, 但在类定义外部, 可以手动添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.greeting = <span class="string">&#x27;my name is&#x27;</span>;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;decade&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.sayName(); <span class="comment">//  my name is decade</span></span><br></pre></td></tr></table></figure>

<h5 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.names = [<span class="string">&quot;decade&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;zio&quot;</span>, <span class="string">&quot;build&quot;</span>, <span class="string">&quot;drive&quot;</span>, <span class="string">&quot;ooo&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    * <span class="function"><span class="title">createName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;decade&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;zio&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;w&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> * <span class="function"><span class="title">createName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;ooo&quot;</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;build&quot;</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;drive&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> * <span class="built_in">this</span>.names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> person.createName()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// decade zio w</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> Person.createName()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// ooo build drive</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// decade w zio build drive ooo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><h5 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h5><p>ES6 类支持单继承, 使用 <code>extends</code> 关键字, 就可以继承任何拥有<code>[[Construct]]</code>和原型的对象, 这意味着不仅可以继承一个类, 也可以继承普通的构造函数(保持向后兼容)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CParent</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FParent</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> <span class="keyword">extends</span> <span class="title">CParent</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Child1();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child1 &#123;&#125;</span></span><br><span class="line"><span class="comment">	__proto__: CParent</span></span><br><span class="line"><span class="comment">		constructor: class Child1</span></span><br><span class="line"><span class="comment">			arguments: (...)</span></span><br><span class="line"><span class="comment">			caller: (...)</span></span><br><span class="line"><span class="comment">			length: 0</span></span><br><span class="line"><span class="comment">			name: &quot;Child1&quot;</span></span><br><span class="line"><span class="comment">			prototype: CParent &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">			__proto__: class CParent</span></span><br><span class="line"><span class="comment">			[[FunctionLocation]]: VM20:3</span></span><br><span class="line"><span class="comment">			[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> <span class="keyword">extends</span> <span class="title">FParent</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Child2();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child2 &#123;&#125;</span></span><br><span class="line"><span class="comment">	__proto__: FParent</span></span><br><span class="line"><span class="comment">		constructor: class Child2</span></span><br><span class="line"><span class="comment">			length: 0</span></span><br><span class="line"><span class="comment">			name: &quot;Child2&quot;</span></span><br><span class="line"><span class="comment">			prototype: FParent &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">			__proto__: ƒ FParent()</span></span><br><span class="line"><span class="comment">			[[FunctionLocation]]: VM56:1</span></span><br><span class="line"><span class="comment">			[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="构造函数-HomeObject-super"><a href="#构造函数-HomeObject-super" class="headerlink" title="构造函数 ,HomeObject ,  super()"></a>构造函数 ,HomeObject ,  super()</h5><p>派生类的方法可以通过 <code>super</code> 关键字引用它们的原型, 这个关键字只能在派生类中使用, 而且仅限于类构造函数, 实例方法和静态方法内部</p>
<p>在类构造函数中使用 <code>super</code> 可以调用父类构造函数</p>
<p>在静态方法中可以通过 <code>super</code> 调用继承的类上定义的静态方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Parent被实例化了&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Parent print&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Child被实例化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(); <span class="comment">// Parent被实例化了 Child被实例化</span></span><br><span class="line">Child.print(); <span class="comment">// Parent print</span></span><br><span class="line">Parent.print(); <span class="comment">// Parent print</span></span><br></pre></td></tr></table></figure>

<p>ES6 给类构造函数和静态方法添加了内部特性<code>[[HomeObject]]</code>, 这个特性是一个指针, 指向定义该方法的对象, 这个指针是自动赋值的, 而且只能在 JavaScript 引擎内部访问, super 始终会定义为<code>[[HomeObject]]</code>的原型</p>
<ul>
<li>super 只能在派生类构造函数和静态方法中使用</li>
<li>不能单独引用 super 关键字，要么用它调用构造函数，要么用它引用静态方法</li>
<li>调用 super()会调用父类构造函数，并将返回的实例赋值给 this</li>
<li>super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入</li>
<li>如果没有定义类构造函数, 在实例化派生类时会调用 super(), 而且会传入所有传给派生类的参数</li>
<li>在类构造函数中，不能在调用 super()之前引用 this</li>
<li>如果在派生类中显式定义了构造函数, 则要么必须在其中调用 super(), 要么必须在其中返回一个对象</li>
</ul>
<h5 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h5><p>有时候可能需要定义这样一个类, 它可供其他类继承, 但本身不会被实例化, 虽然 ECMAScript 没有专门支持这种类的语法 , 但通过 <code>new.target</code> 也很容易实现。<code>new.target</code> 保存通过 <code>new</code> 关键字调用的类或函数, 通过在实例化时检测 <code>new.target</code> 是不是抽象基类, 可以阻止对抽象基类的实例化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">        <span class="comment">// 这是一个抽象类 本身不允许实例化</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Parent) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Parent cannot be directly instantiated&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.sayHi) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Inheriting class must define sayHi()&#x27;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Child extends Parent &#123;</span></span><br><span class="line"><span class="comment">    constructor() &#123;</span></span><br><span class="line"><span class="comment">        super();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    sayHi() &#123;</span></span><br><span class="line"><span class="comment">        console.log(&quot;hi&quot;)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent(); <span class="comment">// Uncaught Error: Parent cannot be directly instantiated</span></span><br></pre></td></tr></table></figure>

<h5 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h5><p>ES6 类为继承内置引用类型提供了顺畅的机制, 开发者可以方便地扩展内置类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">shuffle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">this</span>.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; </span><br><span class="line">            <span class="keyword">const</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>)); </span><br><span class="line">            [<span class="built_in">this</span>[i], <span class="built_in">this</span>[j]] = [<span class="built_in">this</span>[j], <span class="built_in">this</span>[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> myArr = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">myArr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">myArr <span class="keyword">instanceof</span> MyArray; <span class="comment">// true</span></span><br><span class="line">myArr.shuffle(); <span class="comment">// [4, 2, 5, 3, 1]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MyArray(5) [4, 2, 5, 3, 1]</span></span><br><span class="line"><span class="comment">	0: 4</span></span><br><span class="line"><span class="comment">	1: 2</span></span><br><span class="line"><span class="comment">	2: 5</span></span><br><span class="line"><span class="comment">	3: 3</span></span><br><span class="line"><span class="comment">	4: 1</span></span><br><span class="line"><span class="comment">	length: 5</span></span><br><span class="line"><span class="comment">	__proto__: Array</span></span><br><span class="line"><span class="comment">		constructor: class MyArray</span></span><br><span class="line"><span class="comment">		shuffle: ƒ shuffle()</span></span><br><span class="line"><span class="comment">		__proto__: Array(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>有些内置类型的方法会返回新实例, 默认情况下, 返回实例的类型与原始实例的类型是一致的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> a2 = a1.filter(<span class="function"><span class="params">v</span> =&gt;</span> !!(v % <span class="number">2</span>)); <span class="comment">// [1, 3, 5]</span></span><br><span class="line">a1 <span class="keyword">instanceof</span> MyArray; <span class="comment">// true</span></span><br><span class="line">a2 <span class="keyword">instanceof</span> MyArray; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果想覆盖这个默认行为, 则可以覆盖 <code>Symbol.species</code> 访问器, 这个访问器决定在创建返回的实例时使用的类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">const</span> a2 = a1.filter(<span class="function"><span class="params">v</span> =&gt;</span> !!(v % <span class="number">2</span>)); <span class="comment">// [1, 3, 5]</span></span><br><span class="line">a1 <span class="keyword">instanceof</span> MyArray; <span class="comment">// true</span></span><br><span class="line">a2 <span class="keyword">instanceof</span> MyArray; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="类混入"><a href="#类混入" class="headerlink" title="类混入"></a>类混入</h5><p>把不同类的行为集中到一个类是一种常见的 JavaScript 模式, 虽然 ES6 没有显式支持多类继承, 但通过现有特性可以轻松地模拟这种行为</p>
<p>extends 关键字后面是一个 JavaScript 表达式, 任何可以解析为一个类或一个构造函数的表达式都是有效的, 这个表达式会在求值类定义时被求值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">getParent</span>() </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Child &#123;&#125;</span></span><br><span class="line"><span class="comment">	__proto__: Parent</span></span><br><span class="line"><span class="comment">		constructor: class Child</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>多个类的混入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseC</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fooMixin = <span class="function">(<span class="params">superClass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> barMixin = <span class="function">(<span class="params">superClass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bazMixin = <span class="function">(<span class="params">superClass</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">baz</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;baz&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">fooMixin</span>(<span class="title">barMixin</span>(<span class="title">bazMixin</span>(<span class="title">BaseC</span>))) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Bus();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Bus &#123;&#125;</span></span><br><span class="line"><span class="comment">	__proto__:</span></span><br><span class="line"><span class="comment">		constructor: class Bus</span></span><br><span class="line"><span class="comment">			arguments: (...)</span></span><br><span class="line"><span class="comment">			caller: (...)</span></span><br><span class="line"><span class="comment">			length: 0</span></span><br><span class="line"><span class="comment">			name: &quot;Bus&quot;</span></span><br><span class="line"><span class="comment">			prototype:</span></span><br><span class="line"><span class="comment">				constructor: class Bus</span></span><br><span class="line"><span class="comment">				__proto__:</span></span><br><span class="line"><span class="comment">					constructor: class extends</span></span><br><span class="line"><span class="comment">					foo: ƒ foo()</span></span><br><span class="line"><span class="comment">					__proto__:</span></span><br><span class="line"><span class="comment">						bar: ƒ bar()</span></span><br><span class="line"><span class="comment">						constructor: class extends</span></span><br><span class="line"><span class="comment">						__proto__: BaseC</span></span><br><span class="line"><span class="comment">							baz: ƒ baz()</span></span><br><span class="line"><span class="comment">							constructor: class extends</span></span><br><span class="line"><span class="comment">							__proto__: Object</span></span><br><span class="line"><span class="comment">			__proto__: class extends</span></span><br><span class="line"><span class="comment">			[[FunctionLocation]]: VM53:17</span></span><br><span class="line"><span class="comment">			[[Scopes]]: Scopes[2]</span></span><br><span class="line"><span class="comment">		__proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Decade W</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.decade.run/2021/01/27/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0/">http://blog.decade.run/2021/01/27/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.decade.run" target="_blank">王小明</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/">读后笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/" target="_blank"><img class="post-qr-code-img" src="/"/></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/" target="_blank"><img class="post-qr-code-img" src="/"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/05/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaScript高级程序设计第四版-第九章-笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/25/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript高级程序设计第四版-第七章-笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/02/24/JavaScript高级程序设计第四版-第十二章-笔记/" title="JavaScript高级程序设计第四版-第十二章-笔记"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-24</div><div class="title">JavaScript高级程序设计第四版-第十二章-笔记</div></div></a></div><div><a href="/2021/02/19/JavaScript高级程序设计第四版-第十一章-笔记/" title="JavaScript高级程序设计第四版-第十一章-笔记"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-19</div><div class="title">JavaScript高级程序设计第四版-第十一章-笔记</div></div></a></div><div><a href="/2021/02/07/JavaScript高级程序设计第四版-第十章-笔记/" title="JavaScript高级程序设计第四版-第十章-笔记"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-07</div><div class="title">JavaScript高级程序设计第四版-第十章-笔记</div></div></a></div><div><a href="/2021/02/05/JavaScript高级程序设计第四版-第九章-笔记/" title="JavaScript高级程序设计第四版-第九章-笔记"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-05</div><div class="title">JavaScript高级程序设计第四版-第九章-笔记</div></div></a></div><div><a href="/2021/01/25/JavaScript高级程序设计第四版-第七章-笔记/" title="JavaScript高级程序设计第四版-第七章-笔记"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-25</div><div class="title">JavaScript高级程序设计第四版-第七章-笔记</div></div></a></div><div><a href="/2020/12/22/JavaScript高级程序设计第四版-第六章-笔记/" title="JavaScript高级程序设计第四版-第六章-笔记"><img class="cover" src="/img/post.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-22</div><div class="title">JavaScript高级程序设计第四版-第六章-笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Decade W</div><div class="author-info__description">博客,记录,生活,学习,成长</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">61</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://blog.decade.run/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/WangMaoquan" target="_blank" title="Github"><i class="fa fa-github"></i></a><a class="social-icon" href="/shixindonga@gmail.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">属性的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">定义多个属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">读取属性的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.</span> <span class="toc-text">合并对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A0%87%E8%AF%86%E5%8F%8A%E7%9B%B8%E7%AD%89%E5%88%A4%E5%AE%9A"><span class="toc-number">1.5.</span> <span class="toc-text">对象标识及相等判定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">增强的对象语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%80%BC%E7%AE%80%E5%86%99"><span class="toc-number">1.6.1.</span> <span class="toc-text">属性值简写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.2.</span> <span class="toc-text">可计算属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95%E5%90%8D"><span class="toc-number">1.6.3.</span> <span class="toc-text">简写方法名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">1.7.</span> <span class="toc-text">对象解构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%A7%A3%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">嵌套解构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">部分解构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8C%B9%E9%85%8D"><span class="toc-number">1.7.3.</span> <span class="toc-text">参数上下文匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">构造函数模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B9%9F%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">构造函数也是函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.2.</span> <span class="toc-text">构造函数的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">理解原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%B1%82%E7%BA%A7"><span class="toc-number">2.4.2.</span> <span class="toc-text">原型层级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8Cin%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.4.3.</span> <span class="toc-text">原型和in操作符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%9E%9A%E4%B8%BE%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.4.4.</span> <span class="toc-text">属性枚举顺序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BF%AD%E4%BB%A3"><span class="toc-number">2.5.</span> <span class="toc-text">对象迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8E%9F%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text">其他原型语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-number">2.5.2.</span> <span class="toc-text">原型的动态性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.5.3.</span> <span class="toc-text">原生对象原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.4.</span> <span class="toc-text">原型问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">3.1.</span> <span class="toc-text">原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8E%9F%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">默认原型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.2.</span> <span class="toc-text">原型与继承关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">关于方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.4.</span> <span class="toc-text">原型链的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">盗用构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">3.2.1.</span> <span class="toc-text">传递参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%97%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.2.</span> <span class="toc-text">盗用构造函数的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">3.3.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">3.4.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">3.5.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">3.6.</span> <span class="toc-text">寄生式组合继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">类定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">4.2.</span> <span class="toc-text">类的构成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">类构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.3.1.</span> <span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%8A%E7%B1%BB%E5%BD%93%E6%88%90%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">把类当成特殊函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">4.4.</span> <span class="toc-text">实例, 原型和类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98"><span class="toc-number">4.4.1.</span> <span class="toc-text">实例成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%99%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">原型方法与访问器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.3.</span> <span class="toc-text">静态类方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">4.4.4.</span> <span class="toc-text">非函数原型和类成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.5.</span> <span class="toc-text">迭代器与生成器方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-number">4.5.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%A1%80"><span class="toc-number">4.5.1.</span> <span class="toc-text">继承基础</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-HomeObject-super"><span class="toc-number">4.5.2.</span> <span class="toc-text">构造函数 ,HomeObject ,  super()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-number">4.5.3.</span> <span class="toc-text">抽象基类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.4.</span> <span class="toc-text">继承内置类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%B7%B7%E5%85%A5"><span class="toc-number">4.5.5.</span> <span class="toc-text">类混入</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/24/css-restart/" title="css restart"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="css restart"/></a><div class="content"><a class="title" href="/2021/06/24/css-restart/" title="css restart">css restart</a><time datetime="2021-06-24T11:35:56.000Z" title="发表于 2021-06-24 19:35:56">2021-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/22/webpack-%E5%AD%A6%E4%B9%A0/" title="webpack 学习"><img src="/img/coverimg/webpack.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="webpack 学习"/></a><div class="content"><a class="title" href="/2021/06/22/webpack-%E5%AD%A6%E4%B9%A0/" title="webpack 学习">webpack 学习</a><time datetime="2021-06-22T03:46:24.000Z" title="发表于 2021-06-22 11:46:24">2021-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/11/defineAsyncComponent/" title="defineAsyncComponent"><img src="/img/coverimg/vue.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="defineAsyncComponent"/></a><div class="content"><a class="title" href="/2021/06/11/defineAsyncComponent/" title="defineAsyncComponent">defineAsyncComponent</a><time datetime="2021-06-11T12:32:27.000Z" title="发表于 2021-06-11 20:32:27">2021-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/01/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img src="/img/post.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题"/></a><div class="content"><a class="title" href="/2021/06/01/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a><time datetime="2021-06-01T14:37:33.000Z" title="发表于 2021-06-01 22:37:33">2021-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/30/webpack%E6%90%AD%E5%BB%BAvue3/" title="webpack搭建vue3 chat"><img src="/img/coverimg/webpack.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="webpack搭建vue3 chat"/></a><div class="content"><a class="title" href="/2021/05/30/webpack%E6%90%AD%E5%BB%BAvue3/" title="webpack搭建vue3 chat">webpack搭建vue3 chat</a><time datetime="2021-05-29T18:34:56.000Z" title="发表于 2021-05-30 02:34:56">2021-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Decade W</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,  welcome  to  my  <a  href="http://blog.decade.run/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/lib/autoload.js" async></script></body></html>