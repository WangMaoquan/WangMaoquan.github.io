<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaScript高级程序设计第四版 第三章 笔记 | 王小明</title><meta name="description" content="笔记"><meta name="keywords" content="读后笔记"><meta name="author" content="Decade W"><meta name="copyright" content="Decade W"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><script src="https://code.jquery.com/jquery-3.4.1.min.js"></script><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JavaScript高级程序设计第四版 第三章 笔记"><meta name="twitter:description" content="笔记"><meta name="twitter:image" content="http://blog.decade.run/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript高级程序设计第四版 第三章 笔记"><meta property="og:url" content="http://blog.decade.run/2020/11/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="王小明"><meta property="og:description" content="笔记"><meta property="og:image" content="http://blog.decade.run/img/post.jpg"><meta property="article:published_time" content="2020-11-11T01:31:37.000Z"><meta property="article:modified_time" content="2020-11-18T06:23:06.232Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://blog.decade.run/2020/11/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%94%E8%AE%B0/"><link rel="prev" title="JavaScript高级程序设计第四版-第四章-笔记" href="http://blog.decade.run/2020/11/18/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%94%E8%AE%B0/"><link rel="next" title="element-ui-3-源码学习-4" href="http://blog.decade.run/2020/11/09/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-4/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"LEP83554SS","apiKey":"96fa18c62f7619e2bf35df83ba4aef39","indexName":"...","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":0,"translateDelay":1,"cookieDomain":"https://blog.decade.run/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Decade W","link":"链接: ","source":"来源: 王小明","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"努力,学习","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="王小明" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item Home"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item Archives"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item Tag"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tag</span></a></div><div class="menus_item Categories"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item Link"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item About"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript语法"><span class="toc-number">1.</span> <span class="toc-text">JavaScript语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关键字和保留字"><span class="toc-number">2.</span> <span class="toc-text">关键字和保留字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-number">3.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作符"><span class="toc-number">5.</span> <span class="toc-text">操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语句"><span class="toc-number">6.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">王小明</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item Home"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item Archives"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item Tag"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tag</span></a></div><div class="menus_item Categories"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item Link"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item About"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">JavaScript高级程序设计第四版 第三章 笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-11-11 09:31:37"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-11-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-11-18 14:23:06"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-11-18</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">13.3k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 50 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/11/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%94%E8%AE%B0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/11/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h3 id="JavaScript语法"><a href="#JavaScript语法" class="headerlink" title="JavaScript语法"></a>JavaScript语法</h3><ol>
<li><p>无论是变量, 函数名, 函数名, 都区分大小写</p>
</li>
<li><p><strong><code>标识符</code></strong>: 变量, 函数, 属性或者函数参数的名称, 推荐写法驼峰形式(firstExample )</p>
<ul>
<li>第一个字符必须是一个字母(_),  下划线或者美元符($)</li>
<li>剩下的其他字符可以是字母, 下划线, 美元符号或者数字</li>
</ul>
</li>
<li><p>单行注释用双斜线<code>//</code> 多行用 <code>/* 我是多行注释 */</code></p>
</li>
<li><p>严格模式 <code>use strict</code>;</p>
<ul>
<li><code>ECMAScript 5</code> 增加的严格模式, 就是一个预处理指令</li>
<li>为了针对<code>ECMAScript 3</code>的一些不规范写法, 然后抛出错误</li>
<li>放在js脚本开头, 或者函数体第一行都可以</li>
</ul>
</li>
<li><p><code>ECMAScript</code>中的语句以分号结尾</p>
<ul>
<li><p>最好不要省略分号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> sum1 = a + b; <span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">let</span> sum2 = a + b  <span class="comment">// 不推荐</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>if条件语句在某种情况下也不要省略中括号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">10</span>) </span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">console</span>.log(c)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h3><ol>
<li><p><code>ECMA-262 第 6 版</code>规定的所有关键字如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   break      do         in            typeof</span></span><br><span class="line"><span class="comment">   case       else       instanceof    var</span></span><br><span class="line"><span class="comment">   catch      export     new           void</span></span><br><span class="line"><span class="comment">   class      extends    return        while</span></span><br><span class="line"><span class="comment">   const      finally    super         with</span></span><br><span class="line"><span class="comment">   continue   for        switch        yield</span></span><br><span class="line"><span class="comment">   debugger   function   this</span></span><br><span class="line"><span class="comment">   default    if         throw</span></span><br><span class="line"><span class="comment">   delete     import     try</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ECMA-262 第 6 版</code>为未来保留的关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   始终保留</span></span><br><span class="line"><span class="comment">   enum</span></span><br><span class="line"><span class="comment">  	 </span></span><br><span class="line"><span class="comment">   严格模式保留</span></span><br><span class="line"><span class="comment">   implements    package     public</span></span><br><span class="line"><span class="comment">   interface     protected   static</span></span><br><span class="line"><span class="comment">   let           private</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   模块代码中保留</span></span><br><span class="line"><span class="comment">   await</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><p><strong><code>var</code></strong> 关键字</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">// 没有赋值 默认undefined</span></span><br><span class="line">message = <span class="number">123</span>; <span class="comment">// 赋值 123  </span></span><br><span class="line"><span class="comment">// javascript 是弱类型语言 所以 message可以是赋值为Number, Object, String, Boolean 等类型的</span></span><br><span class="line"><span class="comment">// 这样的写法不推荐</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>var</code>声明作用域  使用 var 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 <code>var</code>在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">"test"</span>;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 执行完 销毁 局部变量message</span></span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 如果在函数内申明的变量 省略了var 如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    message1 = <span class="string">"test1"</span>; <span class="comment">// 这样的message1是一个全局变量 不推荐这么做, 在局部声明全局变量就很离谱</span></span><br><span class="line">&#125;</span><br><span class="line">test1();</span><br><span class="line"><span class="built_in">console</span>.log(message1); <span class="comment">// test1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多个变量时可以用逗号</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>var</code>声明提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// undefined </span></span><br><span class="line"><span class="comment">// 这样执行时不会报错的 因为 var声明提升到函数作用顶部 相当于下面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age; <span class="comment">// 默认undefined</span></span><br><span class="line">    <span class="built_in">console</span>.loe(age);</span><br><span class="line">    age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>let</code>声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 是函数作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Matt'</span>; </span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// Matt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let 是块级作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name1 = <span class="string">'decade'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name1); <span class="comment">// decade</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name1); <span class="comment">// ReferenceError: age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 块作用域 是函数作用域的子集</span></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> name: <span class="comment">// 这样不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age; <span class="comment">// SyntaxError age已经申明过了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'decade'</span>; </span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 'decade' </span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">'zio'</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(name); <span class="comment">// 'zio' </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>; </span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 30 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> age = <span class="number">26</span>; </span><br><span class="line"> <span class="built_in">console</span>.log(age); <span class="comment">// 26 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> name; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>暂时性死区</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// name 会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined </span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'decade'</span>; </span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">name = <span class="string">'decade'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// age 不会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// ReferenceError：age 没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性(var 声明的变量则会)</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'decade'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// decade</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>条件声明</p>
<ol>
<li>在使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它</li>
<li>使用 try/catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。</li>
</ol>
</li>
<li><p><strong>for</strong> 循环中的 <strong>let</strong> 声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">0</span>) <span class="comment">// 5, 5, 5 ,5, 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用let</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, <span class="number">0</span>) <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// ReferenceError 未定义</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>const</strong> 声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>; </span><br><span class="line">age = <span class="number">36</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'decade'</span>; </span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'zio'</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'decade'</span>; </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line"> <span class="keyword">const</span> name = <span class="string">'zio'</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// decade</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 声明的限制只适用于它指向的变量的引用。</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.name = <span class="string">'decade'</span>; <span class="comment">// 这样是没有问题的</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>六种简单数据类型(原始类型): Undefined, Null, Number, Boolean, String, Symbol(ES6新增), 一种复杂数据类型: Object</p>
<ol>
<li><p><code>typeof</code>操作符   <strong><code>不是函数 不是函数 不是函数</code></strong></p>
<ul>
<li>“undefined”  表示值为未定义</li>
<li>“boolean” 表示值为布尔值</li>
<li>“string”  表示值为字符串</li>
<li>“number”  表示值为数字</li>
<li>“object”  表示值为对象或者null</li>
<li>“function”  表示值为函数</li>
<li>“symbol”  表示值为符号(Symbol)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">"some string"</span>; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> message); <span class="comment">// "string" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(message)); <span class="comment">// "string" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">95</span>); <span class="comment">// "number"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Undefined</strong> 类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值</span></span><br><span class="line"><span class="keyword">var</span> name; </span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Null</strong> 类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Null 类型同样只有一个值，即特殊值 null, 逻辑上将null是一个空指针</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">typeof</span> obj; <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boolean</strong> 类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Boolean（布尔值）类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true 和 false</span></span><br><span class="line"><span class="keyword">let</span> win = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> lose = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean()转型函数</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">let</span> messageBoolean = <span class="built_in">Boolean</span>(message);</span><br><span class="line"><span class="built_in">console</span>.log(messageBoolean); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">转换为true的值</th>
<th align="center">转换为false的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean</td>
<td align="center">true</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">非空字符串</td>
<td align="center">空字符串</td>
</tr>
<tr>
<td align="center">Number</td>
<td align="center">非零数值(包括无穷值)</td>
<td align="center">0, NaN</td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">任意对象</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="center">没有</td>
<td align="center">undefined</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Number</strong> 类型</p>
<ul>
<li><p>声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> intNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span>  octalNum = <span class="number">070</span>; <span class="comment">// 八进制的56</span></span><br><span class="line"><span class="keyword">let</span> octalNum = <span class="number">079</span>; <span class="comment">// 八进制没有9 所以 忽略前面的0 当成十进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> hexNum =<span class="number">0xA</span>; <span class="comment">// 十六进制的10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">.1</span>; <span class="comment">// 这样也行 但是不推荐</span></span><br><span class="line"><span class="comment">// 存储浮点值使用的内存空间是存储整数值的两倍, 所以会想法设法的转成整数</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">1.0</span>; <span class="comment">// 1忽略小数点后面的0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 科学计数法表示</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">3.125e7</span>; <span class="comment">// 31250000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>值得范围</p>
<p>​       由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e324；可以表示的最大数值保存在Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正无穷大）表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(result)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NaN</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个特殊的数值叫 NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> / +<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> / <span class="number">0</span>); <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-5</span> / <span class="number">0</span>); <span class="comment">// -Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false NaN不等于任何值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isNaN()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数值转换</p>
<ol>
<li><p>Number()</p>
<p> 布尔值，true 转换为 1，false 转换为 0。 </p>
<p> 数值，直接返回。</p>
<p> null，返回 0。 </p>
<p> undefined，返回 NaN。 </p>
<p> 字符串，应用以下规则。</p>
<p>​     如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number(“1”)返回 1，Number(“123”)返回      123，Number(“011”)返回 11（忽略前面的零）。</p>
<p>​     如果字符串包含有效的浮点值格式如”1.1”，则会转换为相应的浮点值（同样，忽略前面的零）。</p>
<p>​     如果字符串包含有效的十六进制格式如”0xf”，则会转换为与该十六进制值对应的十进制整数值。</p>
<p>​     如果是空字符串（不包含字符），则返回 0。 </p>
<p>​     如果字符串包含除上述情况之外的其他字符，则返回 NaN。 </p>
<p> 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用toString()方法，再按照转换字符串的规则转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"Hello World"</span>)); <span class="comment">// NaN</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">" "</span>)); <span class="comment">// 0</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">"000111"</span>)); <span class="comment">// 111</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>parseInt(str, ?radix)</p>
<p>更专注于字符串是否包含数值模式</p>
<p>字符串最前面的空格会被忽略，从第一个非空格字符开始转换,</p>
<p>如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN</p>
<p>如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"1234a34"</span>)); <span class="comment">// 1234</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"1.2"</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"0xa"</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">""</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"077"</span>)); <span class="comment">// 77</span></span><br></pre></td></tr></table></figure>

<p>如上我输入的是一个8进制的“077” 所以我们需要使用第二参数, 指定进制 范围为2-36,</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"070"</span>, <span class="number">8</span>)); <span class="comment">// 63</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">"078"</span>), <span class="number">8</span>)); <span class="comment">// 7 因为八进制中没有数字8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第二个参数为undefined, 0, 或者未指定的情况下, 相当于让方法根据当前环境来判断是多少进制的</span></span><br><span class="line"><span class="comment">// 现在浏览器一般都是十进制 当然 "0x"开头 会认为是十六进制</span></span><br><span class="line"><span class="comment">// 所以在使用parseInt的时候, 第二个参数最好不要省略</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>parseFloat()</p>
<p>都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"1234a.333"</span>)); <span class="comment">// 1234</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"01.2.3"</span>)); <span class="comment">// 0.1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"xxx"</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>)); <span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
</li>
</ol>
<ol start="6">
<li><p><strong>String</strong> 类型</p>
<p>String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列, 可以用双引号(“”), 单引号(‘’), 反引号(``)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="keyword">let</span> str3 = <span class="string">`hello world`</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符字面量</p>
<table>
<thead>
<tr>
<th align="center">字面量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\n</td>
<td align="center">换行</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">制表</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">退格</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">回车</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">换页</td>
</tr>
<tr>
<td align="center">\\</td>
<td align="center">反斜杠</td>
</tr>
<tr>
<td align="center">&#39;</td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center">&quot;</td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center">`</td>
<td align="center">反引号</td>
</tr>
<tr>
<td align="center">\xnn</td>
<td align="center">以十六进制编码 <em>nn</em> 表示的字符，例如\x41 等于”A”</td>
</tr>
<tr>
<td align="center">\unnnn</td>
<td align="center">以十六进制编码 <em>nnnn</em> 表示的 Unicode 字符，例如\u03a3 等于希腊字</td>
</tr>
</tbody></table>
<p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释</p>
<p>如果字符串中包含双字节字符，那么length 属性返回的值可能不是准确的字符数</p>
</li>
<li><p>字符串的特点</p>
<p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量</p>
</li>
<li><p>转换为字符串</p>
<p>使用几乎所有值都有的 toString()方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> numStr = num.toString(); <span class="comment">// "11"</span></span><br><span class="line"><span class="keyword">let</span> isEdit = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> isEditStr = isEdit.toString(); <span class="comment">// "true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了undefined 和 null 都有toString() 方法 </span></span><br><span class="line"><span class="comment">// toString() 传入一个参数可以转换将原数字 转换成相应进制的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num.toString(<span class="number">2</span>)); <span class="comment">// "1011"</span></span><br></pre></td></tr></table></figure>

<p>如果你不确定是否是<code>undefined</code> 和 <code>null</code> 时你可以使用 <code>String()</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">10</span>)); <span class="comment">// "10" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">true</span>)); <span class="comment">// "true" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">null</span>)); <span class="comment">// "null" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">undefined</span>)); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字面量</p>
<p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"firstLine \n secondLine"</span>;</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">`firstLine</span></span><br><span class="line"><span class="string">secondLine`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); </span><br><span class="line"><span class="comment">// firstLine </span></span><br><span class="line"><span class="comment">// secondLine"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str1); </span><br><span class="line"><span class="comment">// firstLine </span></span><br><span class="line"><span class="comment">// secondLine</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字面量会保持反引号内部的空格</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串插值</p>
<p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">'second'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前，字符串插值是这样实现的：</span></span><br><span class="line"><span class="keyword">let</span> str = value + <span class="string">' to the '</span> + exponent + <span class="string">' power is '</span> + (value * value); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，可以用模板字面量这样实现：</span></span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value * value &#125;</span>`</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 5 to the second power is 25 </span></span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// 5 to the second power is 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有插入的值都会使用 toString()强制转型为字符串</span></span><br><span class="line"><span class="comment">// 模板里面也能直接执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printMessage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`打印的是: <span class="subst">$&#123;printMessage(<span class="string">"wocao"</span>)&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板字面量标签函数</p>
<p>模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleTag</span>(<span class="params">strings, ...rest</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(strings);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> _v <span class="keyword">of</span> rest) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(_v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"foobar"</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>; <span class="comment">// 三个变量 标签函数就是4个参数</span></span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>; </span><br><span class="line"><span class="comment">// ["", " + ", " = ", ""] </span></span><br><span class="line"><span class="comment">// 6 </span></span><br><span class="line"><span class="comment">// 9 </span></span><br><span class="line"><span class="comment">// 15 </span></span><br><span class="line"><span class="built_in">console</span>.log(untaggedResult); <span class="comment">// "6 + 9 = 15" </span></span><br><span class="line"><span class="built_in">console</span>.log(taggedResult); <span class="comment">// "foobar"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原始字符串</p>
<p>使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或 Unicode 字符），而不是被转换后的字符表示。为此，可以使用默认的 String.raw 标签函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode 示例</span></span><br><span class="line"><span class="comment">// \u00A9 是版权符号</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`\u00A9`</span>); <span class="comment">// © </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`\u00A9`</span>); <span class="comment">// \u00A9 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`first line\nsecond line`</span>); </span><br><span class="line"><span class="comment">// first line </span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`first line\nsecond line`</span>); <span class="comment">// "first line\nsecond line"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>Symbol</strong> 类型</p>
<p>Symbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</p>
<ul>
<li><p>基本用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> mySymbol);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以传入一个字符串 作为discription(描述)</span></span><br><span class="line"><span class="keyword">let</span> discriptionSymbol = <span class="built_in">Symbol</span>(<span class="string">"discription"</span>);</span><br><span class="line"><span class="keyword">let</span> discriptionSymvol1 = <span class="built_in">Symbol</span>(<span class="string">"discription"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(discriptionSymbol == discriptionSymvol1); <span class="comment">// fasle</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol()函数不能与 new 关键字一起作为构造函数使用</span></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用全局符号注册表</p>
<p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalSymbol = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol1 = <span class="built_in">Symbol</span>.for(<span class="string">'global'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(globalSymbol === globalSymbol1); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 这里的global将会变成描述</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> globalSymbol2 = <span class="built_in">Symbol</span>.for(<span class="string">"xxx"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(globalSymbol2)); <span class="comment">// xxx</span></span><br><span class="line"><span class="comment">// keyFor() 这个方法接收全局符号，返回该全局符号对应的字符串键(描述), 如果不是返回undefined, 如果传入的不是Symbol 抛出类型错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>(<span class="string">"my"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(mySymbol)); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(<span class="number">123</span>)); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用符号作为属性</p>
<p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"s1"</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">"s2"</span>),</span><br><span class="line">    s3 = <span class="built_in">Symbol</span>(<span class="string">"s3"</span>),</span><br><span class="line">    s4 = <span class="built_in">Symbol</span>(<span class="string">"s4"</span>);</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [s1]: <span class="string">'s1'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;Symbol(s1): s1&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, s2, &#123;<span class="attr">value</span>: <span class="string">"s2"</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//  &#123;Symbol(s1): s1, Symbol(s2): s2&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    [s3]: &#123; <span class="attr">value</span>: <span class="string">"s3"</span> &#125;,</span><br><span class="line">    [s4]: &#123; <span class="attr">value</span>: <span class="string">"s4"</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;Symbol(s1): s1, Symbol(s2): s2, Symbol(s3): s3, Symbol(s4): s4&#125;</span></span><br></pre></td></tr></table></figure>

<p>类似于 Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"s1"</span>),</span><br><span class="line">    s2 = <span class="built_in">Symbol</span>(<span class="string">"s2"</span>),</span><br><span class="line">    s3 = <span class="string">'s3'</span>,</span><br><span class="line">    s4 = <span class="string">'s4'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [s1]: <span class="string">'s1'</span>,</span><br><span class="line">    [s2]: <span class="string">'s2'</span>,</span><br><span class="line">    s3,</span><br><span class="line">    s4</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">// ["s3", "s4"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj)); <span class="comment">// [Symbol(s1), Symbol(s2)]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)); <span class="comment">// &#123;s3: &#123;...&#125;, s4: &#123;...&#125;, Symbol(s1): &#123;...&#125;, Symbol(s2): &#123;...&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj)); <span class="comment">// ["s3", "s4", Symbol(s1), Symbol(s2)]</span></span><br></pre></td></tr></table></figure>

<p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> 	[<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="string">'foo val'</span>, </span><br><span class="line"> 	[<span class="built_in">Symbol</span>(<span class="string">'bar'</span>)]: <span class="string">'bar val'</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(o); <span class="comment">// &#123;Symbol(foo): "foo val", Symbol(bar): "bar val"&#125; </span></span><br><span class="line"><span class="keyword">let</span> barSymbol = <span class="built_in">Object</span>.getOwnPropertySymbols(o) </span><br><span class="line"> .find(<span class="function">(<span class="params">symbol</span>) =&gt;</span> symbol.toString().match(<span class="regexp">/bar/</span>)); </span><br><span class="line"><span class="built_in">console</span>.log(barSymbol); <span class="comment">// Symbol(bar)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用的内置符号</p>
<p>ECMAScript 6 也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。</p>
<p>这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为</p>
<p>这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p>
</li>
<li><p>Symbol.asyncIterator</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的 AsyncIterator。 由 for-await-of 语句使用”。换句话说，这个符号表示实现异步迭代器 API 的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for-await-of 循环会利用这个函数执行异步迭代操作。循环时，它们会调用以 Symbol.asyncIterator为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API的 AsyncGenerator</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="built_in">console</span>.log(test[<span class="built_in">Symbol</span>.asyncIterator]()); <span class="comment">//  AsyncGenerator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p>技术上，这个由 Symbol.asyncIterator 函数生成的对象应该通过其 next()方法陆续返回Promise 实例。可以通过显式地调用 next()方法返回，也可以隐式地通过异步生成器函数返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(max) &#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        <span class="keyword">this</span>.asyncIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.asyncIndex &lt; <span class="keyword">this</span>.max) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="keyword">this</span>.asyncIndex++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span>(<span class="keyword">const</span> v <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncCount();<span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用的next()</span></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br><span class="line">emitter[<span class="built_in">Symbol</span>.asyncIterator]()</span><br><span class="line">  .next()</span><br><span class="line">  .then(<span class="function">(<span class="params">&#123; value, done &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value, done); <span class="comment">// 0 false</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.hasInstance</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例,由 instanceof 操作符使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系。以 Symbol.hasInstance 为键的函数会执行同样的操作，只是操作数对调了一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](foo)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>像之前的<code>Symbol.asyncIterator</code>一样我们也可以自定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFoo</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance] () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myFoo = <span class="keyword">new</span> MyFoo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myFoo <span class="keyword">instanceof</span> Foo); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](myFoo)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myFoo <span class="keyword">instanceof</span> MyFoo); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(MyFoo[<span class="built_in">Symbol</span>.hasInstance](myFoo)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.isConcatSpreadable</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat()打平其数组元素”。覆盖 Symbol.isConcatSpreadable 的值可以修改这个行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1[<span class="built_in">Symbol</span>.isConcatSpreadable]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.concat(arr1)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>; <span class="comment">// false 或者 假值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.cancat(arr1)); <span class="comment">// [1, 2, Array(2)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> likeArr = &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> likeArr1 = &#123;<span class="number">2</span>: <span class="string">'b'</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(likeArr1[<span class="built_in">Symbol</span>.isConcatSpreadable]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(likeArr.concat(likeArr1)); <span class="comment">// ['a', &#123;...&#125;]</span></span><br><span class="line">likeArr1[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(likeArr.concat(likeArr1)); <span class="comment">// ['a', 'b']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.Iterator</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器 API 的函数。for-of 循环这样的语言结构会利用这个函数执行迭代操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123; </span><br><span class="line"> 	*[<span class="built_in">Symbol</span>.iterator]() &#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="built_in">Symbol</span>.iterator]()); <span class="comment">// Generator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure>

<p>技术上，这个由 Symbol.iterator 函数生成的对象应该通过其 next()方法陆续返回值。可以通过显式地调用 next()方法返回，也可以隐式地通过生成器函数返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(max) &#123;</span><br><span class="line">    <span class="keyword">this</span>.max = max;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.max) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">this</span>.index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count(); <span class="comment">// 0, 1, 2, 3, 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用next()</span></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> Emitter(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(emitter[<span class="built_in">Symbol</span>.iterator]().next()) <span class="comment">// &#123; value: undefined, done: false &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.match</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用”。String.prototype.match()方法会使用以 Symbol.match 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.match]); <span class="comment">// ƒ [Symbol.match]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fof'</span>.match(<span class="regexp">/f/</span>)); <span class="comment">// ["f", index: 0, input: "fof", groups: undefined]</span></span><br></pre></td></tr></table></figure>

<p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义 Symbol.match 函数以取代默认对正则表达式求值的行为，从而让match()方法使用非正则表达式实例。Symbol.match 函数接收一个参数，就是调用 match()方法的字符串实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript"</span>;</span><br><span class="line">str.match(); <span class="comment">// ["", index: 0, input: "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript.", groups: undefined]</span></span><br><span class="line">str.match(<span class="string">"number"</span>); <span class="comment">// ["number", index: 16, input: "NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript.", groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">	[<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">        <span class="keyword">return</span> target.includes(<span class="keyword">this</span>.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobar'</span>.match(<span class="keyword">new</span> MyMatcher(<span class="string">'foo'</span>))); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barbaz'</span>.match(<span class="keyword">new</span> MyMatcher(<span class="string">'qux'</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.replace</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用”。String.prototype.replace()方法会使用以 Symbol.replace 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.replace]); <span class="comment">// ƒ [Symbol.replace]() &#123; [native code] &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobarbaz'</span>.replace(<span class="regexp">/bar/</span>, <span class="string">'qux'</span>)); <span class="comment">// 'fooquxbaz'</span></span><br></pre></td></tr></table></figure>

<p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.replace 函数以取代默认对正则表达式求值的行为，从而让replace()方法使用非正则表达式实例。Symbol.replace 函数接收两个参数，即调用 replace()方法的字符串实例和替换字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str.replace(<span class="string">"number"</span>, <span class="string">"Number"</span>); <span class="comment">// "NaN means not a Number. Infinity contains -Infinity and +Infinity in JavaScript"</span></span><br><span class="line">str.replace(<span class="literal">NaN</span>, <span class="string">'nAn'</span>); <span class="comment">// "nAn means not a number. Infinity contains -Infinity and +Infinity in JavaScript"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyReplacer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.replace](target, replacement) &#123;</span><br><span class="line">        <span class="keyword">return</span> target.split(<span class="keyword">this</span>.str).join(replacement);</span><br><span class="line">        <span class="comment">// return false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barfoobaz'</span>.replace(<span class="keyword">new</span> MyReplacer(<span class="string">'foo'</span>), <span class="string">'qux'</span>)); <span class="comment">// "barquxbaz"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.search</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用”。String.prototype.search()方法会使用以 Symbol.search 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.search]); <span class="comment">// ƒ [Symbol.search]() &#123; [native code] &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobar'</span>.search(<span class="regexp">/bar/</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.search 函数以取代默认对正则表达式求值的行为，从而让search()方法使用非正则表达式实例。Symbol.search 函数接收一个参数，就是调用 match()方法的字符串实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.search](target) &#123;</span><br><span class="line">        <span class="keyword">return</span> target.indexOf(<span class="keyword">this</span>.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobar'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'foo'</span>))); <span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barfoo'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'foo'</span>))); <span class="comment">// 3 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barbaz'</span>.search(<span class="keyword">new</span> MySearch(<span class="string">'qux'</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.species</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 Symbol.species 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray1 = <span class="keyword">new</span> MyArray1();</span><br><span class="line"><span class="built_in">console</span>.log(myArray1 <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myArray1 <span class="keyword">instanceof</span> MyArray1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray2 = <span class="keyword">new</span> MyArray2();</span><br><span class="line"><span class="built_in">console</span>.log(myArray2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myArray2 <span class="keyword">instanceof</span> MyArray2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.split</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用”。String.prototype.split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.split]); <span class="comment">// ƒ [Symbol.split]() &#123; [native code] &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'foobarbaz'</span>.split(<span class="regexp">/bar/</span>)); <span class="comment">// ['foo', 'baz']</span></span><br></pre></td></tr></table></figure>

<p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 Symbol.split 函数以取代默认对正则表达式求值的行为，从而让 split()方法使用非正则表达式实例。Symbol.split 函数接收一个参数，就是调用 match()方法的字符串实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpliter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(str) &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.split](target) &#123;</span><br><span class="line">        <span class="keyword">return</span> target.split(<span class="keyword">this</span>.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'barfoobaz'</span>.split(<span class="keyword">new</span> MySpliter(<span class="string">'foo'</span>))); <span class="comment">// ["bar", "baz"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.toPrimitive</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的 Symbol.toPrimitive 属性上定义一个函数可以改变默认行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125; </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + foo); <span class="comment">// "3[object Object]" </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - foo); <span class="comment">// NaN </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(foo)); <span class="comment">// "[object Object]"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyToPrimitive</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123; <span class="comment">// hint 暗示 会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型</span></span><br><span class="line">            <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'number'</span>: </span><br><span class="line">                    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'string primitive'</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'default'</span>: </span><br><span class="line">                    <span class="keyword">return</span> <span class="string">'我是默认值'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mytp = <span class="keyword">new</span> MyToPrimitive();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + mytp); <span class="comment">// 10 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> - mytp); <span class="comment">// -7 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(mytp)); <span class="comment">// "string primitive"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.toStringTag</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用”。通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为”Object”。内置类型已经指定了这个值，但自定义类实例还需要明确定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'MyObject'</span>; <span class="comment">// 这里的xxx 就相当于 你toString() [object xxx]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="built_in">console</span>.log(my) <span class="comment">// MyObject &#123; [Symbol(Symbol.toStringTag)]: 'MyObject' &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(my.toString()); <span class="comment">// [object MyObject]</span></span><br><span class="line"><span class="built_in">console</span>.log(my[<span class="built_in">Symbol</span>.toStringTag]); <span class="comment">// MyObject</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Symbol.unscopables</p>
<p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除”。设置这个符号并让其映射对应属性的键值为 true，就可以阻止该属性出现在 with 环境绑定中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;; </span><br><span class="line"><span class="keyword">with</span> (o) &#123; </span><br><span class="line"> 	<span class="built_in">console</span>.log(foo); <span class="comment">// bar </span></span><br><span class="line">&#125; </span><br><span class="line">o[<span class="built_in">Symbol</span>.unscopables] = &#123; </span><br><span class="line"> 	foo: <span class="literal">true</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">with</span> (o) &#123; </span><br><span class="line"> 	<span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不推荐使用 with，因此也不推荐使用 Symbol.unscopables</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>Object</strong> 类型</p>
<p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>每个 Object 实例都有如下属性和方法。</p>
<ul>
<li><p>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object() 函数。</p>
</li>
<li><p>hasOwnProperty(<em>propertyName</em>)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串或符号。</p>
</li>
<li><p>isPrototypeOf(<em>object</em>)：用于判断当前对象是否为另一个对象的原型</p>
</li>
<li><p>propertyIsEnumerable(<em>propertyName</em>)：用于判断给定的属性是否可以使用）for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</p>
</li>
<li><p>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</p>
</li>
<li><p>toString()：返回对象的字符串表示。</p>
</li>
<li><p>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同</p>
</li>
</ul>
</li>
</ol>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ol>
<li><p>一元操作符</p>
<p>只操作一个值的操作符叫一元操作符（unary operator）一元操作符是 ECMAScript中最简单的操作符</p>
<ul>
<li><p>递增/递减操作符</p>
<p>前加加/前减减 都是先加/减之后的值 再计算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> result = ++num - <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = --num - <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>后加加/后减减 是先计算 再自增/自减</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> result = ++num - <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = --num - <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>参与操作的值 的类型可以为 数字, 字符串, 布尔值, 对象,</p>
<p>都遵循以下的规则: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"2"</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">"z"</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> 	valueOf() &#123; </span><br><span class="line"> 		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</span></span><br><span class="line">s1++; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值</span></span><br><span class="line">s2++; <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值</span></span><br><span class="line"><span class="comment">// 对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。</span></span><br><span class="line">b++; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于浮点值，加 1 或减 1。</span></span><br><span class="line">f++; <span class="comment">// 2.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是对象，则调用其valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他规则。变量类型从对象变成数值</span></span><br><span class="line">o--; <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一元加和减</p>
<p>将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换：布尔值 false和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toString()方法以得到可以转换的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"01"</span>; </span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">"1.1"</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">"z"</span>; </span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>; </span><br><span class="line"><span class="keyword">let</span> o = &#123; </span><br><span class="line"> 	valueOf() &#123; </span><br><span class="line"> 		<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">s1 = +s1; <span class="comment">//  1 </span></span><br><span class="line">s2 = +s2; <span class="comment">//  1.1 </span></span><br><span class="line">s3 = +s3; <span class="comment">// NaN </span></span><br><span class="line">b = +b; <span class="comment">// 0 </span></span><br><span class="line">f = +f; <span class="comment">// 1.1 </span></span><br><span class="line">o = +o; <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>一元减由一个减号（-）表示，放在变量前头，主要用于把数值变成负值，如把 1 转换为-1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> num1 = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>对数值使用一元减会将其变成相应的负值（如上面的例子所示）。在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = -s1; <span class="comment">// -1 </span></span><br><span class="line">s2 = -s2; <span class="comment">// -1.1 </span></span><br><span class="line">s3 = -s3; <span class="comment">// NaN </span></span><br><span class="line">b = -b; <span class="comment">// 0 </span></span><br><span class="line">f = -f; <span class="comment">// -1.1 </span></span><br><span class="line">o = -o; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>位操作符</p>
<p>有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式</p>
<p>正值以真正的二进制格式存储，即 31位中的每一位都代表 2 的幂</p>
<p>负值以一种称为二补数（或补码）的二进制编码存储</p>
<ul>
<li><p>按位非 (按位取反)</p>
<p>按位非操作符用波浪符（~）表示，它的作用是返回数值的一补数。按位非是 ECMAScript 中为数不多的几个二进制数学操作符之一</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> num1 = ~num;</span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">// -31</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">30</th>
</tr>
</thead>
<tbody><tr>
<td align="center">二进制</td>
<td align="center">0000 0000 0000 0000 0000 0000 0001 1110</td>
</tr>
<tr>
<td align="center">按位非</td>
<td align="center">1111 1111 1111 1111 1111 1111  1110 0001</td>
</tr>
<tr>
<td align="center">减1</td>
<td align="center">1111 1111 1111 1111 1111 1111 1110 0000</td>
</tr>
<tr>
<td align="center">取反</td>
<td align="center">1000 0000 0000 0000 0000 0000 0001 1111</td>
</tr>
<tr>
<td align="center">按位非十进制</td>
<td align="center">-31</td>
</tr>
</tbody></table>
<p>按位非操作符作用到了数值 25，得到的结果是26。由此可以看出，按位非的最终效果是对数值取反并减 1</p>
</li>
<li><p>按位与</p>
<p>按位与操作符用和号（&amp;）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作</p>
<p>两个都是1 才为1</p>
<table>
<thead>
<tr>
<th align="center">第一个数值位</th>
<th align="center">第二个数值位</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">28</span> &amp; <span class="number">9</span>; <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">28</td>
<td align="center">0000 0000 0000 0000 0000 0000 0001 1100</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">0000 0000 0000 0000 0000 0000 0000 1001</td>
</tr>
<tr>
<td align="center">最后结果</td>
<td align="center">0000 0000 0000 0000 0000 0000 0000 1000</td>
</tr>
</tbody></table>
</li>
<li><p>按位或</p>
<p>按位或操作符用管道符（|）表示，同样有两个操作数  有1才为1</p>
<table>
<thead>
<tr>
<th align="center">第一个数值位</th>
<th align="center">第二个数值位</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">28</span> | <span class="number">9</span>; <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">28</td>
<td align="center">0000 0000 0000 0000 0000 0000 0001 1100</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">0000 0000 0000 0000 0000 0000 0000 1001</td>
</tr>
<tr>
<td align="center">最后结果</td>
<td align="center">0000 0000 0000 0000 0000 0000 0001 1101</td>
</tr>
</tbody></table>
</li>
<li><p>按位异或</p>
<p>按位异或用脱字符（^）表示，同样有两个操作数 有且只有一个为1 才是1</p>
<table>
<thead>
<tr>
<th align="center">第一个数值位</th>
<th align="center">第二个数值位</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">28</span> ^ <span class="number">9</span>; <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">28</td>
<td align="center">0000 0000 0000 0000 0000 0000 0001 1100</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">0000 0000 0000 0000 0000 0000 0000 1001</td>
</tr>
<tr>
<td align="center">最后结果</td>
<td align="center">0000 0000 0000 0000 0000 0000 0001 0101</td>
</tr>
</tbody></table>
</li>
<li><p>左移</p>
<p>左移操作符用两个小于号（&lt;&lt;）表示，会按照指定的位数将数值的所有位向左移动</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ov = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> nv = <span class="number">3</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">3</td>
<td align="center">0000 0000 0000 0000 0000 0000 0000 0011</td>
</tr>
<tr>
<td align="center">&lt;&lt; 2</td>
<td align="center">0000 0000 0000 0000 0000 0000 0000 1100</td>
</tr>
</tbody></table>
<p>左移是会保留符号的</p>
</li>
<li><p>有符号右移</p>
<p>有符号右移由两个大于号（&gt;&gt;）表示，会将数值的所有 32 位都向右移，同时保留符号（正或负）有符号右移实际上是左移的逆运算</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ov = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> nv = <span class="number">12</span> &gt;&gt; <span class="number">2</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">12</td>
<td align="center">0000 0000 0000 0000 0000 0000 0000 1100</td>
</tr>
<tr>
<td align="center">&gt;&gt; 2</td>
<td align="center">0000 0000 0000 0000 0000 0000 0000 0011</td>
</tr>
</tbody></table>
</li>
<li><p>无符号右移</p>
<p>无符号右移用 3 个大于号表示（&gt;&gt;&gt;），会将数值的所有 32 位都向右移。</p>
<p>对于正数，无符号右移与有符号右移结果相同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ov = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> nv = ov &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>对于负数, 无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ov = <span class="number">-12</span>; <span class="comment">// 负数在javascript中存储的是 绝对值的反码的再加一</span></span><br><span class="line"><span class="keyword">let</span> nv = ov &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">// 1073741821</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">-12</th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">绝对值的二进制</td>
<td align="center">0000 0000 0000 0000 0000 0000 0000 1100</td>
</tr>
<tr>
<td align="center">反码</td>
<td align="center">1111 1111 1111 1111 1111 1111 1111 0011</td>
</tr>
<tr>
<td align="center">补码</td>
<td align="center">1111 1111 1111 1111 1111 1111 1111 0100</td>
</tr>
<tr>
<td align="center">&gt;&gt;&gt; 2</td>
<td align="center">0011 1111 1111 1111 1111 1111 1111 1101</td>
</tr>
<tr>
<td align="center">转为10进制</td>
<td align="center">1073741821</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>布尔操作符</p>
<ul>
<li><p>逻辑非</p>
<p>逻辑非操作符由一个叹号（!）表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反.</p>
<ol>
<li>如果操作数是对象,  返回 <code>false</code></li>
<li>如果操作数是空字符串, 返回 <code>true</code></li>
<li>如果操作数是非空字符串, 返回 <code>false</code></li>
<li>如果操作数是0, 返回 <code>true</code></li>
<li>如果操作数是非0(包括Infinity), 返回 <code>false</code></li>
<li>如果操作数是null, 返回 <code>true</code></li>
<li>如果操作数是NaN, 返回 <code>true</code></li>
<li>如果操作数是undefined, 返回 <code>true</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果操作数是对象,  返回false</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(!obj); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是空字符串, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">""</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是非空字符串, 返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="string">"1"</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是0, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是非0(包括Infinity), 返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是null, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是NaN, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果操作数是undefined, 返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号（!!），相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值</p>
</li>
<li><p>逻辑与</p>
<p>逻辑与操作符由两个和号（&amp;&amp;）表示，应用到两个值</p>
<table>
<thead>
<tr>
<th align="center">第一个操作数</th>
<th align="center">第二个操作数</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">true</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值</p>
<ol>
<li>如果第一个操作数是对象, 则返回第二个操作数</li>
<li>如果第二个操作数是对象, 则只有在第一个操作数为t<code>true</code> 时返回对象</li>
<li>如果两个操作数都是对象, 则返回第二个对象</li>
<li>如果第一个操作符是null, 则返回null</li>
<li>如果第一个操作数是NaN, 则返回NaN</li>
<li>如果第一个操作数是undefined, 则返回undefined</li>
</ol>
<p>大概意思就是 只有在第一个操作数为真的情况下 才会返回或者执行第二个操作数</p>
</li>
<li><p>逻辑或</p>
<p>逻辑或操作符由两个管道符（||）表示</p>
<table>
<thead>
<tr>
<th align="center">第一个操作数</th>
<th align="center">第二个操作数</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true</td>
<td align="center">false</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">false</td>
<td align="center">false</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值</p>
<ol>
<li>如果第一个操作数是对象, 则返回第一个操作数</li>
<li>如果第一个操作数是false, 则返回第二个操作数</li>
<li>如果两个操作数都是对象, 则返回第一个操作数</li>
<li>如果两个操作数都是null, 返回null</li>
<li>如果两个操作数都是NaN, 返回NaN</li>
<li>如果两个操作数都是undefined, 返回undefined</li>
</ol>
<p>大概意思就是, 只要第一个操作数为真, 返回第一个, 否则返回第二个</p>
</li>
</ul>
</li>
<li><p>乘性操作符</p>
<p>ECMAScript 定义了 3 个乘性操作符：乘法、除法和取模.  在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有</p>
<p>不是数值的操作数，则该操作数会在后台被使用 Number()转型函数转换为数值</p>
<ul>
<li><p>乘法操作符</p>
<p>乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积</p>
<ol>
<li>如果操作数都是数值, 该怎么来怎么来, 结果不能表示会得到<code>Infinity</code> 或者 <code>-Infinity</code></li>
<li>如果有一个操作数是NaN, 则返回NaN</li>
<li>如果是Infinity乘以0, 返回NaN</li>
<li>如果是Infinity乘以非0, 则根据第二个操作数的符号返回 <code>Infinity</code> 或者 <code>-Infinity</code></li>
<li>如果是Infinity 乘以 Infinity, 返回 <code>Infinity</code></li>
<li>如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则</li>
</ol>
</li>
<li><p>除法操作符</p>
<p>除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商</p>
<ol>
<li>如果操作数都是数值, 该怎么算怎么算</li>
<li>如果有任一操作数是 NaN，则返回 NaN</li>
<li>如果是 Infinity 除以 Infinity，则返回 NaN</li>
<li>如果是 0 除以 0，则返回 NaN</li>
<li>如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或-Infinity</li>
<li>如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或-Infinity</li>
<li>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则</li>
</ol>
</li>
<li><p>取模操作符</p>
<p>取模（余数）操作符由一个百分比符号（%）表示</p>
<ol>
<li>取模（余数）操作符由一个百分比符号（%）表示</li>
<li>如果被除数是无限值，除数是有限值，则返回 NaN</li>
<li>如果被除数是有限值，除数是 0，则返回 NaN</li>
<li>如果是 Infinity 除以 Infinity，则返回 NaN</li>
<li>如果被除数是有限值，除数是无限值，则返回被除数</li>
<li>如果被除数是 0，除数不是 0，则返回 0</li>
<li>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则</li>
</ol>
</li>
</ul>
</li>
<li><p>指数操作符</p>
<p>ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 9 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> ** <span class="number">2</span>); <span class="comment">// 9 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">16</span>, <span class="number">0.5</span>); <span class="comment">// 4 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">16</span>** <span class="number">0.5</span>); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>; </span><br><span class="line">squared **= <span class="number">2</span>; </span><br><span class="line"><span class="built_in">console</span>.log(squared); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加性操作符</p>
<ul>
<li><p>加法操作符</p>
<p>加法操作符（+）用于求两个数的和</p>
<p>如果两个都是数字:</p>
<ol>
<li>如果有任一操作数是 NaN，则返回 NaN</li>
<li>如果是 Infinity 加 Infinity，则返回 Infinity</li>
<li>如果是-Infinity 加-Infinity，则返回-Infinity</li>
<li>如果是 Infinity 加-Infinity，则返回 NaN</li>
<li>如果是+0 加+0，则返回+0</li>
<li>如果是-0 加+0，则返回+0</li>
<li>如果是-0 加-0，则返回-0</li>
</ol>
<p>如果有一个是字符串</p>
<ol>
<li>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起</li>
<li>如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则</li>
</ol>
</li>
<li><p>减法操作符</p>
<p>减法操作符（-）也是使用很频繁的一种操作符</p>
<ol>
<li>如果两个操作数都是数值，则执行数学减法运算并返回结果</li>
<li>如果有任一操作数是 NaN，则返回 NaN</li>
<li>如果是 Infinity 减 Infinity，则返回 NaN</li>
<li>如果是-Infinity 减-Infinity，则返回 NaN</li>
<li>如果是 Infinity 减-Infinity，则返回 Infinity</li>
<li>如果是-Infinity 减 Infinity，则返回-Infinity</li>
<li>如果是+0 减+0，则返回+0</li>
<li>如果是+0 减-0，则返回-0</li>
<li>如果是-0 减-0，则返回+0</li>
<li>如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算</li>
<li>如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。</li>
</ol>
</li>
</ul>
</li>
<li><p>关系操作符</p>
<p>关系操作符执行比较两个值的操作，包括小于（&lt;）、大于（&gt;）、小于等于（&lt;=）和大于等于（&gt;=）这几个操作符都返回布尔值</p>
<ol>
<li>如果操作数都是数值，则执行数值比较。</li>
<li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码</li>
<li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较</li>
<li>如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较</li>
<li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li>
</ol>
</li>
<li><p>相等操作符</p>
<ul>
<li><p>等于和不等于</p>
<p>ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进行类型转换（通常称为强制类型转换）再确定操作数是否相等</p>
<ol>
<li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等</li>
<li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较</li>
<li>null 和 undefined 相等</li>
<li>null 和 undefined 不能转换为其他类型的值再进行比较</li>
<li>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则，NaN 不等于 NaN</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true。否则，两者不相等</li>
</ol>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">null == undefined</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">“NaN” == NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">5 == NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN == NaN</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">NaN != NaN</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">false == 0</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true == 1</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">true == 2</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">undefined == 0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">null == 0</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">“5” == 5</td>
<td align="center">true</td>
</tr>
</tbody></table>
</li>
<li><p>全等与不全等</p>
<p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true</p>
<p>由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性</p>
</li>
</ul>
</li>
<li><p>条件操作符</p>
<p>条件操作符是 ECMAScript 中用途最为广泛的操作符之一 (三元运算)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值操作符</p>
<p>简单赋值用等于号（=）表示，将右手边的值赋给左手边的变量</p>
<ul>
<li>乘后赋值（*=）</li>
<li>除后赋值（/=）</li>
<li>取模后赋值（%=）</li>
<li>加后赋值（+=）</li>
<li>减后赋值（-=）</li>
<li>左移后赋值（&lt;&lt;=）</li>
<li>右移后赋值（&gt;&gt;=）</li>
<li>无符号右移后赋值（&gt;&gt;&gt;=）</li>
</ul>
</li>
<li><p>逗号操作符</p>
<p>逗号操作符可以用来在一条语句中执行多个操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMA-262 描述了一些语句（也称为流控制语句），而 ECMAScript 中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令</p>
<ol>
<li><p>if语句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statement2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>do-while语句</p>
<p>do-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line"> 	statement </span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure>
</li>
<li><p>while语句</p>
<p>while 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while 循环体内的代码有可能不会执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for语句</p>
<p>for 语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; expression; post-loop-expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for-in语句</p>
<p>for-in 语句是一种严格的迭代语句，用于枚举对象中的<strong>非符号</strong>键属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (property <span class="keyword">in</span> expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-in 语句不能保证返回对象属性的顺序, 如果 for-in 循环要迭代的变量是 null 或 undefined，则不执行循环体</p>
</li>
<li><p>for-of语句</p>
<p>for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (property <span class="keyword">of</span> expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-of 循环会按照可迭代对象的 next()方法产生值的顺序迭代元素</p>
<p>如果尝试迭代的变量不支持迭代，则 for-of 语句会抛出错误。</p>
</li>
<li><p>标签语句</p>
<p>标签语句用于给语句加标签</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label: statement</span><br></pre></td></tr></table></figure>
</li>
<li><p>break 和 continuey语句</p>
<p>break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// i=5时 满足条件 直接退出for循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    num++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// i=5时 满足条件, 退出当前的循环, 所以不会执行num++ i=10时  也不会执行 num++</span></span><br><span class="line">    &#125;</span><br><span class="line">    num1++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>break 和 continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>; </span><br><span class="line">outermost: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; </span><br><span class="line"> 		<span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123; </span><br><span class="line"> 			<span class="keyword">break</span> outermost; <span class="comment">// 只是一个break不会跳出i的循环 但是加了标签 所以相当于跳出了两层for循环</span></span><br><span class="line"> 		&#125; </span><br><span class="line"> 		num++; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">0</span>; </span><br><span class="line">outermost: </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line"> 	<span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; </span><br><span class="line"> 		<span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123; </span><br><span class="line"> 			<span class="keyword">continue</span> outermost; <span class="comment">// 也是跳出两层循环 相当于从 i = 6 开始 之前也就少了 i = 5时, j = 5, 6, 7, 8, 9 num1少自增了5次</span></span><br><span class="line"> 		&#125; </span><br><span class="line"> 		num1++; </span><br><span class="line"> 	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(num1); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>with语句</p>
<p>with 语句的用途是将代码作用域设置为特定的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有使用with</span></span><br><span class="line"><span class="keyword">let</span> qs = location.search.substring(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">let</span> hostName = location.hostname; </span><br><span class="line"><span class="keyword">let</span> url = location.href;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with</span></span><br><span class="line"><span class="keyword">with</span> (location) &#123; </span><br><span class="line"> 	<span class="keyword">let</span> qs = search.substring(<span class="number">1</span>); </span><br><span class="line"> 	<span class="keyword">let</span> hostName = hostname; </span><br><span class="line"> 	<span class="keyword">let</span> url = href; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>严格模式不允许使用 with 语句，否则会抛出错误</p>
<p>由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with语句。</p>
</li>
<li><p>switch 语句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123; </span><br><span class="line"> 	<span class="keyword">case</span> value1: </span><br><span class="line"> 		statement </span><br><span class="line"> 		<span class="keyword">break</span>; </span><br><span class="line"> 	<span class="keyword">case</span> value2: </span><br><span class="line"> 		statement </span><br><span class="line"> 		<span class="keyword">break</span>; </span><br><span class="line"> 	<span class="keyword">case</span> value3: </span><br><span class="line"> 		statement </span><br><span class="line"> 		<span class="keyword">break</span>; </span><br><span class="line"> 	<span class="keyword">case</span> value4: </span><br><span class="line"> 		statement </span><br><span class="line"> 		<span class="keyword">break</span>; </span><br><span class="line"> 	<span class="keyword">default</span>: </span><br><span class="line"> 		statement </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为避免不必要的条件判断，最好给每个条件后面都加上 break 语句</p>
<p>switch 语句在比较每个条件的值时会使用全等操作符</p>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Decade W</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.decade.run/2020/11/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%94%E8%AE%B0/">http://blog.decade.run/2020/11/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.decade.run" target="_blank">王小明</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0/">读后笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/11/18/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E7%89%88-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%AC%94%E8%AE%B0/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaScript高级程序设计第四版-第四章-笔记</div></div></a></div><div class="next-post pull_right"><a href="/2020/11/09/element-ui-3-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-4/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">element-ui-3-源码学习-4</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/02/05/JavaScript高级程序设计第四版-第九章-笔记/" title="JavaScript高级程序设计第四版-第九章-笔记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-02-05</div><div class="relatedPosts_title">JavaScript高级程序设计第四版-第九章-笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2021/02/07/JavaScript高级程序设计第四版-第十章-笔记/" title="JavaScript高级程序设计第四版-第十章-笔记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-02-07</div><div class="relatedPosts_title">JavaScript高级程序设计第四版-第十章-笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/25/JavaScript高级程序设计第四版-第七章-笔记/" title="JavaScript高级程序设计第四版-第七章-笔记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-25</div><div class="relatedPosts_title">JavaScript高级程序设计第四版-第七章-笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2020/11/19/JavaScript高级程序设计第四版-第五章-笔记/" title="JavaScript高级程序设计第四版-第五章-笔记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-11-19</div><div class="relatedPosts_title">JavaScript高级程序设计第四版-第五章-笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/27/JavaScript高级程序设计第四版-第八章-笔记/" title="JavaScript高级程序设计第四版-第八章-笔记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-27</div><div class="relatedPosts_title">JavaScript高级程序设计第四版-第八章-笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2020/11/18/JavaScript高级程序设计第四版-第四章-笔记/" title="JavaScript高级程序设计第四版-第四章-笔记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-11-18</div><div class="relatedPosts_title">JavaScript高级程序设计第四版-第四章-笔记</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  appId: 'WzoNQ79zXHpLGhYhAiHrDU9m-gzGzoHsz',
  appKey: 'Nhmax4ME4ul4BPqWy3GGqIFq',
  placeholder: 'Please leave your footprints',
  avatar: '',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: true,
  serverURLs: '',
  mathjax: false
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Decade W</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi,  welcome  to  my  <a  href="http://blog.decade.run/">blog</a>!</div><div class="icp"><a href="http://beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>互联网ICP备案:渝ICP备19015868号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Search</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="106,90,205" opacity="0.7" zIndex="-1" count="199" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script><div class="waifu"><div class="hide-button">隐藏</div><div class="waifu-tips"></div><canvas class="live2d" id="live2d" width="200" height="300"></canvas></div><script src="/lib/waifu-tips.js" async></script><script src="/lib/live2d.js"></script><script src="/lib/run.js"></script></body></html>